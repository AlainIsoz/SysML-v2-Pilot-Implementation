/*
 * generated by Xtext 2.12.0
 */
package org.omg.sysml.owl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.omg.sysml.owl.owl.Annotation;
import org.omg.sysml.owl.owl.AnnotationAssertion;
import org.omg.sysml.owl.owl.AnnotationProperty;
import org.omg.sysml.owl.owl.AnnotationPropertyDomain;
import org.omg.sysml.owl.owl.AnnotationPropertyRange;
import org.omg.sysml.owl.owl.AnnotationSubject;
import org.omg.sysml.owl.owl.AnnotationValue;
import org.omg.sysml.owl.owl.AnonymousIndividual;
import org.omg.sysml.owl.owl.AnonymousIndividualReference;
import org.omg.sysml.owl.owl.AsymmetricObjectProperty;
import org.omg.sysml.owl.owl.ClassAssertion;
import org.omg.sysml.owl.owl.ClassReference;
import org.omg.sysml.owl.owl.DataAllValuesFrom;
import org.omg.sysml.owl.owl.DataComplementOf;
import org.omg.sysml.owl.owl.DataExactCardinality;
import org.omg.sysml.owl.owl.DataHasValue;
import org.omg.sysml.owl.owl.DataIntersectionOf;
import org.omg.sysml.owl.owl.DataMaxCardinality;
import org.omg.sysml.owl.owl.DataMinCardinality;
import org.omg.sysml.owl.owl.DataOneOf;
import org.omg.sysml.owl.owl.DataProperty;
import org.omg.sysml.owl.owl.DataPropertyAssertion;
import org.omg.sysml.owl.owl.DataPropertyDomain;
import org.omg.sysml.owl.owl.DataPropertyRange;
import org.omg.sysml.owl.owl.DataPropertyReference;
import org.omg.sysml.owl.owl.DataSomeValuesFrom;
import org.omg.sysml.owl.owl.DataUnionOf;
import org.omg.sysml.owl.owl.Datatype;
import org.omg.sysml.owl.owl.DatatypeDefinition;
import org.omg.sysml.owl.owl.DatatypeReference;
import org.omg.sysml.owl.owl.DatatypeRestriction;
import org.omg.sysml.owl.owl.Declaration;
import org.omg.sysml.owl.owl.DifferentIndividuals;
import org.omg.sysml.owl.owl.DisjointClasses;
import org.omg.sysml.owl.owl.DisjointDataProperties;
import org.omg.sysml.owl.owl.DisjointObjectProperties;
import org.omg.sysml.owl.owl.DisjointUnion;
import org.omg.sysml.owl.owl.EquivalentClasses;
import org.omg.sysml.owl.owl.EquivalentDataProperties;
import org.omg.sysml.owl.owl.EquivalentObjectProperties;
import org.omg.sysml.owl.owl.FacetRestriction;
import org.omg.sysml.owl.owl.FunctionalDataProperty;
import org.omg.sysml.owl.owl.FunctionalObjectProperty;
import org.omg.sysml.owl.owl.HasKey;
import org.omg.sysml.owl.owl.InverseFunctionalObjectProperty;
import org.omg.sysml.owl.owl.InverseObjectProperties;
import org.omg.sysml.owl.owl.InverseObjectProperty;
import org.omg.sysml.owl.owl.IrreflexiveObjectProperty;
import org.omg.sysml.owl.owl.NamedIndividual;
import org.omg.sysml.owl.owl.NamedIndividualReference;
import org.omg.sysml.owl.owl.NegativeDataPropertyAssertion;
import org.omg.sysml.owl.owl.NegativeObjectPropertyAssertion;
import org.omg.sysml.owl.owl.ObjectAllValuesFrom;
import org.omg.sysml.owl.owl.ObjectComplementOf;
import org.omg.sysml.owl.owl.ObjectExactCardinality;
import org.omg.sysml.owl.owl.ObjectHasSelf;
import org.omg.sysml.owl.owl.ObjectHasValue;
import org.omg.sysml.owl.owl.ObjectIntersectionOf;
import org.omg.sysml.owl.owl.ObjectMaxCardinality;
import org.omg.sysml.owl.owl.ObjectMinCardinality;
import org.omg.sysml.owl.owl.ObjectOneOf;
import org.omg.sysml.owl.owl.ObjectProperty;
import org.omg.sysml.owl.owl.ObjectPropertyAssertion;
import org.omg.sysml.owl.owl.ObjectPropertyDomain;
import org.omg.sysml.owl.owl.ObjectPropertyRange;
import org.omg.sysml.owl.owl.ObjectPropertyReference;
import org.omg.sysml.owl.owl.ObjectSomeValuesFrom;
import org.omg.sysml.owl.owl.ObjectUnionOf;
import org.omg.sysml.owl.owl.Ontology;
import org.omg.sysml.owl.owl.OntologyDocument;
import org.omg.sysml.owl.owl.OwlPackage;
import org.omg.sysml.owl.owl.PrefixDeclaration;
import org.omg.sysml.owl.owl.ReflexiveObjectProperty;
import org.omg.sysml.owl.owl.SameIndividual;
import org.omg.sysml.owl.owl.StringLiteral;
import org.omg.sysml.owl.owl.SubAnnotationPropertyOf;
import org.omg.sysml.owl.owl.SubClassOf;
import org.omg.sysml.owl.owl.SubDataPropertyOf;
import org.omg.sysml.owl.owl.SubObjectPropertyOf;
import org.omg.sysml.owl.owl.SymmetricObjectProperty;
import org.omg.sysml.owl.owl.TransitiveObjectProperty;
import org.omg.sysml.owl.owl.TypedLiteral;
import org.omg.sysml.owl.services.OwlGrammarAccess;

@SuppressWarnings("all")
public class OwlSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private OwlGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == OwlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case OwlPackage.ANNOTATION:
				sequence_Annotation(context, (Annotation) semanticObject); 
				return; 
			case OwlPackage.ANNOTATION_ASSERTION:
				sequence_AnnotationAssertion(context, (AnnotationAssertion) semanticObject); 
				return; 
			case OwlPackage.ANNOTATION_PROPERTY:
				sequence_AnnotationProperty(context, (AnnotationProperty) semanticObject); 
				return; 
			case OwlPackage.ANNOTATION_PROPERTY_DOMAIN:
				sequence_AnnotationPropertyDomain(context, (AnnotationPropertyDomain) semanticObject); 
				return; 
			case OwlPackage.ANNOTATION_PROPERTY_RANGE:
				sequence_AnnotationPropertyRange(context, (AnnotationPropertyRange) semanticObject); 
				return; 
			case OwlPackage.ANNOTATION_SUBJECT:
				sequence_AnnotationSubject(context, (AnnotationSubject) semanticObject); 
				return; 
			case OwlPackage.ANNOTATION_VALUE:
				sequence_AnnotationValue(context, (AnnotationValue) semanticObject); 
				return; 
			case OwlPackage.ANONYMOUS_INDIVIDUAL:
				sequence_AnonymousIndividual(context, (AnonymousIndividual) semanticObject); 
				return; 
			case OwlPackage.ANONYMOUS_INDIVIDUAL_REFERENCE:
				sequence_AnonymousIndividualReference(context, (AnonymousIndividualReference) semanticObject); 
				return; 
			case OwlPackage.ASYMMETRIC_OBJECT_PROPERTY:
				sequence_AsymmetricObjectProperty(context, (AsymmetricObjectProperty) semanticObject); 
				return; 
			case OwlPackage.CLASS:
				sequence_Class(context, (org.omg.sysml.owl.owl.Class) semanticObject); 
				return; 
			case OwlPackage.CLASS_ASSERTION:
				sequence_ClassAssertion(context, (ClassAssertion) semanticObject); 
				return; 
			case OwlPackage.CLASS_REFERENCE:
				sequence_ClassReference(context, (ClassReference) semanticObject); 
				return; 
			case OwlPackage.DATA_ALL_VALUES_FROM:
				sequence_DataAllValuesFrom(context, (DataAllValuesFrom) semanticObject); 
				return; 
			case OwlPackage.DATA_COMPLEMENT_OF:
				sequence_DataComplementOf(context, (DataComplementOf) semanticObject); 
				return; 
			case OwlPackage.DATA_EXACT_CARDINALITY:
				sequence_DataExactCardinality(context, (DataExactCardinality) semanticObject); 
				return; 
			case OwlPackage.DATA_HAS_VALUE:
				sequence_DataHasValue(context, (DataHasValue) semanticObject); 
				return; 
			case OwlPackage.DATA_INTERSECTION_OF:
				sequence_DataIntersectionOf(context, (DataIntersectionOf) semanticObject); 
				return; 
			case OwlPackage.DATA_MAX_CARDINALITY:
				sequence_DataMaxCardinality(context, (DataMaxCardinality) semanticObject); 
				return; 
			case OwlPackage.DATA_MIN_CARDINALITY:
				sequence_DataMinCardinality(context, (DataMinCardinality) semanticObject); 
				return; 
			case OwlPackage.DATA_ONE_OF:
				sequence_DataOneOf(context, (DataOneOf) semanticObject); 
				return; 
			case OwlPackage.DATA_PROPERTY:
				sequence_DataProperty(context, (DataProperty) semanticObject); 
				return; 
			case OwlPackage.DATA_PROPERTY_ASSERTION:
				sequence_DataPropertyAssertion(context, (DataPropertyAssertion) semanticObject); 
				return; 
			case OwlPackage.DATA_PROPERTY_DOMAIN:
				sequence_DataPropertyDomain(context, (DataPropertyDomain) semanticObject); 
				return; 
			case OwlPackage.DATA_PROPERTY_RANGE:
				sequence_DataPropertyRange(context, (DataPropertyRange) semanticObject); 
				return; 
			case OwlPackage.DATA_PROPERTY_REFERENCE:
				sequence_DataPropertyReference(context, (DataPropertyReference) semanticObject); 
				return; 
			case OwlPackage.DATA_SOME_VALUES_FROM:
				sequence_DataSomeValuesFrom(context, (DataSomeValuesFrom) semanticObject); 
				return; 
			case OwlPackage.DATA_UNION_OF:
				sequence_DataUnionOf(context, (DataUnionOf) semanticObject); 
				return; 
			case OwlPackage.DATATYPE:
				sequence_Datatype(context, (Datatype) semanticObject); 
				return; 
			case OwlPackage.DATATYPE_DEFINITION:
				sequence_DatatypeDefinition(context, (DatatypeDefinition) semanticObject); 
				return; 
			case OwlPackage.DATATYPE_REFERENCE:
				sequence_DatatypeReference(context, (DatatypeReference) semanticObject); 
				return; 
			case OwlPackage.DATATYPE_RESTRICTION:
				sequence_DatatypeRestriction(context, (DatatypeRestriction) semanticObject); 
				return; 
			case OwlPackage.DECLARATION:
				sequence_Declaration(context, (Declaration) semanticObject); 
				return; 
			case OwlPackage.DIFFERENT_INDIVIDUALS:
				sequence_DifferentIndividuals(context, (DifferentIndividuals) semanticObject); 
				return; 
			case OwlPackage.DISJOINT_CLASSES:
				sequence_DisjointClasses(context, (DisjointClasses) semanticObject); 
				return; 
			case OwlPackage.DISJOINT_DATA_PROPERTIES:
				sequence_DisjointDataProperties(context, (DisjointDataProperties) semanticObject); 
				return; 
			case OwlPackage.DISJOINT_OBJECT_PROPERTIES:
				sequence_DisjointObjectProperties(context, (DisjointObjectProperties) semanticObject); 
				return; 
			case OwlPackage.DISJOINT_UNION:
				sequence_DisjointUnion(context, (DisjointUnion) semanticObject); 
				return; 
			case OwlPackage.EQUIVALENT_CLASSES:
				sequence_EquivalentClasses(context, (EquivalentClasses) semanticObject); 
				return; 
			case OwlPackage.EQUIVALENT_DATA_PROPERTIES:
				sequence_EquivalentDataProperties(context, (EquivalentDataProperties) semanticObject); 
				return; 
			case OwlPackage.EQUIVALENT_OBJECT_PROPERTIES:
				sequence_EquivalentObjectProperties(context, (EquivalentObjectProperties) semanticObject); 
				return; 
			case OwlPackage.FACET_RESTRICTION:
				sequence_FacetRestriction(context, (FacetRestriction) semanticObject); 
				return; 
			case OwlPackage.FUNCTIONAL_DATA_PROPERTY:
				sequence_FunctionalDataProperty(context, (FunctionalDataProperty) semanticObject); 
				return; 
			case OwlPackage.FUNCTIONAL_OBJECT_PROPERTY:
				sequence_FunctionalObjectProperty(context, (FunctionalObjectProperty) semanticObject); 
				return; 
			case OwlPackage.HAS_KEY:
				sequence_HasKey(context, (HasKey) semanticObject); 
				return; 
			case OwlPackage.INVERSE_FUNCTIONAL_OBJECT_PROPERTY:
				sequence_InverseFunctionalObjectProperty(context, (InverseFunctionalObjectProperty) semanticObject); 
				return; 
			case OwlPackage.INVERSE_OBJECT_PROPERTIES:
				sequence_InverseObjectProperties(context, (InverseObjectProperties) semanticObject); 
				return; 
			case OwlPackage.INVERSE_OBJECT_PROPERTY:
				sequence_InverseObjectProperty(context, (InverseObjectProperty) semanticObject); 
				return; 
			case OwlPackage.IRREFLEXIVE_OBJECT_PROPERTY:
				sequence_IrreflexiveObjectProperty(context, (IrreflexiveObjectProperty) semanticObject); 
				return; 
			case OwlPackage.NAMED_INDIVIDUAL:
				sequence_NamedIndividual(context, (NamedIndividual) semanticObject); 
				return; 
			case OwlPackage.NAMED_INDIVIDUAL_REFERENCE:
				sequence_NamedIndividualReference(context, (NamedIndividualReference) semanticObject); 
				return; 
			case OwlPackage.NEGATIVE_DATA_PROPERTY_ASSERTION:
				sequence_NegativeDataPropertyAssertion(context, (NegativeDataPropertyAssertion) semanticObject); 
				return; 
			case OwlPackage.NEGATIVE_OBJECT_PROPERTY_ASSERTION:
				sequence_NegativeObjectPropertyAssertion(context, (NegativeObjectPropertyAssertion) semanticObject); 
				return; 
			case OwlPackage.OBJECT_ALL_VALUES_FROM:
				sequence_ObjectAllValuesFrom(context, (ObjectAllValuesFrom) semanticObject); 
				return; 
			case OwlPackage.OBJECT_COMPLEMENT_OF:
				sequence_ObjectComplementOf(context, (ObjectComplementOf) semanticObject); 
				return; 
			case OwlPackage.OBJECT_EXACT_CARDINALITY:
				sequence_ObjectExactCardinality(context, (ObjectExactCardinality) semanticObject); 
				return; 
			case OwlPackage.OBJECT_HAS_SELF:
				sequence_ObjectHasSelf(context, (ObjectHasSelf) semanticObject); 
				return; 
			case OwlPackage.OBJECT_HAS_VALUE:
				sequence_ObjectHasValue(context, (ObjectHasValue) semanticObject); 
				return; 
			case OwlPackage.OBJECT_INTERSECTION_OF:
				sequence_ObjectIntersectionOf(context, (ObjectIntersectionOf) semanticObject); 
				return; 
			case OwlPackage.OBJECT_MAX_CARDINALITY:
				sequence_ObjectMaxCardinality(context, (ObjectMaxCardinality) semanticObject); 
				return; 
			case OwlPackage.OBJECT_MIN_CARDINALITY:
				sequence_ObjectMinCardinality(context, (ObjectMinCardinality) semanticObject); 
				return; 
			case OwlPackage.OBJECT_ONE_OF:
				sequence_ObjectOneOf(context, (ObjectOneOf) semanticObject); 
				return; 
			case OwlPackage.OBJECT_PROPERTY:
				sequence_ObjectProperty(context, (ObjectProperty) semanticObject); 
				return; 
			case OwlPackage.OBJECT_PROPERTY_ASSERTION:
				sequence_ObjectPropertyAssertion(context, (ObjectPropertyAssertion) semanticObject); 
				return; 
			case OwlPackage.OBJECT_PROPERTY_DOMAIN:
				sequence_ObjectPropertyDomain(context, (ObjectPropertyDomain) semanticObject); 
				return; 
			case OwlPackage.OBJECT_PROPERTY_RANGE:
				sequence_ObjectPropertyRange(context, (ObjectPropertyRange) semanticObject); 
				return; 
			case OwlPackage.OBJECT_PROPERTY_REFERENCE:
				sequence_ObjectPropertyReference(context, (ObjectPropertyReference) semanticObject); 
				return; 
			case OwlPackage.OBJECT_SOME_VALUES_FROM:
				sequence_ObjectSomeValuesFrom(context, (ObjectSomeValuesFrom) semanticObject); 
				return; 
			case OwlPackage.OBJECT_UNION_OF:
				sequence_ObjectUnionOf(context, (ObjectUnionOf) semanticObject); 
				return; 
			case OwlPackage.ONTOLOGY:
				sequence_Ontology(context, (Ontology) semanticObject); 
				return; 
			case OwlPackage.ONTOLOGY_DOCUMENT:
				sequence_OntologyDocument(context, (OntologyDocument) semanticObject); 
				return; 
			case OwlPackage.PREFIX_DECLARATION:
				sequence_PrefixDeclaration(context, (PrefixDeclaration) semanticObject); 
				return; 
			case OwlPackage.REFLEXIVE_OBJECT_PROPERTY:
				sequence_ReflexiveObjectProperty(context, (ReflexiveObjectProperty) semanticObject); 
				return; 
			case OwlPackage.SAME_INDIVIDUAL:
				sequence_SameIndividual(context, (SameIndividual) semanticObject); 
				return; 
			case OwlPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case OwlPackage.SUB_ANNOTATION_PROPERTY_OF:
				sequence_SubAnnotationPropertyOf(context, (SubAnnotationPropertyOf) semanticObject); 
				return; 
			case OwlPackage.SUB_CLASS_OF:
				sequence_SubClassOf(context, (SubClassOf) semanticObject); 
				return; 
			case OwlPackage.SUB_DATA_PROPERTY_OF:
				sequence_SubDataPropertyOf(context, (SubDataPropertyOf) semanticObject); 
				return; 
			case OwlPackage.SUB_OBJECT_PROPERTY_OF:
				sequence_SubObjectPropertyOf(context, (SubObjectPropertyOf) semanticObject); 
				return; 
			case OwlPackage.SYMMETRIC_OBJECT_PROPERTY:
				sequence_SymmetricObjectProperty(context, (SymmetricObjectProperty) semanticObject); 
				return; 
			case OwlPackage.TRANSITIVE_OBJECT_PROPERTY:
				sequence_TransitiveObjectProperty(context, (TransitiveObjectProperty) semanticObject); 
				return; 
			case OwlPackage.TYPED_LITERAL:
				sequence_TypedLiteral(context, (TypedLiteral) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Axiom returns AnnotationAssertion
	 *     AnnotationAxiom returns AnnotationAssertion
	 *     AnnotationAssertion returns AnnotationAssertion
	 *
	 * Constraint:
	 *     (annotationAnnotations+=Annotation* annotationProperty=AnnotationProperty annotationSubject=AnnotationSubject annotationValue=AnnotationValue)
	 */
	protected void sequence_AnnotationAssertion(ISerializationContext context, AnnotationAssertion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns AnnotationPropertyDomain
	 *     AnnotationAxiom returns AnnotationPropertyDomain
	 *     AnnotationPropertyDomain returns AnnotationPropertyDomain
	 *
	 * Constraint:
	 *     (annotationAnnotations+=Annotation* annotationProperty=AnnotationProperty domain=IRI)
	 */
	protected void sequence_AnnotationPropertyDomain(ISerializationContext context, AnnotationPropertyDomain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns AnnotationPropertyRange
	 *     AnnotationAxiom returns AnnotationPropertyRange
	 *     AnnotationPropertyRange returns AnnotationPropertyRange
	 *
	 * Constraint:
	 *     (annotationAnnotations+=Annotation* annotationProperty=AnnotationProperty range=IRI)
	 */
	protected void sequence_AnnotationPropertyRange(ISerializationContext context, AnnotationPropertyRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns AnnotationProperty
	 *     AnnotationProperty returns AnnotationProperty
	 *     EntityDeclaration returns AnnotationProperty
	 *
	 * Constraint:
	 *     entityIRI=IRI
	 */
	protected void sequence_AnnotationProperty(ISerializationContext context, AnnotationProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.ENTITY__ENTITY_IRI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.ENTITY__ENTITY_IRI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnnotationPropertyAccess().getEntityIRIIRIParserRuleCall_0(), semanticObject.getEntityIRI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AnnotationSubject returns AnnotationSubject
	 *
	 * Constraint:
	 *     {AnnotationSubject}
	 */
	protected void sequence_AnnotationSubject(ISerializationContext context, AnnotationSubject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnnotationValue returns AnnotationValue
	 *
	 * Constraint:
	 *     {AnnotationValue}
	 */
	protected void sequence_AnnotationValue(ISerializationContext context, AnnotationValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Annotation returns Annotation
	 *
	 * Constraint:
	 *     (annotationAnnotations+=Annotation* annotationProperty=AnnotationProperty annotationvalue=AnnotationValue)
	 */
	protected void sequence_Annotation(ISerializationContext context, Annotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IndividualReference returns AnonymousIndividualReference
	 *     AnonymousIndividualReference returns AnonymousIndividualReference
	 *     AnnotationValue returns AnonymousIndividualReference
	 *     AnnotationSubject returns AnonymousIndividualReference
	 *
	 * Constraint:
	 *     individual=NodeID
	 */
	protected void sequence_AnonymousIndividualReference(ISerializationContext context, AnonymousIndividualReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.INDIVIDUAL_REFERENCE__INDIVIDUAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.INDIVIDUAL_REFERENCE__INDIVIDUAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnonymousIndividualReferenceAccess().getIndividualNodeIDParserRuleCall_0(), semanticObject.getIndividual());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Individual returns AnonymousIndividual
	 *     AnonymousIndividual returns AnonymousIndividual
	 *
	 * Constraint:
	 *     nodeId=NodeID
	 */
	protected void sequence_AnonymousIndividual(ISerializationContext context, AnonymousIndividual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.ANONYMOUS_INDIVIDUAL__NODE_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.ANONYMOUS_INDIVIDUAL__NODE_ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnonymousIndividualAccess().getNodeIdNodeIDParserRuleCall_0(), semanticObject.getNodeId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns AsymmetricObjectProperty
	 *     ObjectPropertyAxiom returns AsymmetricObjectProperty
	 *     AsymmetricObjectProperty returns AsymmetricObjectProperty
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* objectPropertyExpression=ObjectPropertyExpression)
	 */
	protected void sequence_AsymmetricObjectProperty(ISerializationContext context, AsymmetricObjectProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns ClassAssertion
	 *     Assertion returns ClassAssertion
	 *     ClassAssertion returns ClassAssertion
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* classExpression=ClassExpression individual=IndividualReference)
	 */
	protected void sequence_ClassAssertion(ISerializationContext context, ClassAssertion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassExpression returns ClassReference
	 *     ClassReference returns ClassReference
	 *
	 * Constraint:
	 *     class=IRI
	 */
	protected void sequence_ClassReference(ISerializationContext context, ClassReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.CLASS_REFERENCE__CLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.CLASS_REFERENCE__CLASS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClassReferenceAccess().getClassIRIParserRuleCall_0(), semanticObject.getClass_());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Class
	 *     Class returns Class
	 *     EntityDeclaration returns Class
	 *
	 * Constraint:
	 *     entityIRI=IRI
	 */
	protected void sequence_Class(ISerializationContext context, org.omg.sysml.owl.owl.Class semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.ENTITY__ENTITY_IRI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.ENTITY__ENTITY_IRI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClassAccess().getEntityIRIIRIParserRuleCall_0(), semanticObject.getEntityIRI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassExpression returns DataAllValuesFrom
	 *     DataAllValuesFrom returns DataAllValuesFrom
	 *
	 * Constraint:
	 *     (dataPropertyExpressions+=DataPropertyExpression+ dataRange+=DataRange)
	 */
	protected void sequence_DataAllValuesFrom(ISerializationContext context, DataAllValuesFrom semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataRange returns DataComplementOf
	 *     DataComplementOf returns DataComplementOf
	 *
	 * Constraint:
	 *     dataRange=DataRange
	 */
	protected void sequence_DataComplementOf(ISerializationContext context, DataComplementOf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.DATA_COMPLEMENT_OF__DATA_RANGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.DATA_COMPLEMENT_OF__DATA_RANGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataComplementOfAccess().getDataRangeDataRangeParserRuleCall_2_0(), semanticObject.getDataRange());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassExpression returns DataExactCardinality
	 *     DataExactCardinality returns DataExactCardinality
	 *
	 * Constraint:
	 *     (cardinality=INT dataPropertyExpression=DataPropertyExpression dataRange=DataRange?)
	 */
	protected void sequence_DataExactCardinality(ISerializationContext context, DataExactCardinality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassExpression returns DataHasValue
	 *     DataHasValue returns DataHasValue
	 *
	 * Constraint:
	 *     (dataPropertyExpression=DataPropertyExpression literal=Literal)
	 */
	protected void sequence_DataHasValue(ISerializationContext context, DataHasValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.DATA_HAS_VALUE__DATA_PROPERTY_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.DATA_HAS_VALUE__DATA_PROPERTY_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.DATA_HAS_VALUE__LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.DATA_HAS_VALUE__LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataHasValueAccess().getDataPropertyExpressionDataPropertyExpressionParserRuleCall_2_0(), semanticObject.getDataPropertyExpression());
		feeder.accept(grammarAccess.getDataHasValueAccess().getLiteralLiteralParserRuleCall_3_0(), semanticObject.getLiteral());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataRange returns DataIntersectionOf
	 *     DataIntersectionOf returns DataIntersectionOf
	 *
	 * Constraint:
	 *     (dataRanges+=DataRange dataRanges+=DataRange+)
	 */
	protected void sequence_DataIntersectionOf(ISerializationContext context, DataIntersectionOf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassExpression returns DataMaxCardinality
	 *     DataMaxCardinality returns DataMaxCardinality
	 *
	 * Constraint:
	 *     (cardinality=INT dataPropertyExpression=DataPropertyExpression dataRange=DataRange?)
	 */
	protected void sequence_DataMaxCardinality(ISerializationContext context, DataMaxCardinality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassExpression returns DataMinCardinality
	 *     DataMinCardinality returns DataMinCardinality
	 *
	 * Constraint:
	 *     (cardinality=INT dataPropertyExpression=DataPropertyExpression dataRange=DataRange?)
	 */
	protected void sequence_DataMinCardinality(ISerializationContext context, DataMinCardinality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataRange returns DataOneOf
	 *     DataOneOf returns DataOneOf
	 *
	 * Constraint:
	 *     literals+=Literal+
	 */
	protected void sequence_DataOneOf(ISerializationContext context, DataOneOf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns DataPropertyAssertion
	 *     Assertion returns DataPropertyAssertion
	 *     DataPropertyAssertion returns DataPropertyAssertion
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* objectPropertyExpression=ObjectPropertyExpression sourceIndividual=IndividualReference targetValue=Literal)
	 */
	protected void sequence_DataPropertyAssertion(ISerializationContext context, DataPropertyAssertion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns DataPropertyDomain
	 *     DataPropertyAxiom returns DataPropertyDomain
	 *     DataPropertyDomain returns DataPropertyDomain
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* dataPropertyExpressions+=DataPropertyExpression classExpression=ClassExpression)
	 */
	protected void sequence_DataPropertyDomain(ISerializationContext context, DataPropertyDomain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns DataPropertyRange
	 *     DataPropertyAxiom returns DataPropertyRange
	 *     DataPropertyRange returns DataPropertyRange
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* dataPropertyExpressions+=DataPropertyExpression classExpression=ClassExpression)
	 */
	protected void sequence_DataPropertyRange(ISerializationContext context, DataPropertyRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataPropertyExpression returns DataPropertyReference
	 *     DataPropertyReference returns DataPropertyReference
	 *
	 * Constraint:
	 *     dataProperty=IRI
	 */
	protected void sequence_DataPropertyReference(ISerializationContext context, DataPropertyReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.DATA_PROPERTY_REFERENCE__DATA_PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.DATA_PROPERTY_REFERENCE__DATA_PROPERTY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataPropertyReferenceAccess().getDataPropertyIRIParserRuleCall_0(), semanticObject.getDataProperty());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns DataProperty
	 *     DataProperty returns DataProperty
	 *     EntityDeclaration returns DataProperty
	 *
	 * Constraint:
	 *     entityIRI=IRI
	 */
	protected void sequence_DataProperty(ISerializationContext context, DataProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.ENTITY__ENTITY_IRI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.ENTITY__ENTITY_IRI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataPropertyAccess().getEntityIRIIRIParserRuleCall_0(), semanticObject.getEntityIRI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassExpression returns DataSomeValuesFrom
	 *     DataSomeValuesFrom returns DataSomeValuesFrom
	 *
	 * Constraint:
	 *     (dataPropertyExpressions+=DataPropertyExpression+ dataRange+=DataRange)
	 */
	protected void sequence_DataSomeValuesFrom(ISerializationContext context, DataSomeValuesFrom semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataRange returns DataUnionOf
	 *     DataUnionOf returns DataUnionOf
	 *
	 * Constraint:
	 *     (dataRanges+=DataRange dataRanges+=DataRange+)
	 */
	protected void sequence_DataUnionOf(ISerializationContext context, DataUnionOf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns DatatypeDefinition
	 *     DatatypeDefinition returns DatatypeDefinition
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* datatype=DatatypeReference dataRange=DataRange)
	 */
	protected void sequence_DatatypeDefinition(ISerializationContext context, DatatypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataRange returns DatatypeReference
	 *     DatatypeReference returns DatatypeReference
	 *
	 * Constraint:
	 *     datatype=IRI
	 */
	protected void sequence_DatatypeReference(ISerializationContext context, DatatypeReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.DATATYPE_REFERENCE__DATATYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.DATATYPE_REFERENCE__DATATYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDatatypeReferenceAccess().getDatatypeIRIParserRuleCall_0(), semanticObject.getDatatype());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataRange returns DatatypeRestriction
	 *     DatatypeRestriction returns DatatypeRestriction
	 *
	 * Constraint:
	 *     (dataType=DatatypeReference restrictions+=FacetRestriction+)
	 */
	protected void sequence_DatatypeRestriction(ISerializationContext context, DatatypeRestriction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Datatype
	 *     Datatype returns Datatype
	 *     EntityDeclaration returns Datatype
	 *
	 * Constraint:
	 *     entityIRI=IRI
	 */
	protected void sequence_Datatype(ISerializationContext context, Datatype semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.ENTITY__ENTITY_IRI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.ENTITY__ENTITY_IRI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDatatypeAccess().getEntityIRIIRIParserRuleCall_0(), semanticObject.getEntityIRI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Declaration
	 *     Axiom returns Declaration
	 *
	 * Constraint:
	 *     (axiomAnnotation+=Annotation* entity=EntityDeclaration)
	 */
	protected void sequence_Declaration(ISerializationContext context, Declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns DifferentIndividuals
	 *     Assertion returns DifferentIndividuals
	 *     DifferentIndividuals returns DifferentIndividuals
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* individuals+=IndividualReference individuals+=IndividualReference+)
	 */
	protected void sequence_DifferentIndividuals(ISerializationContext context, DifferentIndividuals semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns DisjointClasses
	 *     ClassAxiom returns DisjointClasses
	 *     DisjointClasses returns DisjointClasses
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* classExpressions+=ClassExpression classExpressions+=ClassExpression+)
	 */
	protected void sequence_DisjointClasses(ISerializationContext context, DisjointClasses semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns DisjointDataProperties
	 *     DataPropertyAxiom returns DisjointDataProperties
	 *     DisjointDataProperties returns DisjointDataProperties
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* dataPropertyExpressions+=DataPropertyExpression dataPropertyExpressions+=DataPropertyExpression+)
	 */
	protected void sequence_DisjointDataProperties(ISerializationContext context, DisjointDataProperties semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns DisjointObjectProperties
	 *     ObjectPropertyAxiom returns DisjointObjectProperties
	 *     DisjointObjectProperties returns DisjointObjectProperties
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* objectPropertyExpressions+=ObjectPropertyExpression objectPropertyExpressions+=ObjectPropertyExpression+)
	 */
	protected void sequence_DisjointObjectProperties(ISerializationContext context, DisjointObjectProperties semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns DisjointUnion
	 *     ClassAxiom returns DisjointUnion
	 *     DisjointUnion returns DisjointUnion
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* class=ClassReference disjointClassExpressions+=ClassExpression disjointClassExpressions+=ClassExpression+)
	 */
	protected void sequence_DisjointUnion(ISerializationContext context, DisjointUnion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns EquivalentClasses
	 *     ClassAxiom returns EquivalentClasses
	 *     EquivalentClasses returns EquivalentClasses
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* classExpressions+=ClassExpression classExpressions+=ClassExpression+)
	 */
	protected void sequence_EquivalentClasses(ISerializationContext context, EquivalentClasses semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns EquivalentDataProperties
	 *     DataPropertyAxiom returns EquivalentDataProperties
	 *     EquivalentDataProperties returns EquivalentDataProperties
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* dataPropertyExpressions+=DataPropertyExpression dataPropertyExpressions+=DataPropertyExpression+)
	 */
	protected void sequence_EquivalentDataProperties(ISerializationContext context, EquivalentDataProperties semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns EquivalentObjectProperties
	 *     ObjectPropertyAxiom returns EquivalentObjectProperties
	 *     EquivalentObjectProperties returns EquivalentObjectProperties
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* objectPropertyExpressions+=ObjectPropertyExpression objectPropertyExpressions+=ObjectPropertyExpression+)
	 */
	protected void sequence_EquivalentObjectProperties(ISerializationContext context, EquivalentObjectProperties semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FacetRestriction returns FacetRestriction
	 *
	 * Constraint:
	 *     (constrainingFacet=IRI restrictionValue=Literal)
	 */
	protected void sequence_FacetRestriction(ISerializationContext context, FacetRestriction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.FACET_RESTRICTION__CONSTRAINING_FACET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.FACET_RESTRICTION__CONSTRAINING_FACET));
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.FACET_RESTRICTION__RESTRICTION_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.FACET_RESTRICTION__RESTRICTION_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFacetRestrictionAccess().getConstrainingFacetIRIParserRuleCall_0_0(), semanticObject.getConstrainingFacet());
		feeder.accept(grammarAccess.getFacetRestrictionAccess().getRestrictionValueLiteralParserRuleCall_1_0(), semanticObject.getRestrictionValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns FunctionalDataProperty
	 *     DataPropertyAxiom returns FunctionalDataProperty
	 *     FunctionalDataProperty returns FunctionalDataProperty
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* dataPropertyExpressions+=DataPropertyExpression)
	 */
	protected void sequence_FunctionalDataProperty(ISerializationContext context, FunctionalDataProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns FunctionalObjectProperty
	 *     ObjectPropertyAxiom returns FunctionalObjectProperty
	 *     FunctionalObjectProperty returns FunctionalObjectProperty
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* objectPropertyExpression=ObjectPropertyExpression)
	 */
	protected void sequence_FunctionalObjectProperty(ISerializationContext context, FunctionalObjectProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns HasKey
	 *     HasKey returns HasKey
	 *
	 * Constraint:
	 *     (
	 *         axiomAnnotations+=Annotation* 
	 *         classExpression=ClassExpression 
	 *         objectPropertyExpressions+=ObjectPropertyExpression* 
	 *         dataPropertyExpressions+=DataPropertyExpression*
	 *     )
	 */
	protected void sequence_HasKey(ISerializationContext context, HasKey semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns InverseFunctionalObjectProperty
	 *     ObjectPropertyAxiom returns InverseFunctionalObjectProperty
	 *     InverseFunctionalObjectProperty returns InverseFunctionalObjectProperty
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* objectPropertyExpression=ObjectPropertyExpression)
	 */
	protected void sequence_InverseFunctionalObjectProperty(ISerializationContext context, InverseFunctionalObjectProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns InverseObjectProperties
	 *     ObjectPropertyAxiom returns InverseObjectProperties
	 *     InverseObjectProperties returns InverseObjectProperties
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* objectPropertyExpression1=ObjectPropertyExpression objectPropertyExpression2=ObjectPropertyExpression)
	 */
	protected void sequence_InverseObjectProperties(ISerializationContext context, InverseObjectProperties semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObjectPropertyExpression returns InverseObjectProperty
	 *     InverseObjectProperty returns InverseObjectProperty
	 *
	 * Constraint:
	 *     objectProperty=IRI
	 */
	protected void sequence_InverseObjectProperty(ISerializationContext context, InverseObjectProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.OBJECT_PROPERTY_EXPRESSION__OBJECT_PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.OBJECT_PROPERTY_EXPRESSION__OBJECT_PROPERTY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInverseObjectPropertyAccess().getObjectPropertyIRIParserRuleCall_2_0(), semanticObject.getObjectProperty());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns IrreflexiveObjectProperty
	 *     ObjectPropertyAxiom returns IrreflexiveObjectProperty
	 *     IrreflexiveObjectProperty returns IrreflexiveObjectProperty
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* objectPropertyExpression=ObjectPropertyExpression)
	 */
	protected void sequence_IrreflexiveObjectProperty(ISerializationContext context, IrreflexiveObjectProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IndividualReference returns NamedIndividualReference
	 *     NamedIndividualReference returns NamedIndividualReference
	 *
	 * Constraint:
	 *     individual=IRI
	 */
	protected void sequence_NamedIndividualReference(ISerializationContext context, NamedIndividualReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.INDIVIDUAL_REFERENCE__INDIVIDUAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.INDIVIDUAL_REFERENCE__INDIVIDUAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNamedIndividualReferenceAccess().getIndividualIRIParserRuleCall_0(), semanticObject.getIndividual());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns NamedIndividual
	 *     Individual returns NamedIndividual
	 *     NamedIndividual returns NamedIndividual
	 *     EntityDeclaration returns NamedIndividual
	 *
	 * Constraint:
	 *     entityIRI=IRI
	 */
	protected void sequence_NamedIndividual(ISerializationContext context, NamedIndividual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.ENTITY__ENTITY_IRI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.ENTITY__ENTITY_IRI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNamedIndividualAccess().getEntityIRIIRIParserRuleCall_0(), semanticObject.getEntityIRI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns NegativeDataPropertyAssertion
	 *     Assertion returns NegativeDataPropertyAssertion
	 *     NegativeDataPropertyAssertion returns NegativeDataPropertyAssertion
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* objectPropertyExpression=ObjectPropertyExpression sourceIndividual=IndividualReference targetValue=Literal)
	 */
	protected void sequence_NegativeDataPropertyAssertion(ISerializationContext context, NegativeDataPropertyAssertion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns NegativeObjectPropertyAssertion
	 *     Assertion returns NegativeObjectPropertyAssertion
	 *     NegativeObjectPropertyAssertion returns NegativeObjectPropertyAssertion
	 *
	 * Constraint:
	 *     (
	 *         axiomAnnotations+=Annotation* 
	 *         objectPropertyExpression=ObjectPropertyExpression 
	 *         sourceIndividual=IndividualReference 
	 *         targetIndividual=IndividualReference
	 *     )
	 */
	protected void sequence_NegativeObjectPropertyAssertion(ISerializationContext context, NegativeObjectPropertyAssertion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassExpression returns ObjectAllValuesFrom
	 *     ObjectAllValuesFrom returns ObjectAllValuesFrom
	 *
	 * Constraint:
	 *     (objectPropertyExpression=ObjectPropertyExpression classExpression=ClassExpression)
	 */
	protected void sequence_ObjectAllValuesFrom(ISerializationContext context, ObjectAllValuesFrom semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.OBJECT_ALL_VALUES_FROM__OBJECT_PROPERTY_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.OBJECT_ALL_VALUES_FROM__OBJECT_PROPERTY_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.OBJECT_ALL_VALUES_FROM__CLASS_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.OBJECT_ALL_VALUES_FROM__CLASS_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectAllValuesFromAccess().getObjectPropertyExpressionObjectPropertyExpressionParserRuleCall_2_0(), semanticObject.getObjectPropertyExpression());
		feeder.accept(grammarAccess.getObjectAllValuesFromAccess().getClassExpressionClassExpressionParserRuleCall_3_0(), semanticObject.getClassExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassExpression returns ObjectComplementOf
	 *     ObjectComplementOf returns ObjectComplementOf
	 *
	 * Constraint:
	 *     classExpression=ClassExpression
	 */
	protected void sequence_ObjectComplementOf(ISerializationContext context, ObjectComplementOf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.OBJECT_COMPLEMENT_OF__CLASS_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.OBJECT_COMPLEMENT_OF__CLASS_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectComplementOfAccess().getClassExpressionClassExpressionParserRuleCall_2_0(), semanticObject.getClassExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassExpression returns ObjectExactCardinality
	 *     ObjectExactCardinality returns ObjectExactCardinality
	 *
	 * Constraint:
	 *     (cardinality=INT objectPropertyExpression=ObjectPropertyExpression classExpression=ClassExpression?)
	 */
	protected void sequence_ObjectExactCardinality(ISerializationContext context, ObjectExactCardinality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassExpression returns ObjectHasSelf
	 *     ObjectHasSelf returns ObjectHasSelf
	 *
	 * Constraint:
	 *     objectPropertyExpression=ObjectPropertyExpression
	 */
	protected void sequence_ObjectHasSelf(ISerializationContext context, ObjectHasSelf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.OBJECT_HAS_SELF__OBJECT_PROPERTY_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.OBJECT_HAS_SELF__OBJECT_PROPERTY_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectHasSelfAccess().getObjectPropertyExpressionObjectPropertyExpressionParserRuleCall_2_0(), semanticObject.getObjectPropertyExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassExpression returns ObjectHasValue
	 *     ObjectHasValue returns ObjectHasValue
	 *
	 * Constraint:
	 *     (objectPropertyExpression=ObjectPropertyExpression individual=IndividualReference)
	 */
	protected void sequence_ObjectHasValue(ISerializationContext context, ObjectHasValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.OBJECT_HAS_VALUE__OBJECT_PROPERTY_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.OBJECT_HAS_VALUE__OBJECT_PROPERTY_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.OBJECT_HAS_VALUE__INDIVIDUAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.OBJECT_HAS_VALUE__INDIVIDUAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectHasValueAccess().getObjectPropertyExpressionObjectPropertyExpressionParserRuleCall_2_0(), semanticObject.getObjectPropertyExpression());
		feeder.accept(grammarAccess.getObjectHasValueAccess().getIndividualIndividualReferenceParserRuleCall_3_0(), semanticObject.getIndividual());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassExpression returns ObjectIntersectionOf
	 *     ObjectIntersectionOf returns ObjectIntersectionOf
	 *
	 * Constraint:
	 *     classExpressions+=ClassExpression+
	 */
	protected void sequence_ObjectIntersectionOf(ISerializationContext context, ObjectIntersectionOf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassExpression returns ObjectMaxCardinality
	 *     ObjectMaxCardinality returns ObjectMaxCardinality
	 *
	 * Constraint:
	 *     (cardinality=INT objectPropertyExpression=ObjectPropertyExpression classExpression=ClassExpression?)
	 */
	protected void sequence_ObjectMaxCardinality(ISerializationContext context, ObjectMaxCardinality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassExpression returns ObjectMinCardinality
	 *     ObjectMinCardinality returns ObjectMinCardinality
	 *
	 * Constraint:
	 *     (cardinality=INT objectPropertyExpression=ObjectPropertyExpression classExpression=ClassExpression?)
	 */
	protected void sequence_ObjectMinCardinality(ISerializationContext context, ObjectMinCardinality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassExpression returns ObjectOneOf
	 *     ObjectOneOf returns ObjectOneOf
	 *
	 * Constraint:
	 *     individuals+=IndividualReference+
	 */
	protected void sequence_ObjectOneOf(ISerializationContext context, ObjectOneOf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns ObjectPropertyAssertion
	 *     Assertion returns ObjectPropertyAssertion
	 *     ObjectPropertyAssertion returns ObjectPropertyAssertion
	 *
	 * Constraint:
	 *     (
	 *         axiomAnnotations+=Annotation* 
	 *         objectPropertyExpression=ObjectPropertyExpression 
	 *         sourceIndividual=IndividualReference 
	 *         targetIndividual=IndividualReference
	 *     )
	 */
	protected void sequence_ObjectPropertyAssertion(ISerializationContext context, ObjectPropertyAssertion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns ObjectPropertyDomain
	 *     ObjectPropertyAxiom returns ObjectPropertyDomain
	 *     ObjectPropertyDomain returns ObjectPropertyDomain
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* objectPropertyExpression=ObjectPropertyExpression classExpression=ClassExpression)
	 */
	protected void sequence_ObjectPropertyDomain(ISerializationContext context, ObjectPropertyDomain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns ObjectPropertyRange
	 *     ObjectPropertyAxiom returns ObjectPropertyRange
	 *     ObjectPropertyRange returns ObjectPropertyRange
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* objectPropertyExpression=ObjectPropertyExpression classExpression=ClassExpression)
	 */
	protected void sequence_ObjectPropertyRange(ISerializationContext context, ObjectPropertyRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObjectPropertyExpression returns ObjectPropertyReference
	 *     ObjectPropertyReference returns ObjectPropertyReference
	 *
	 * Constraint:
	 *     objectProperty=IRI
	 */
	protected void sequence_ObjectPropertyReference(ISerializationContext context, ObjectPropertyReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.OBJECT_PROPERTY_EXPRESSION__OBJECT_PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.OBJECT_PROPERTY_EXPRESSION__OBJECT_PROPERTY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectPropertyReferenceAccess().getObjectPropertyIRIParserRuleCall_0(), semanticObject.getObjectProperty());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns ObjectProperty
	 *     ObjectProperty returns ObjectProperty
	 *     EntityDeclaration returns ObjectProperty
	 *
	 * Constraint:
	 *     entityIRI=IRI
	 */
	protected void sequence_ObjectProperty(ISerializationContext context, ObjectProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.ENTITY__ENTITY_IRI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.ENTITY__ENTITY_IRI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectPropertyAccess().getEntityIRIIRIParserRuleCall_0(), semanticObject.getEntityIRI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassExpression returns ObjectSomeValuesFrom
	 *     ObjectSomeValuesFrom returns ObjectSomeValuesFrom
	 *
	 * Constraint:
	 *     (objectPropertyExpression=ObjectPropertyExpression classExpression=ClassExpression)
	 */
	protected void sequence_ObjectSomeValuesFrom(ISerializationContext context, ObjectSomeValuesFrom semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.OBJECT_SOME_VALUES_FROM__OBJECT_PROPERTY_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.OBJECT_SOME_VALUES_FROM__OBJECT_PROPERTY_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.OBJECT_SOME_VALUES_FROM__CLASS_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.OBJECT_SOME_VALUES_FROM__CLASS_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectSomeValuesFromAccess().getObjectPropertyExpressionObjectPropertyExpressionParserRuleCall_2_0(), semanticObject.getObjectPropertyExpression());
		feeder.accept(grammarAccess.getObjectSomeValuesFromAccess().getClassExpressionClassExpressionParserRuleCall_3_0(), semanticObject.getClassExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassExpression returns ObjectUnionOf
	 *     ObjectUnionOf returns ObjectUnionOf
	 *
	 * Constraint:
	 *     classExpressions+=ClassExpression+
	 */
	protected void sequence_ObjectUnionOf(ISerializationContext context, ObjectUnionOf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OntologyDocument returns OntologyDocument
	 *
	 * Constraint:
	 *     (prefixDeclarations+=PrefixDeclaration* ontology=Ontology)
	 */
	protected void sequence_OntologyDocument(ISerializationContext context, OntologyDocument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Ontology returns Ontology
	 *
	 * Constraint:
	 *     ((ontologyIRI=IRI versionIRI=IRI?)? directlyImportsDocuments+=DirectlyImportsDocument* ontologyAnnotations+=Annotation* axioms+=Axiom*)
	 */
	protected void sequence_Ontology(ISerializationContext context, Ontology semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrefixDeclaration returns PrefixDeclaration
	 *
	 * Constraint:
	 *     (prefixName=PrefixName fullIRI=FullIRI)
	 */
	protected void sequence_PrefixDeclaration(ISerializationContext context, PrefixDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.PREFIX_DECLARATION__PREFIX_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.PREFIX_DECLARATION__PREFIX_NAME));
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.PREFIX_DECLARATION__FULL_IRI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.PREFIX_DECLARATION__FULL_IRI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrefixDeclarationAccess().getPrefixNamePrefixNameParserRuleCall_2_0(), semanticObject.getPrefixName());
		feeder.accept(grammarAccess.getPrefixDeclarationAccess().getFullIRIFullIRIParserRuleCall_4_0(), semanticObject.getFullIRI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns ReflexiveObjectProperty
	 *     ObjectPropertyAxiom returns ReflexiveObjectProperty
	 *     ReflexiveObjectProperty returns ReflexiveObjectProperty
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* objectPropertyExpression=ObjectPropertyExpression)
	 */
	protected void sequence_ReflexiveObjectProperty(ISerializationContext context, ReflexiveObjectProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns SameIndividual
	 *     Assertion returns SameIndividual
	 *     SameIndividual returns SameIndividual
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* individuals+=IndividualReference individuals+=IndividualReference+)
	 */
	protected void sequence_SameIndividual(ISerializationContext context, SameIndividual semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *     AnnotationValue returns StringLiteral
	 *
	 * Constraint:
	 *     lexicalForm=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.LITERAL__LEXICAL_FORM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.LITERAL__LEXICAL_FORM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getLexicalFormSTRINGTerminalRuleCall_0(), semanticObject.getLexicalForm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns SubAnnotationPropertyOf
	 *     AnnotationAxiom returns SubAnnotationPropertyOf
	 *     SubAnnotationPropertyOf returns SubAnnotationPropertyOf
	 *
	 * Constraint:
	 *     (annotationAnnotations+=Annotation* subAnnotationProperty=AnnotationProperty superAnnotationProperty=AnnotationProperty)
	 */
	protected void sequence_SubAnnotationPropertyOf(ISerializationContext context, SubAnnotationPropertyOf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns SubClassOf
	 *     ClassAxiom returns SubClassOf
	 *     SubClassOf returns SubClassOf
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* subClassExpression=ClassExpression superClassExpression=ClassExpression)
	 */
	protected void sequence_SubClassOf(ISerializationContext context, SubClassOf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns SubDataPropertyOf
	 *     DataPropertyAxiom returns SubDataPropertyOf
	 *     SubDataPropertyOf returns SubDataPropertyOf
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* subDataPropertyExpression=DataPropertyExpression superDataPropertyExpression=DataPropertyExpression)
	 */
	protected void sequence_SubDataPropertyOf(ISerializationContext context, SubDataPropertyOf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns SubObjectPropertyOf
	 *     ObjectPropertyAxiom returns SubObjectPropertyOf
	 *     SubObjectPropertyOf returns SubObjectPropertyOf
	 *
	 * Constraint:
	 *     (
	 *         axiomAnnotations+=Annotation* 
	 *         (subObjectPropertyExpression+=ObjectPropertyExpression | subObjectPropertyExpression+=ObjectPropertyExpression+)
	 *     )
	 */
	protected void sequence_SubObjectPropertyOf(ISerializationContext context, SubObjectPropertyOf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns SymmetricObjectProperty
	 *     ObjectPropertyAxiom returns SymmetricObjectProperty
	 *     SymmetricObjectProperty returns SymmetricObjectProperty
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* objectPropertyExpression=ObjectPropertyExpression)
	 */
	protected void sequence_SymmetricObjectProperty(ISerializationContext context, SymmetricObjectProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Axiom returns TransitiveObjectProperty
	 *     ObjectPropertyAxiom returns TransitiveObjectProperty
	 *     TransitiveObjectProperty returns TransitiveObjectProperty
	 *
	 * Constraint:
	 *     (axiomAnnotations+=Annotation* objectPropertyExpression=ObjectPropertyExpression)
	 */
	protected void sequence_TransitiveObjectProperty(ISerializationContext context, TransitiveObjectProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns TypedLiteral
	 *     TypedLiteral returns TypedLiteral
	 *     AnnotationValue returns TypedLiteral
	 *
	 * Constraint:
	 *     (lexicalForm=STRING datatype=IRI)
	 */
	protected void sequence_TypedLiteral(ISerializationContext context, TypedLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.LITERAL__LEXICAL_FORM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.LITERAL__LEXICAL_FORM));
			if (transientValues.isValueTransient(semanticObject, OwlPackage.Literals.TYPED_LITERAL__DATATYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OwlPackage.Literals.TYPED_LITERAL__DATATYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypedLiteralAccess().getLexicalFormSTRINGTerminalRuleCall_0_0(), semanticObject.getLexicalForm());
		feeder.accept(grammarAccess.getTypedLiteralAccess().getDatatypeIRIParserRuleCall_2_0(), semanticObject.getDatatype());
		feeder.finish();
	}
	
	
}
