/*****************************************************************************
 * Copyright (c) 2018 Model Driven Solutions, Inc.
 *    
 * Contributors:
 *  Ed Seidewitz
 * 
 *****************************************************************************/

grammar org.omg.sysml.Alf hidden (WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.openmbee.org/kerml/core" as core
import "http://www.openmbee.org/kerml/str" as str

/* PACKAGES */
PackageDefinition returns core::Container: 
	'package' name = Name '{' ( ownedMember += PackagedElement )* '}' 
;

PackageDefinitionOrStub returns core::Container :
//	'package' name = Name ( isStub ?= ';' | '{' ( ownedMember += PackagedElement )* '}' )
	( packageVisibility = VisibilityKind ) 'package' name = Name 
		'{' ( ownedMember += PackagedElement )* '}'
;

PackagedElement returns core::ElementRecord : 
//  ( documentation += DOCUMENTATION_COMMENT )?
//  ( annotation += StereotypeAnnotation )*
//  visibility = ImportVisibilityIndicator 
//	definition = PackagedElementDefinition
	PackagedElementDefinition
;

PackagedElementDefinition returns core::ElementRecord:
  PackageDefinitionOrStub | ClassifierDefinitionOrStub
;

ClassifierDefinitionOrStub returns str::Class:
	ClassDefinitionOrStub
;

/* CLASSES */
ClassDeclaration returns str::Class : 
//	( 'namespace' namespace += [core::Container | QualifiedName] )?
//	( ^import += ImportDeclaration )*
	( isAbstract ?= 'abstract' )? 'class' name = Name 
//  ( '<' ownedMember += ClassifierTemplateParameter ( ',' ownedMember += ClassifierTemplateParameter )* '>' )? 
//  ( specialization = SpecializationClause )?
	// NOTE: Made generalization a containment reference.
	( 'specializes' ( generalization += Generalization )+ )?
;

//SpecializationClause returns QualifiedNameList : 
//	'specializes' QualifiedNameList
//;

Generalization returns str::Generalization :
	// NOTE: Made Relationship::related optional.
	general = [str::Class | QualifiedName]
;

ClassDefinition returns str::Class : 
  ClassDeclaration
	'{' ( ownedFeature += ClassMember )* '}'
;

ClassDefinitionOrStub returns str::Class : 
	( packageVisibility = VisibilityKind ) ( isAbstract ?= 'abstract' )? 'class' name = Name 
		( 'specializes' ( generalization += Generalization )+ )?
		'{' ( ownedFeature += ClassMember )* '}'
//	ClassDeclaration
//	( isStub ?= ';' | '{' ( ownedMember += ClassMember )* '}' )
;

ClassMember returns str::Feature : 
	FeatureDefinition
//	( documentation += DOCUMENTATION_COMMENT )?
//	( annotation += StereotypeAnnotation )*
//	( methodVisibility = VisibilityKind )?
//	definition = ClassMemberDefinition
;

enum VisibilityKind returns core::visibilityKind :
	public = 'public' | private = 'private' | protected = 'protected'
;

/* FEATURES */
FeatureDefinition returns str::Feature :
	( methodVisibility = VisibilityKind )? name = Name ':' 
	// NOTE: Made type unidirectional; made definingType and refiningType optional.
	type += [str::Class | QualifiedName]
//	( '[' lower = NATURAL_VALUE '..' upper = NATURAL_VALUE ']' )?
	';'
;

//FeatureDefinitionOrStub returns str::Feature : 
//  AttributeDefinition /*| OperationDefinitionOrStub*/
//;
//
///* PROPERTIES */
//PropertyDefinition returns str::Feature : 
//	PropertyDeclaration ';'
//;
//
//AttributeDefinition returns str::Feature : 
//	PropertyDeclaration ( initializer = AttributeInitializer )? ';'
//;
//
//AttributeInitializer returns Expression : 
//	'=' InitializationExpression
//;
//
//PropertyDeclaration returns PropertyDefinition : 
//	name = Name ':' ( isComposite?='compose' )? 
//	// CHANGE: Made TypedElementDefinition a composite part of PropertyDefinition instead of the supertype
//	typePart = TypePart
//;
//
//TypePart returns TypedElementDefinition :
//  // CHANGE: Added isAny attribute to TypedElementDefinition to allow Xtext serialization.
//  // CHANGE: Added isMultiplicity attribute to TypedElementDefinition.
//  // CHANGE: Added isSequence attribute to TypedElementDefinition.
//  ( isAny ?= 'any' | typeName = QualifiedName )
//  ( ( '[' 
//      ( isMultiplicity ?= ']' | 
//        ( lowerBound = NATURAL_VALUE '..' )? upperBound = UnlimitedNaturalLiteral ']' 
//      )
//    )?
//    ( isOrdered ?= 'ordered' ( isNonunique ?= 'nonunique' )? | 
//      isNonunique ?='nonunique' ( isOrdered ?= 'ordered' )? | 
//      isSequence ?= 'sequence'
//    )?
//  )?
//;


/***************
* NAMES        *
***************/
Name :
	ID | UNRESTRICTED_NAME
;

QualifiedName :
	Name ( '::' Name)*
;

/****************
* Terminals
*****************/
terminal BOOLEAN_VALUE : 'true' | 'false' ;

terminal NATURAL_VALUE :
	('0' | '1'..'9' (('_')? '0'..'9')*) | //DECIMAL 
	(('0b' | '0B') '0'..'1' (('_')? '0'..'1')*) | // BINARY
	(('0x'|'0X') ('0'..'9'|'a'..'f'|'A'..'F')  (('_')? ('0'..'9'|'a'..'f'|'A'..'F'))*) | // HEX
	('0' ('_')? '0'..'7' (('_')? '0'..'7')*) // OCT
;

terminal ID : ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')* ;
terminal UNRESTRICTED_NAME : '\'' ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|'\'') )* '\'' ;

terminal STRING	: '"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|'"') )* '"' ;

terminal DOCUMENTATION_COMMENT : '/**' -> '*/' ;
terminal STATEMENT_ANNOTATION : '//@' -> '\n'
//  '//@' WS? ID (WS? '(' WS? (ID | UNRESTRICTED_NAME) (WS? ',' WS? (ID | UNRESTRICTED_NAME))* WS? ')')? 
//  (WS? '@' WS? ID (WS? '(' WS? (ID | UNRESTRICTED_NAME) (WS? ',' WS? (ID | UNRESTRICTED_NAME))* WS? ')')?)* (' '|'\t')* ('\r'? '\n')
;
terminal INLINE_STATEMENT : '/*@inline(' (ID | UNRESTRICTED_NAME) ')' -> '*/';

terminal ML_COMMENT	: '/*' !('*' | '@') -> '*/';
terminal SL_COMMENT : '//' (!('@'|'\n'|'\r') !('\n'|'\r')*)? ('\r'? '\n')?;

terminal WS : (' '|'\t'|'\r'|'\n')+;
