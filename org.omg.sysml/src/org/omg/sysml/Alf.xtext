/*****************************************************************************
 * SysML 2 Pilot Implementation
 * Copyright (c) 2018 Model Driven Solutions, Inc.
 * Copyright (c) 2018 IncQuery Labs Ltd.
 *    
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 * @license LGPL-3.0-or-later <http://spdx.org/licenses/LGPL-3.0-or-later>
 * 
 * Contributors:
 *  Ed Seidewitz
 *  Zoltan Kiss
 *  Balazs Grill
 * 
 *****************************************************************************/

grammar org.omg.sysml.Alf hidden (WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as Ecore
import "http://www.omg.org/spec/SysML/2.0" as SysML

/* UNITS */

UnitDefinition returns SysML::Package :
	  PackageUnitDefinition 
	| ClassUnitDefinition 
	| AssociationUnitDefinition 
	| FeatureUnitDefinition
;

PackageUnitDefinition returns SysML::Package: 
    UnitPrefix PackageDefinition 
;

ClassUnitDefinition returns SysML::Class : 
	UnitPrefix ClassDefinition
;

AssociationUnitDefinition returns SysML::Association :
	UnitPrefix AssociationDefinition
;

FeatureUnitDefinition returns SysML::Feature :
	UnitPrefix FeatureBodyDefinition
;

fragment UnitPrefix returns SysML::Package :
	//	( 'namespace' namespace += [SysML::Package | QualifiedName] )?
	( ownedImport += PackageImport 
	| ownedMembership += ElementImport
	)*
	( ownedElement += Comment )*
;

/* VISIBILITY */

enum PackageElementVisibilityIndicator returns SysML::VisibilityKind:
	public = 'public' | private = 'private'
;

enum VisibilityIndicator returns SysML::VisibilityKind :
	public = 'public' | private = 'private' | protected = 'protected' | package = 'packaged'
;

/* COMMENTS */

Comment returns SysML::Comment :
	body = DOCUMENTATION_COMMENT
;

/* IMPORTS */

PackageImport returns SysML::Import :
	( visibility = PackageElementVisibilityIndicator )?  
	'import' (
	  importedPackage = [SysML::Package|Name] ( '::' | '.' ) '*' 
	| importedPackage = [SysML::Package|ColonQualifiedName] '::' '*' 
	| importedPackage = [SysML::Package|DotQualifiedName] '.' '*'
	) ';'
;

ElementImport returns SysML::Membership :
	( visibility = PackageElementVisibilityIndicator )? 
	'import' memberElement = [SysML::Element|QualifiedName] ( 'as' memberName = Name )? ';'
;

/* PACKAGES */

NonFeatureDefinition returns SysML::Package:
	PackageDefinitionOrStub | ClassDefinitionOrStub | AssociationDefinitionOrStub
;

PackageDefinitionOrStub returns SysML::Package :
	PackageDefinition
//	'package' name = Name ( isStub ?= ';' | '{' ( ownedMembership += PackageMember )* '}' )
;

fragment PackageDefinition returns SysML::Package: 
	'package' name = Name '{' ( ownedMembership += PackageMember | ownedImport += PackageImport )* '}' 
;

/* PACKAGE MEMBERSHIPS */

PackageMember returns SysML::Membership : 
	( ownedElement += Comment )*
//  ( annotation += StereotypeAnnotation )*
    ( visibility = PackageElementVisibilityIndicator )?	
	( NonFeatureMemberElement 
	| FeaturePackageMemberElement
	)
;

fragment NonFeatureMemberElement returns SysML::Membership :
	( ownedMemberElement = NonFeatureDefinition
	| 'package' ( memberName = Name )? 'is' memberElement = [SysML::Package|QualifiedName] ';'
    | 'class' ( memberName = Name )? 'is' memberElement = [SysML::Class|QualifiedName] ';'
    | 'assoc' ( memberName = Name )? 'is' memberElement = [SysML::Association|QualifiedName] ';'
	| 'import' memberElement = [SysML::Element|QualifiedName] ( 'as' memberName = Name )? ';'
	)
;

//NonFeatureMemberKind :
//	'package' | 'class' | 'assoc'
//;

fragment FeaturePackageMemberElement returns SysML::Membership :
	( 
	  'feature'? ownedMemberElement = NamedFeatureDefinition
	| 'feature' ownedMemberElement = UnnamedFeatureDefinition
	| ( 'feature' ( memberName = Name )? | memberName = Name ) 'is' memberElement = [SysML::Feature|QualifiedName] ';'
	)
;

/* CLASSES */

ClassDefinitionOrStub returns SysML::Class :
	ClassDefinition 
//	ClassDeclaration ( isStub ?= ';' | ClassBody '}' )
;

fragment ClassDefinition returns SysML::Class : 
	ClassDeclaration ClassBody
;

fragment ClassDeclaration returns SysML::Class :
	( isAbstract ?= 'abstract' )? 'class' name = Name 
//  ( '<' ownedMember += ClassifierTemplateParameter ( ',' ownedMember += ClassifierTemplateParameter )* '>' )? 
	( 'specializes' ownedElement += Generalization ( ',' ownedElement += Generalization )* )?
;

fragment ClassBody returns SysML::Class :
	'{' ( ownedMembership += ClassMember | ownedImport += PackageImport )* '}'
;

Generalization returns SysML::Generalization:
	general = [SysML::Class | QualifiedName]
;

/* CLASS MEMBERSHIPS */

ClassMember returns SysML::Membership : 
	NonFeatureClassMember | FeatureClassMember
;

NonFeatureClassMember returns SysML::Membership : 
	( ownedElement += Comment )*
//  ( annotation += StereotypeAnnotation )*
    ( visibility = VisibilityIndicator )?
	NonFeatureMemberElement
;

FeatureClassMember returns SysML::FeatureMembership : 
	( ownedElement += Comment )*
//  ( annotation += StereotypeAnnotation )*
    ( visibility = VisibilityIndicator )?
    ( FeatureMemberElement
      
    // These alternatives are provided for legacy Alf backwards compatibility.	
    | ( direction = FeatureDirection )? ownedMemberElement = NamedFeatureDefinition
	| memberName = Name 'is' memberElement = [SysML::Feature|QualifiedName] ';'	
	)
;

fragment FeatureMemberElement returns SysML::FeatureMembership :
      ( 'feature' | isComposite ?= 'part' | isPort ?= 'port' ) ( direction = FeatureDirection )? ownedMemberElement = FeatureDefinition
	| ( 'feature' | isComposite ?= 'part' ) ( memberName = Name )? 'is' memberElement = [SysML::Feature|QualifiedName] ';'
	| 'connector' ownedMemberElement = ConnectorDefinition
	| 'connector' ( memberName = Name )? 'is' memberElement = [SysML::Connector|QualifiedName] ';' 
;

enum FeatureDirection returns SysML::FeatureDirectionKind:
	in = 'in' | out = 'out' | inout = 'inout'
;

/* ASSOCIATIONS */

AssociationDefinitionOrStub returns SysML::Association :
	AssociationDefinition
	// AssociationDeclaration { isStub = ';' | AssociationBody }
;

fragment AssociationDefinition returns SysML::Association :
	AssociationDeclaration AssociationBody
;

fragment AssociationDeclaration returns SysML::Association :
	( isAbstract ?= 'abstract' )? 'assoc' name = Name
	( 'specializes' ownedElement += Generalization ( ',' ownedElement += Generalization )* )?
;

fragment AssociationBody returns SysML::Association :
	'{' ( ownedMembership += AssociationMember | ownedImport += PackageImport )* '}'
;

/* ASSOCIATION MEMBERSHIPS */

AssociationMember returns SysML::Membership :
	NonFeatureClassMember | AssociationFeatureMember | AssociationEndFeatureMember
;

AssociationFeatureMember returns SysML::FeatureMembership :
	( ownedElement += Comment )*
//  ( annotation += StereotypeAnnotation )*
    ( visibility = VisibilityIndicator )?
    FeatureMemberElement
;

AssociationEndFeatureMember returns SysML::EndFeatureMembership :
	( ownedElement += Comment )*
//  ( annotation += StereotypeAnnotation )*
    ( visibility = VisibilityIndicator )?
    (
      'end' ( direction = FeatureDirection )? ownedMemberElement = FeatureDefinition
	| 'end' ( memberName = Name )? 'is' memberElement = [SysML::Feature|QualifiedName] ';'

	// These alternatives are provided for legacy Alf backwards compatibilty;
    | ( direction = FeatureDirection )? ownedMemberElement = NamedFeatureDefinition
	| memberName = Name 'is' memberElement = [SysML::Feature|QualifiedName] ';'
	)
;

/* FEATURES */

FeatureDefinition returns SysML::Feature :
	NamedFeatureDefinition | UnnamedFeatureDefinition
;

NamedFeatureDefinition returns SysML::Feature :
	FeatureDeclaration FeatureCompletion
;

UnnamedFeatureDefinition returns SysML::Feature :
	ownedElement += SubsetOrRedefinition TypePart? Multiplicity?
	FeatureCompletion
;

fragment FeatureBodyDefinition returns SysML::Feature :
	'feature' FeatureDeclaration ClassBody
;

fragment FeatureDeclaration returns SysML::Feature :
	name = Name TypePart? Multiplicity? 
	( ownedElement += SubsetOrRedefinition )? 
;

fragment FeatureCompletion returns SysML::Feature :
	( '=' value = Expression )? ( ';' | ClassBody )
;

fragment TypePart returns SysML::Feature :
	':' ( isComposite ?= 'compose' )? ( referencedType += [SysML::Class | QualifiedName] | 'any' )
;

fragment Multiplicity returns SysML::Feature :
	'[' ( lower = NaturalLiteralExpression '..' )? upper = UnlimitedNaturalLiteralExpression ']'
	( isOrdered ?= 'ordered'? & isNonunique ?= 'nonunique'? )
;

SubsetOrRedefinition returns SysML::Subset :
	( 'subsets' Subset
	| 'redefines' Redefinition
	)
;

Redefinition returns SysML::Redefinition:
	redefinedFeature = [SysML::Feature|QualifiedName] 
;

Subset returns SysML::Subset:
	subsettedFeature = [SysML::Feature|QualifiedName]
;

/* CONNECTORS */

ConnectorDefinition returns SysML::Connector:	 
	( ( ( name = Name )? ( ':' association = [SysML::Association | QualifiedName] )? 'is')?
		  connectorEnd += ConnectorEnd 'to' connectorEnd += ConnectorEnd ';'
	| ( name = Name )? ( ':' association = [SysML::Association | QualifiedName] )?
	  '(' connectorEnd += ConnectorEnd ',' connectorEnd += ConnectorEnd
	      ( ',' connectorEnd += ConnectorEnd )*
	  ')' ';'
	)	  
;

ConnectorEnd returns SysML::ConnectorEnd :
	  ( end = [SysML::Feature | QualifiedName] ':' )? 
	  feature = [SysML::Feature | QualifiedName] ConnectorEndMultiplicity?
	| ( end = [SysML::Feature | QualifiedName] ConnectorEndMultiplicity? '=>' ) 
	  feature = [SysML::Feature | QualifiedName] 
      
;

fragment ConnectorEndMultiplicity returns SysML::ConnectorEnd :
	'[' ( lower = NaturalLiteralExpression '..' )? upper = UnlimitedNaturalLiteralExpression ']'
;

/* EXPRESSIONS */

Expression returns SysML::Expression:
	BinaryExpression
;

BinaryExpression returns SysML::Expression:
	UnaryExpression ( {SysML::OperatorExpression.operand += current}  
		( operator = BinaryOperator operand += Expression | operator = '@' '[' operand += Expression ']' ) )?
;

BinaryOperator:
	'+' | '-' | '*' | '/' | '^'
;

UnaryExpression returns SysML::Expression:
	SequenceAccessExpression | {SysML::OperatorExpression} operator = UnaryOperator operand += SequenceAccessExpression
;

UnaryOperator:
	'+' | '-'
;

SequenceAccessExpression returns SysML::Expression:
	 PrimaryExpression 
	 ( {SysML::SequenceAccessExpression.primary = current} '[' index = Expression ']' )*
;

PrimaryExpression returns SysML::Expression:
	  LiteralExpression 
	| ElementReferenceExpression 
	| InstanceCreationExpression 
	| SequenceConstructionExpression 
	| '(' Expression ')'
;

ElementReferenceExpression returns SysML::ElementReferenceExpression :
	referent = [SysML::Element | QualifiedName]
;

InstanceCreationExpression returns SysML::InstanceCreationExpression :
	class = [SysML::Class  | QualifiedName] '(' Tuple? ')'
;

fragment Tuple returns SysML::InstanceCreationExpression :
	PositionalTuple | NamedTuple
;

fragment PositionalTuple returns SysML::InstanceCreationExpression :
	argument += Expression ( ',' argument += Expression )*
;

fragment NamedTuple returns SysML::InstanceCreationExpression :
	Name '=>' argument += Expression ( ',' Name '=>' argument += Expression )*
;

SequenceConstructionExpression returns SysML::SequenceConstructionExpression:
	{SysML::SequenceConstructionExpression} '{' ( element += Expression ( ',' element += Expression )* )? '}'
;

LiteralExpression returns SysML::Expression :
	NullLiteralExpression | BooleanLiteralExpression | StringLiteralExpression | RealLiteralExpression | UnlimitedNaturalLiteralExpression
;

NullLiteralExpression returns SysML::LiteralNull :
	{SysML::LiteralNull} 'null'
;

BooleanLiteralExpression returns SysML::LiteralBoolean :
	value = BOOLEAN_VALUE
;

StringLiteralExpression returns SysML::LiteralString :
	value = STRING_VALUE
;

RealLiteralExpression returns SysML::LiteralReal:
	value = RealValue
;

RealValue returns Ecore::EDouble:
	(NATURAL_VALUE '.' ( NATURAL_VALUE )? | '.' NATURAL_VALUE) (('e' | 'E') ('+' | '-')? NATURAL_VALUE)?
;

NaturalLiteralExpression returns SysML::LiteralInteger:
	value = NATURAL_VALUE
;

UnlimitedNaturalLiteralExpression returns SysML::Expression:
	NaturalLiteralExpression | {SysML::LiteralUnbounded} '*'
;

/* NAMES */

Name :
	ID | UNRESTRICTED_NAME
;

QualifiedName :
	Name | ColonQualifiedName | DotQualifiedName
;

ColonQualifiedName :
	Name ('::' Name)+
;

DotQualifiedName :
	Name ('.' Name)+
;

/* TERMINALS */

terminal BOOLEAN_VALUE returns Ecore::EBoolean : 
	'true' | 'false' ;

terminal NATURAL_VALUE returns Ecore::EInt :
	('0' | '1'..'9' (('_')? '0'..'9')*) | //DECIMAL 
	(('0b' | '0B') '0'..'1' (('_')? '0'..'1')*) | // BINARY
	(('0x'|'0X') ('0'..'9'|'a'..'f'|'A'..'F')  (('_')? ('0'..'9'|'a'..'f'|'A'..'F'))*) | // HEX
	('0' ('_')? '0'..'7' (('_')? '0'..'7')*) // OCT
;

terminal ID : ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')* ;
terminal UNRESTRICTED_NAME returns Ecore::EString : 
	'\'' ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|'\'') )* '\'' ;

terminal STRING_VALUE returns Ecore::EString : 
	'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|'"') )* '"' ;

terminal DOCUMENTATION_COMMENT : '/**' -> '*/' ;
terminal STATEMENT_ANNOTATION : '//@' -> '\n'
//  '//@' WS? ID (WS? '(' WS? (ID | UNRESTRICTED_NAME) (WS? ',' WS? (ID | UNRESTRICTED_NAME))* WS? ')')? 
//  (WS? '@' WS? ID (WS? '(' WS? (ID | UNRESTRICTED_NAME) (WS? ',' WS? (ID | UNRESTRICTED_NAME))* WS? ')')?)* (' '|'\t')* ('\r'? '\n')
;
terminal INLINE_STATEMENT : '/*@inline(' (ID | UNRESTRICTED_NAME) ')' -> '*/';

terminal ML_COMMENT	: '/*' !('*' | '@') -> '*/';
terminal SL_COMMENT : '//' (!('@'|'\n'|'\r') !('\n'|'\r')*)? ('\r'? '\n')?;

terminal WS : (' '|'\t'|'\r'|'\n')+;
