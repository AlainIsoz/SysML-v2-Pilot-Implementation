/*****************************************************************************
 * SysML 2 Pilot Implementation
 * Copyright (c) 2018 Model Driven Solutions, Inc.
 *    
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 * @license LGPL-3.0-or-later <http://spdx.org/licenses/LGPL-3.0-or-later>
 * 
 * Contributors:
 *  Ed Seidewitz
 * 
 *****************************************************************************/

modeltype SysML uses "http://www.omg.org/spec/SysML/2.0";
modeltype UML uses "http://www.eclipse.org/uml2/5.0.0/UML";
modeltype Ecore uses "http://www.eclipse.org/emf/2002/Ecore";

transformation SysML2UML(in sysml: SysML, out uml: UML);

main() {
	object Model {
		name := "Model";
		packagedElement := sysml.rootObjects()[SysML::Package]->
			map toNamespace()[UML::PackageableElement];
	};
}

// CORE

// Element

abstract mapping SysML::Element::toNamedElement() : UML::NamedElement {
	name := self.name;
//	var package = self.owningPackage;
//	if package <> null then {
//		var naming = package.namingOf(self);
//		name := naming.name;
//		visibility := toVisibilityKind(naming.visibility);
//	} endif;
}

mapping SysML::Element::toPackageableElement() : UML::PackageableElement
	disjuncts 
		SysML::Feature::toInstanceSpecification,
		SysML::Class::toClass,
		SysML::Package::toPackage;

// GROUPS

// Namespace

mapping SysML::Package::toNamespace() : UML::Namespace
	disjuncts 
		SysML::Class::toClass,
		SysML::Package::toPackage;

mapping SysML::Package::toPackage() : UML::Package
	inherits SysML::Element::toNamedElement {
	packagedElement += self.membership->map toPackageableElement();
	packagedElement += self.membership.ownedMemberElement[SysML::Feature]->map toClass();
}

//query SysML::Package::namingOf(e: Element): Membership {
//	return self.membership![memberElement = e];
//}

// NamespaceMembership

mapping SysML::Membership::toPackageableElement() : UML::PackageableElement {
init {
	result := self.ownedMemberElement.map toPackageableElement();
}
	visibility := toVisibilityKind(self.visibility);
}

mapping SysML::Membership::toProperty() : UML::Property {
init {
	result := self.ownedMemberElement.oclAsType(SysML::Feature).map toProperty();
}
	visibility := toVisibilityKind(self.visibility);
}

query toVisibilityKind(visibility : SysML::VisibilityKind) : UML::VisibilityKind {
	return 
		if visibility = null then null
		else if visibility = SysML::VisibilityKind::private then UML::VisibilityKind::private
		else if visibility = SysML::VisibilityKind::public then UML::VisibilityKind::public
		else if visibility = SysML::VisibilityKind::protected then UML::VisibilityKind::protected
		else if visibility = SysML::VisibilityKind::package then UML::VisibilityKind::package
		endif endif endif endif endif;
}

// CLASSIFICATION

// Class

mapping SysML::Class::toClass() : UML::Class
	inherits SysML::Element::toNamedElement {
	ownedAttribute := self.membership[ownedMemberElement.oclIsTypeOf(SysML::Feature)].oclAsType(Membership)->map toProperty();
	generalization := self.ownedGeneralization->map toGeneralization();
}

// Generalization

mapping SysML::Generalization::toGeneralization() : UML::Generalization {
	general := self.general.late resolveone(UML::Class);
}

// Feature

helper SysML::Feature::mapType(): UML::Classifier {
	return if self.referencedType->notEmpty() then self.referencedType![true].map toClass() 
		   else if self.ownedRedefinition.redefinedFeature->notEmpty() then self.ownedRedefinition.redefinedFeature![true].map toClass()
		   else null 
		   endif endif;
}

abstract mapping SysML::Feature::toNamedElement(): UML::NamedElement 
	inherits SysML::Element::toNamedElement {
	if name = null then {
		name := self.ownedRedefinition.redefinedFeature![true].name;
	} endif;
}

mapping SysML::Feature::toProperty() : UML::Property
	inherits SysML::Element::toNamedElement {
	type := self.referencedType![true].late resolveone(UML::Type);
	self.mapMultiplicity(result);
}

mapping SysML::Feature::toInstanceSpecification(): UML::InstanceSpecification
	inherits SysML::Feature::toNamedElement {
	classifier += self.mapType();
}

mapping SysML::Feature::toClass(): UML::Class
	inherits SysML::Feature::toNamedElement {
	if name = null then {
		name := self.ownedRedefinition.redefinedFeature![true].name;
	} endif;
	self.ownedType->forEach (type) {
		var classifier = type.map toClass();
		nestedClassifier += classifier;
		
		var superclass := self.mapType();		
		if superclass <> null then {
			generalization += object UML::Generalization {
				general := superclass;
			}
		} endif;
	};
}

// Multiplicity

helper SysML::Feature::mapMultiplicity(inout element: UML::MultiplicityElement) {
	if self.upper <> null and self.upper.oclIsKindOf(SysML::LiteralUnbounded) then {
		element.upper := -1;
	} else if self.upper <> null then {
		element.upper := self.upper.oclAsType(SysML::LiteralInteger).value;
	} else {
		element.upper := 1;
	} endif endif;
	if self.lower <> null then {
		element.lower := self.lower.oclAsType(SysML::LiteralInteger).value;
	} else if element.upper = -1 then {
		element.lower := 0;
	} else {
		element.lower := element.upper;
	} endif endif;
}

