/*****************************************************************************
 * SysML 2 Pilot Implementation
 * Copyright (c) 2018-2019 Model Driven Solutions, Inc.
 *    
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 * @license LGPL-3.0-or-later <http://spdx.org/licenses/LGPL-3.0-or-later>
 * 
 * Contributors:
 *  Ed Seidewitz
 * 
 *****************************************************************************/

modeltype SysML uses "http://www.omg.org/spec/SysML/2.0";
modeltype UML uses "http://www.eclipse.org/uml2/5.0.0/UML";
modeltype Ecore uses "http://www.eclipse.org/emf/2002/Ecore";

transformation SysML2UML(in sysml: SysML, out uml: UML);

main() {
	object Model {
		name := "Model";
		packagedElement := sysml.rootObjects()[SysML::Package]->
			map toNamespace()[UML::PackageableElement];
	};
}

// CORE

// Element

query SysML::Element::name(): String {
	return if self.name = null then '<null>'
		else if self.name = '' then '<empty>'
		else self.name
		endif endif;
}

abstract mapping SysML::Element::toElement(): UML::Element {
	log('Mapping ' + self.metaClassName() + ' ' + self.name() + ' to ' + result.metaClassName());	
}

abstract mapping SysML::Element::toNamedElement(): UML::NamedElement
	inherits SysML::Element::toElement {	
	name := self.name;
//	var package = self.owningPackage;
//	if package <> null then {
//		var naming = package.namingOf(self);
//		name := naming.name;
//		visibility := toVisibilityKind(naming.visibility);
//	} endif;
}

mapping SysML::Element::toPackageableElement(): UML::PackageableElement
	disjuncts 
		SysML::Feature::toInstanceSpecification,
		SysML::Association::toAssociationClass,
		SysML::Class::toClass,
		SysML::Package::toPackage;

mapping SysML::Element::toClass(): UML::Class
	disjuncts
		SysML::Feature::toClass,
		SysML::Association::toAssociationClass,
		SysML::Class::toClass;

// Package

query SysML::Package::ownedMemberMemberships(): OrderedSet(SysML::Membership) {
	return self.ownedMembership[ownedMemberElement <> null];
}

query SysML::Package::ownedFeatureMemberships(): OrderedSet(SysML::Membership) {
	return self.ownedMemberMemberships()[ownedMemberElement.oclIsKindOf(SysML::Feature)];
}

query SysML::Package::ownedMembers(): Sequence(SysML::Element) {
	return self.ownedMemberMemberships().ownedMemberElement;
}

query SysML::Package::members(): Sequence(SysML::Element) {
	return self.ownedMembership.memberElement();
}

query SysML::Package::features(): Sequence(SysML::Feature) {
	return self.members()[SysML::Feature];
}

query SysML::Package::hasFeatures(): Boolean {
	return self.features()->notEmpty();
}

mapping SysML::Package::toNamespace(): UML::Namespace
	disjuncts 
		SysML::Association::toAssociationClass,
		SysML::Class::toClass,
		SysML::Package::toPackage;

mapping SysML::Package::toPackage(): UML::Package
	inherits SysML::Element::toNamedElement {
	packagedElement += self.ownedMemberMemberships()->mapToPackageableElement();
	packagedElement += self.features()->map toClass();
}

//query SysML::Package::namingOf(e: Element): Membership {
//	return self.membership![memberElement = e];
//}

// Membership

query SysML::Membership::memberElement(): SysML::Element {
	return 
		if self.memberElement <> null then self.memberElement
		else self.ownedMemberElement
		endif;
}

helper SysML::Membership::mapToPackageableElement(): UML::PackageableElement {
	var element := self.ownedMemberElement.map toPackageableElement();
	element.visibility := toVisibilityKind(self.visibility);
	return element;
}

helper SysML::Membership::mapToFeature(): UML::Feature {
	return self.memberElement().oclAsType(SysML::Feature).map toProperty();
}

helper SysML::FeatureMembership::mapToFeature(): UML::Feature {
	var feature := self.memberElement().oclAsType(SysML::Feature);
	var umlFeature: UML::Feature;
	if feature.oclIsKindOf(SysML::Connector) then {
		umlFeature := feature.oclAsType(SysML::Connector).map toConnector();
	} else if self.isPort then {
		umlFeature := feature.map toPort();
		if self.direction = SysML::FeatureDirectionKind::_out then {
			umlFeature.oclAsType(UML::Port).isConjugated := true;
		} endif;
	} else {
		umlFeature := feature.map toProperty();
		if self.isPart then {
			umlFeature.oclAsType(UML::Property).aggregation := UML::AggregationKind::composite;
		} endif;
	} endif endif;
	umlFeature.visibility := toVisibilityKind(self.visibility);
	return umlFeature;
}

query toVisibilityKind(visibility : SysML::VisibilityKind): UML::VisibilityKind {
	return 
		if visibility = null then null
		else if visibility = SysML::VisibilityKind::private then UML::VisibilityKind::private
		else if visibility = SysML::VisibilityKind::public then UML::VisibilityKind::public
		else if visibility = SysML::VisibilityKind::protected then UML::VisibilityKind::protected
		else if visibility = SysML::VisibilityKind::package then UML::VisibilityKind::package
		endif endif endif endif endif;
}

// CLASSIFICATION

// Category

abstract mapping SysML::Category::toClass(): UML::Class
	inherits SysML::Element::toNamedElement 
	when { not self.oclIsKindOf(SysML::Connector) } {
	var features := self.ownedFeatureMemberships()->mapToFeature();
	ownedAttribute := features[UML::Property];
	ownedConnector := features[UML::Connector];
	nestedClassifier := self.members()->map toClass();
	generalization := self.ownedMembers()[SysML::Generalization]->map toGeneralization();
}

// Class

mapping SysML::Class::toClass(): UML::Class
	inherits SysML::Category::toClass { }

// Association
mapping SysML::Association::toAssociationClass(): UML::AssociationClass
	inherits SysML::Element::toNamedElement {
	navigableOwnedEnd := self.ownedMemberMemberships()->mapToFeature()[UML::Property];
}

// Generalization

mapping SysML::Generalization::toGeneralization(): UML::Generalization
	when { self.oclIsTypeOf(SysML::Generalization) } {
	general := self.general.late resolveone(UML::Class);
}

// Feature

query SysML::Feature::subsettedFeatures(): Sequence(SysML::Feature) {
	return self.ownedMembers()[SysML::Subsetting].subsettedFeature;
}

query SysML::Feature::redefinedFeatures(): Sequence(SysML::Feature) {
	return self.ownedMembers()[SysML::Redefinition].redefinedFeature;
}

helper SysML::Feature::parentTypeElement(): SysML::Element{
	return if self.referencedType->notEmpty() then self.referencedType![true] 
		   else if self.redefinedFeatures()->notEmpty() then self.redefinedFeatures()![true].typeElement()
		   else if self.subsettedFeatures()->notEmpty() then self.subsettedFeatures()![true].typeElement()
		   else null 
		   endif endif endif;
}

helper SysML::Feature::typeElement(): SysML::Element {
	var parentTypeElement = self.parentTypeElement();
	return if parentTypeElement = null or self.hasFeatures() then self
		   else parentTypeElement
		   endif;
}

abstract mapping SysML::Feature::toNamedElement(): UML::NamedElement 
	inherits SysML::Element::toNamedElement {
	if name = null and self.redefinedFeatures()->notEmpty() then {
		name := self.redefinedFeatures()![true].name;
	} endif;
}

mapping SysML::Feature::toProperty(): UML::Property
	inherits SysML::Feature::toNamedElement {
	type := self.typeElement().late resolveone(UML::Class);
	self.mapMultiplicity(result);
	redefinedProperty := self.redefinedFeatures()->late resolveone(UML::Property);
	subsettedProperty := self.subsettedFeatures()->late resolveone(UML::Property);
	if self.isComposite then {
		aggregation := UML::AggregationKind::composite;
	} endif;
	if self.valuation <> null then {
		defaultValue := self.valuation.value.map toValueSpecification();
	} endif;
}

mapping SysML::Feature::toPort(): UML::Port
	inherits SysML::Feature::toProperty {
	aggregation := UML::AggregationKind::composite;
}

mapping SysML::Feature::toInstanceSpecification(): UML::InstanceSpecification
	inherits SysML::Feature::toNamedElement {
	classifier += self.typeElement().late resolveone(UML::Class);
}

mapping SysML::Feature::toClass(): UML::Class
	inherits SysML::Category::toClass, SysML::Feature::toNamedElement
	when { 	not self.oclIsKindOf(SysML::Connector) and
	        self.typeElement() = self } {
	var typeElement := self.parentTypeElement();
	if typeElement <> null then {
		generalization += object UML::Generalization {
			general := typeElement.late resolveone(UML::Class);
		}
	} endif;
	
//	self.ownedType->forEach (type) {
//		var classifier = type.map toClass();
//		nestedClassifier += classifier;
//		
//		var superclass := self.mapType();		
//		if superclass <> null then {
//			generalization += object UML::Generalization {
//				general := superclass;
//			}
//		} endif;
//	};
}

// Multiplicity

helper SysML::Feature::mapMultiplicity(inout element: UML::MultiplicityElement) {
	if self.multiplicity = null then {
		element.upper := 1;
		element.lower := 1;
	} else {
		if self.multiplicity.upper <> null and 
			self.multiplicity.upper.oclIsKindOf(SysML::LiteralUnbounded) then {
			element.upper := -1;
		} else if self.multiplicity.upper <> null then {
			element.upper := self.multiplicity.upper.oclAsType(SysML::LiteralInteger).value;
		} else {
			element.upper := 1;
		} endif endif;
		if self.multiplicity.lower <> null then {
			element.lower := self.multiplicity.lower.oclAsType(SysML::LiteralInteger).value;
		} else if element.upper = -1 then {
			element.lower := 0;
		} else {
			element.lower := element.upper;
		} endif endif;
	} endif;
}

// Connectors

mapping SysML::Connector::toConnector(): UML::Connector
	inherits SysML::Element::toNamedElement {
	// Note: This presumes that the connector ends are ordered the same as
	// the association ends.
	_end += self.connectorEnd->map toConnectorEnd();
	if self.association <> null then {
		type := self.association.late resolveone(UML::Association);
	} endif;
}

mapping SysML::ConnectorEnd::toConnectorEnd(): UML::ConnectorEnd {
	role := self.feature.late resolveone(UML::Property);
	if self.feature.owningMembership <> null and 
		self.feature.owningMembership.membershipOwningPackage.oclIsKindOf(SysML::Feature) then {
		partWithPort := self.feature.owningMembership.membershipOwningPackage.late resolveone(UML::Property);
	} endif;
}

constructor UML::ConnectorEnd::ConnectorEnd(feature: SysML::Feature) {
	role := feature.late resolveone(UML::Property);
	var element: SysML::Element := feature;
	if element.owningMembership <> null and 
		element.owningMembership.membershipOwningPackage.oclIsKindOf(SysML::Feature) then {
		partWithPort := element.owningMembership.membershipOwningPackage.late resolveone(UML::Property);
	} endif;
}

// BEHAVIOR

// Expressions

mapping SysML::Expression::toValueSpecification(): UML::ValueSpecification
	disjuncts
		SysML::NullExpression::toLiteralNull,
		SysML::LiteralExpression::toLiteralSpecification,
//		SysML::OperatorExpression::toExpression,
		SysML::InstanceCreationExpression::toExpression,
		SysML::SequenceAccessExpression::toExpression,
		SysML::SequenceConstructionExpression::toExpression,
		SysML::ElementReferenceExpression::toExpression;

mapping SysML::NullExpression::toLiteralNull(): UML::LiteralNull
	inherits SysML::Element::toNamedElement {
}

mapping SysML::LiteralExpression::toLiteralSpecification(): UML::LiteralSpecification
	disjuncts
		SysML::LiteralBoolean::toLiteralBoolean,
		SysML::LiteralString::toLiteralString,
		SysML::LiteralInteger::toLiteralInteger,
		SysML::LiteralReal::toLiteralReal,
		SysML::LiteralUnbounded::toLiteralUnlimitedNatural;

mapping SysML::LiteralBoolean::toLiteralBoolean(): UML::LiteralBoolean
	inherits SysML::Element::toNamedElement {
	value := self.value;
}

mapping SysML::LiteralString::toLiteralString(): UML::LiteralString
	inherits SysML::Element::toNamedElement {
	value := self.value;
}

mapping SysML::LiteralInteger::toLiteralInteger(): UML::LiteralInteger
	inherits SysML::Element::toNamedElement {
	value := self.value;
}

mapping SysML::LiteralReal::toLiteralReal(): UML::LiteralReal
	inherits SysML::Element::toNamedElement {
	value := self.value;
}

mapping SysML::LiteralUnbounded::toLiteralUnlimitedNatural(): UML::LiteralUnlimitedNatural
	inherits SysML::Element::toNamedElement {
	value := -1;
}


mapping SysML::OperatorExpression::toExpression(): UML::Expression
	inherits SysML::Element::toNamedElement {
	symbol := self.operator;
	operand := self.operand->map toValueSpecification();
}


mapping SysML::InstanceCreationExpression::toExpression(): UML::Expression
	inherits SysML::Element::toNamedElement {
	symbol := 'new ' + self._class.name;
	operand := self.argument->map toValueSpecification();
}

/*
mapping SysML::FeatureAccessExpression::toExpression(): UML::Expression
	inherits SysML::Element::toNamedElement {
	symbol := '.' + self.accessedFeature.name;
	operand += self.expression.map toValueSpecification();
}
*/

mapping SysML::SequenceAccessExpression::toExpression(): UML::Expression
	inherits SysML::Element::toNamedElement {
	symbol := 'at';
	operand += self.primary.map toValueSpecification();
	operand += self.index.map toValueSpecification();
}

mapping SysML::SequenceConstructionExpression::toExpression(): UML::Expression
	inherits SysML::Element::toNamedElement {
	symbol := 'sequence';
	operand := self.element->map toValueSpecification();
}

mapping SysML::ElementReferenceExpression::toExpression(): UML::Expression
	inherits SysML::Element::toNamedElement {
	symbol := self.referent.name;
}