/*****************************************************************************
 * SysML 2 Pilot Implementation
 * Copyright (c) 2018 Model Driven Solutions, Inc.
 *    
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 * @license LGPL-3.0-or-later <http://spdx.org/licenses/LGPL-3.0-or-later>
 * 
 * Contributors:
 *  Ed Seidewitz
 * 
 *****************************************************************************/

modeltype SysML uses "http://www.omg.org/spec/SysML/2.0";
modeltype UML uses "http://www.eclipse.org/uml2/5.0.0/UML";
modeltype Ecore uses "http://www.eclipse.org/emf/2002/Ecore";

transformation SysML2UML(in sysml: SysML, out uml: UML);

main() {
	object Model {
		name := "Model";
		packagedElement := sysml.rootObjects()[SysML::Package]->
			map toNamespace()[UML::PackageableElement];
	};
}

// CORE

// Element

query SysML::Element::name(): String {
	return if self.name = null then '<null>'
		else if self.name = '' then '<empty>'
		else self.name
		endif endif;
}

abstract mapping SysML::Element::toElement(): UML::Element {
	log('Mapping ' + self.metaClassName() + ' ' + self.name() + ' to ' + result.metaClassName());	
}

abstract mapping SysML::Element::toNamedElement(): UML::NamedElement
	inherits SysML::Element::toElement {	
	name := self.name;
//	var package = self.owningPackage;
//	if package <> null then {
//		var naming = package.namingOf(self);
//		name := naming.name;
//		visibility := toVisibilityKind(naming.visibility);
//	} endif;
}

mapping SysML::Element::toPackageableElement(): UML::PackageableElement
	disjuncts 
		SysML::Feature::toInstanceSpecification,
		SysML::Class::toClass,
		SysML::Package::toPackage;

mapping SysML::Element::toClass(): UML::Class
	disjuncts
		SysML::Feature::toClass,
		SysML::Class::toClass;

// PACKAGES

// Package

query SysML::Package::ownedMembers(): Sequence(SysML::Element) {
	return self.membership[ownedMemberElement <> null].ownedMemberElement;
}

query SysML::Package::members(): Sequence(SysML::Element) {
	return self.membership.memberElement();
}

query SysML::Package::features(): Sequence(SysML::Feature) {
	return self.members()[SysML::Feature];
}

query SysML::Package::hasFeatures(): Boolean {
	return self.features()->notEmpty();
}

mapping SysML::Package::toNamespace(): UML::Namespace
	disjuncts 
		SysML::Class::toClass,
		SysML::Package::toPackage;

mapping SysML::Package::toPackage(): UML::Package
	inherits SysML::Element::toNamedElement {
	packagedElement += self.membership->map toPackageableElement();
	packagedElement += self.features()->map toClass();
}

abstract mapping SysML::Package::toClass(): UML::Class 
	inherits SysML::Element::toNamedElement {
	ownedAttribute := self.membership->map toProperty();
	nestedClassifier := self.members()->map toClass();
}

//query SysML::Package::namingOf(e: Element): Membership {
//	return self.membership![memberElement = e];
//}

// Membership

query SysML::Membership::memberElement(): SysML::Element {
	return 
		if self.memberElement <> null then self.memberElement
		else self.ownedMemberElement
		endif;
}

helper SysML::Membership::mapToProperty(): UML::Property {
	return self.memberElement().oclAsType(SysML::Feature).map toProperty();
}

helper SysML::FeatureMembership::mapToProperty(): UML::Property {
	var feature := self.memberElement().oclAsType(SysML::Feature);
	return
		if self.direction = null then feature.map toProperty()
		else self.feature.map toPort()
		endif;
}

mapping SysML::Membership::toPackageableElement(): UML::PackageableElement
	when { self.ownedMemberElement <> null } {
init {
	result := self.ownedMemberElement.map toPackageableElement();
}
	visibility := toVisibilityKind(self.visibility);
}

mapping SysML::Membership::toProperty(): UML::Property
	when { self.memberElement().oclIsKindOf(SysML::Feature) } {
init {
	result := self.mapToProperty();
}
	visibility := toVisibilityKind(self.visibility);
	if self.memberName <> null then {
		name := self.memberName;
	} endif;
}

mapping SysML::FeatureMembership::toProperty(): UML::Property 
	inherits SysML::Membership::toProperty {
	if self.direction = SysML::FeatureDirectionKind::_out then {
		result.oclAsType(UML::Port).isConjugated := true;
	} endif;
}

query toVisibilityKind(visibility : SysML::VisibilityKind): UML::VisibilityKind {
	return 
		if visibility = null then null
		else if visibility = SysML::VisibilityKind::private then UML::VisibilityKind::private
		else if visibility = SysML::VisibilityKind::public then UML::VisibilityKind::public
		else if visibility = SysML::VisibilityKind::protected then UML::VisibilityKind::protected
		else if visibility = SysML::VisibilityKind::package then UML::VisibilityKind::package
		endif endif endif endif endif;
}

// CLASSIFICATION

// Class

mapping SysML::Class::toClass(): UML::Class
	inherits SysML::Package::toClass {
	var ownedGeneralizations := self.membership.ownedMemberElement[SysML::Generalization];
	generalization := ownedGeneralizations->map toGeneralization();
}

// Generalization

mapping SysML::Generalization::toGeneralization(): UML::Generalization {
	general := self.general.late resolveone(UML::Class);
}

// Feature

query SysML::Feature::subsettedFeatures(): Sequence(SysML::Feature) {
	return self.ownedMembers()[SysML::Subset].subsettedFeature;
}

query SysML::Feature::redefinedFeatures(): Sequence(SysML::Feature) {
	return self.ownedMembers()[SysML::Redefinition].redefinedFeature;
}

helper SysML::Feature::parentTypeElement(): SysML::Element{
	return if self.referencedType->notEmpty() then self.referencedType![true] 
		   else if self.redefinedFeatures()->notEmpty() then self.redefinedFeatures()![true].typeElement()
		   else if self.subsettedFeatures()->notEmpty() then self.subsettedFeatures()![true].typeElement()
		   else null 
		   endif endif endif;
}

helper SysML::Feature::typeElement(): SysML::Element {
	var parentTypeElement = self.parentTypeElement();
	return if parentTypeElement = null or self.hasFeatures() then self
		   else parentTypeElement
		   endif;
}

abstract mapping SysML::Feature::toNamedElement(): UML::NamedElement 
	inherits SysML::Element::toNamedElement {
	if name = null and self.redefinedFeatures()->notEmpty() then {
		name := self.redefinedFeatures()![true].name;
	} endif;
}

mapping SysML::Feature::toProperty(): UML::Property
	inherits SysML::Feature::toNamedElement {
	type := self.typeElement().late resolveone(UML::Class);
	self.mapMultiplicity(result);
	redefinedProperty := self.redefinedFeatures()->late resolveone(UML::Property);
	subsettedProperty := self.subsettedFeatures()->late resolveone(UML::Property);
	if self.value <> null then {
		defaultValue := self.value.map toValueSpecification();
	} endif;
}

mapping SysML::Feature::toPort(): UML::Port
	inherits SysML::Feature::toProperty {
}

mapping SysML::Feature::toInstanceSpecification(): UML::InstanceSpecification
	inherits SysML::Feature::toNamedElement {
	classifier += self.typeElement().late resolveone(UML::Class);
}

mapping SysML::Feature::toClass(): UML::Class
	inherits SysML::Package::toClass, SysML::Feature::toNamedElement
	when { self.typeElement() = self } {
	var typeElement := self.parentTypeElement();
	if typeElement <> null then {
		generalization += object UML::Generalization {
			general := typeElement.late resolveone(UML::Class);
		}
	} endif;
	
//	self.ownedType->forEach (type) {
//		var classifier = type.map toClass();
//		nestedClassifier += classifier;
//		
//		var superclass := self.mapType();		
//		if superclass <> null then {
//			generalization += object UML::Generalization {
//				general := superclass;
//			}
//		} endif;
//	};
}

// Multiplicity

helper SysML::Feature::mapMultiplicity(inout element: UML::MultiplicityElement) {
	if self.upper <> null and self.upper.oclIsKindOf(SysML::LiteralUnbounded) then {
		element.upper := -1;
	} else if self.upper <> null then {
		element.upper := self.upper.oclAsType(SysML::LiteralInteger).value;
	} else {
		element.upper := 1;
	} endif endif;
	if self.lower <> null then {
		element.lower := self.lower.oclAsType(SysML::LiteralInteger).value;
	} else if element.upper = -1 then {
		element.lower := 0;
	} else {
		element.lower := element.upper;
	} endif endif;
}

// Expressions

mapping SysML::Expression::toValueSpecification(): UML::ValueSpecification
	disjuncts
		SysML::LiteralExpression::toLiteralSpecification,
		SysML::OperatorExpression::toExpression,
		SysML::InstanceCreationExpression::toExpression,
		SysML::SequenceConstructionExpression::toExpression,
		SysML::ElementReferenceExpression::toExpression;

mapping SysML::LiteralExpression::toLiteralSpecification(): UML::LiteralSpecification
	disjuncts
		SysML::LiteralBoolean::toLiteralBoolean,
		SysML::LiteralString::toLiteralString,
		SysML::LiteralInteger::toLiteralInteger,
		SysML::LiteralReal::toLiteralReal,
		SysML::LiteralUnbounded::toLiteralUnlimitedNatural,
		SysML::LiteralNull::toLiteralNull;

mapping SysML::LiteralBoolean::toLiteralBoolean(): UML::LiteralBoolean
	inherits SysML::Element::toNamedElement {
	value := self.value;
}

mapping SysML::LiteralString::toLiteralString(): UML::LiteralString
	inherits SysML::Element::toNamedElement {
	value := self.value;
}

mapping SysML::LiteralInteger::toLiteralInteger(): UML::LiteralInteger
	inherits SysML::Element::toNamedElement {
	value := self.value;
}

mapping SysML::LiteralReal::toLiteralReal(): UML::LiteralReal
	inherits SysML::Element::toNamedElement {
	value := self.value;
}

mapping SysML::LiteralUnbounded::toLiteralUnlimitedNatural(): UML::LiteralUnlimitedNatural
	inherits SysML::Element::toNamedElement {
	value := -1;
}

mapping SysML::LiteralNull::toLiteralNull(): UML::LiteralNull
	inherits SysML::Element::toNamedElement {
}

mapping OperatorExpression::toExpression(): UML::Expression
	inherits SysML::Element::toNamedElement {
	symbol := self.operator;
	operand := self.operand->map toValueSpecification();
}

mapping InstanceCreationExpression::toExpression(): UML::Expression
	inherits SysML::Element::toNamedElement {
	symbol := 'new ' + self._class.name;
	operand := self.argument->map toValueSpecification();
}

mapping SequenceConstructionExpression::toExpression(): UML::Expression
	inherits SysML::Element::toNamedElement {
	symbol := 'sequence';
	operand := self.element->map toValueSpecification();
}

mapping ElementReferenceExpression::toExpression(): UML::Expression
	inherits SysML::Element::toNamedElement {
	symbol := self.referent.name;
}