/*
 * generated by Xtext 2.16.0
 */
package org.omg.sysml.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.omg.sysml.lang.sysml.Annotation;
import org.omg.sysml.lang.sysml.Association;
import org.omg.sysml.lang.sysml.Behavior;
import org.omg.sysml.lang.sysml.Comment;
import org.omg.sysml.lang.sysml.Connector;
import org.omg.sysml.lang.sysml.ConnectorEnd;
import org.omg.sysml.lang.sysml.EndFeatureMembership;
import org.omg.sysml.lang.sysml.Expression;
import org.omg.sysml.lang.sysml.Feature;
import org.omg.sysml.lang.sysml.FeatureMembership;
import org.omg.sysml.lang.sysml.FeatureTyping;
import org.omg.sysml.lang.sysml.FeatureValue;
import org.omg.sysml.lang.sysml.Function;
import org.omg.sysml.lang.sysml.Import;
import org.omg.sysml.lang.sysml.InstanceCreationExpression;
import org.omg.sysml.lang.sysml.LiteralBoolean;
import org.omg.sysml.lang.sysml.LiteralInteger;
import org.omg.sysml.lang.sysml.LiteralNull;
import org.omg.sysml.lang.sysml.LiteralReal;
import org.omg.sysml.lang.sysml.LiteralString;
import org.omg.sysml.lang.sysml.LiteralUnbounded;
import org.omg.sysml.lang.sysml.Membership;
import org.omg.sysml.lang.sysml.Multiplicity;
import org.omg.sysml.lang.sysml.ObjectClass;
import org.omg.sysml.lang.sysml.OperatorExpression;
import org.omg.sysml.lang.sysml.Redefinition;
import org.omg.sysml.lang.sysml.SequenceConstructionExpression;
import org.omg.sysml.lang.sysml.Subsetting;
import org.omg.sysml.lang.sysml.Superclassing;
import org.omg.sysml.lang.sysml.SysMLPackage;
import org.omg.sysml.lang.sysml.ValueClass;
import org.omg.sysml.services.AlfGrammarAccess;

@SuppressWarnings("all")
public class AlfSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AlfGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SysMLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SysMLPackage.ANNOTATION:
				sequence_Annotation(context, (Annotation) semanticObject); 
				return; 
			case SysMLPackage.ASSOCIATION:
				if (rule == grammarAccess.getNonFeatureDefinitionRule()) {
					sequence_AssociationBody_AssociationDeclaration_ClassDeclarationCompletion_SpecializationList(context, (Association) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssociationDefinitionOrStubRule()) {
					sequence_AssociationBody_AssociationDeclaration_ClassDeclarationCompletion_SpecializationList(context, (Association) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnitDefinitionRule()) {
					sequence_AssociationBody_AssociationDeclaration_ClassDeclarationCompletion_SpecializationList_UnitPrefix(context, (Association) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssociationUnitDefinitionRule()) {
					sequence_AssociationBody_AssociationDeclaration_ClassDeclarationCompletion_SpecializationList_UnitPrefix(context, (Association) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.BEHAVIOR:
				sequence_BehaviorDeclaration_ParameterList_SpecializationList(context, (Behavior) semanticObject); 
				return; 
			case SysMLPackage.CLASS:
				if (rule == grammarAccess.getNonFeatureDefinitionRule()) {
					sequence_CategoryBody_ClassDeclaration_ClassDeclarationCompletion_SpecializationList(context, (org.omg.sysml.lang.sysml.Class) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getClassDefinitionOrStubRule()) {
					sequence_CategoryBody_ClassDeclaration_ClassDeclarationCompletion_SpecializationList(context, (org.omg.sysml.lang.sysml.Class) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.COMMENT:
				sequence_Comment(context, (Comment) semanticObject); 
				return; 
			case SysMLPackage.CONNECTOR:
				sequence_CategoryBody_ConnectorDefinition(context, (Connector) semanticObject); 
				return; 
			case SysMLPackage.CONNECTOR_END:
				sequence_ConnectorEnd(context, (ConnectorEnd) semanticObject); 
				return; 
			case SysMLPackage.END_FEATURE_MEMBERSHIP:
				sequence_AssociationEndFeatureMember_CategoryMemberPrefix(context, (EndFeatureMembership) semanticObject); 
				return; 
			case SysMLPackage.EXPRESSION:
				sequence_FeatureReferenceExpression(context, (Expression) semanticObject); 
				return; 
			case SysMLPackage.FEATURE:
				if (rule == grammarAccess.getNamedFeatureDefinitionRule()) {
					sequence_CategoryBody_FeatureCompletion_FeatureDeclaration_Redefines_Subsets_SubsettingPart_TypePart(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnitDefinitionRule()) {
					sequence_CategoryBody_FeatureCompletion_FeatureDeclaration_Redefines_Subsets_SubsettingPart_TypePart_UnitPrefix(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFeatureUnitDefinitionRule()) {
					sequence_CategoryBody_FeatureCompletion_FeatureDeclaration_Redefines_Subsets_SubsettingPart_TypePart_UnitPrefix(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFeatureDefinitionRule()) {
					sequence_CategoryBody_FeatureCompletion_FeatureDeclaration_Redefines_Subsets_SubsettingPart_TypePart_UnnamedFeatureDefinition(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnnamedFeatureDefinitionRule()) {
					sequence_CategoryBody_FeatureCompletion_TypePart_UnnamedFeatureDefinition(context, (Feature) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.FEATURE_MEMBERSHIP:
				if (rule == grammarAccess.getCategoryMemberRule()
						|| rule == grammarAccess.getFeatureCategoryMemberRule()) {
					sequence_CategoryMemberPrefix_FeatureCategoryMember_FeatureMemberElement(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssociationMemberRule()) {
					sequence_CategoryMemberPrefix_FeatureMemberElement(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssociationFeatureMemberRule()) {
					sequence_CategoryMemberPrefix_FeatureMemberElement(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFeatureReferenceRule()) {
					sequence_FeatureReference(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getParameterMemberRule()) {
					sequence_ParameterMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getReturnParameterMemberRule()) {
					sequence_ReturnParameterMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.FEATURE_TYPING:
				if (rule == grammarAccess.getConnectorTypingRule()) {
					sequence_ConnectorTyping(context, (FeatureTyping) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFeatureTypingRule()) {
					sequence_FeatureTyping(context, (FeatureTyping) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.FEATURE_VALUE:
				sequence_FeatureValue(context, (FeatureValue) semanticObject); 
				return; 
			case SysMLPackage.FUNCTION:
				sequence_FunctionDeclaration_ParameterList_ReturnParameterPart_SpecializationList(context, (Function) semanticObject); 
				return; 
			case SysMLPackage.IMPORT:
				sequence_PackageImport(context, (Import) semanticObject); 
				return; 
			case SysMLPackage.INSTANCE_CREATION_EXPRESSION:
				sequence_InstanceCreationExpression_NamedTuple_PositionalTuple(context, (InstanceCreationExpression) semanticObject); 
				return; 
			case SysMLPackage.LITERAL_BOOLEAN:
				sequence_BooleanLiteralExpression(context, (LiteralBoolean) semanticObject); 
				return; 
			case SysMLPackage.LITERAL_INTEGER:
				sequence_NaturalLiteralExpression(context, (LiteralInteger) semanticObject); 
				return; 
			case SysMLPackage.LITERAL_NULL:
				sequence_NullExpression(context, (LiteralNull) semanticObject); 
				return; 
			case SysMLPackage.LITERAL_REAL:
				sequence_RealLiteralExpression(context, (LiteralReal) semanticObject); 
				return; 
			case SysMLPackage.LITERAL_STRING:
				sequence_StringLiteralExpression(context, (LiteralString) semanticObject); 
				return; 
			case SysMLPackage.LITERAL_UNBOUNDED:
				sequence_UnlimitedNaturalLiteralExpression(context, (LiteralUnbounded) semanticObject); 
				return; 
			case SysMLPackage.MEMBERSHIP:
				if (rule == grammarAccess.getCategoryMemberRule()
						|| rule == grammarAccess.getAssociationMemberRule()) {
					sequence_CategoryMemberPrefix_NonFeatureMemberElement(context, (Membership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNonFeatureCategoryMemberRule()) {
					sequence_CategoryMemberPrefix_NonFeatureMemberElement(context, (Membership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getElementImportRule()) {
					sequence_ElementImport_PackageMemberPrefix(context, (Membership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPackageMemberRule()) {
					sequence_FeaturePackageMemberElement_NonFeatureMemberElement_PackageMemberPrefix(context, (Membership) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.MULTIPLICITY:
				sequence_Multiplicity(context, (Multiplicity) semanticObject); 
				return; 
			case SysMLPackage.OBJECT_CLASS:
				if (rule == grammarAccess.getNonFeatureDefinitionRule()) {
					sequence_CategoryBody_ClassDeclarationCompletion_ObjectClassDeclaration_SpecializationList(context, (ObjectClass) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getObjectClassDefinitionOrStubRule()) {
					sequence_CategoryBody_ClassDeclarationCompletion_ObjectClassDeclaration_SpecializationList(context, (ObjectClass) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getObjectClassUnitDefinitionRule()) {
					sequence_CategoryBody_ClassDeclarationCompletion_ObjectClassDeclaration_SpecializationList_UnitPrefix(context, (ObjectClass) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnitDefinitionRule()) {
					sequence_CategoryBody_ClassDeclaration_ClassDeclarationCompletion_ObjectClassDeclaration_SpecializationList_UnitPrefix(context, (ObjectClass) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getClassUnitDefinitionRule()) {
					sequence_CategoryBody_ClassDeclaration_ClassDeclarationCompletion_SpecializationList_UnitPrefix(context, (ObjectClass) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.OPERATOR_EXPRESSION:
				sequence_BinaryExpression_SequenceAccessExpression_UnaryExpression(context, (OperatorExpression) semanticObject); 
				return; 
			case SysMLPackage.PACKAGE:
				if (rule == grammarAccess.getNonFeatureDefinitionRule()
						|| rule == grammarAccess.getPackageDefinitionOrStubRule()) {
					sequence_PackageDefinition(context, (org.omg.sysml.lang.sysml.Package) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnitDefinitionRule()
						|| rule == grammarAccess.getPackageUnitDefinitionRule()) {
					sequence_PackageDefinition_UnitPrefix(context, (org.omg.sysml.lang.sysml.Package) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.PARAMETER:
				sequence_Redefines_Subsets_TypePart(context, (org.omg.sysml.lang.sysml.Parameter) semanticObject); 
				return; 
			case SysMLPackage.REDEFINITION:
				sequence_Redefinition(context, (Redefinition) semanticObject); 
				return; 
			case SysMLPackage.SEQUENCE_CONSTRUCTION_EXPRESSION:
				sequence_SequenceConstructionExpression(context, (SequenceConstructionExpression) semanticObject); 
				return; 
			case SysMLPackage.SUBSETTING:
				sequence_Subset(context, (Subsetting) semanticObject); 
				return; 
			case SysMLPackage.SUPERCLASSING:
				sequence_Superclassing(context, (Superclassing) semanticObject); 
				return; 
			case SysMLPackage.VALUE_CLASS:
				if (rule == grammarAccess.getUnitDefinitionRule()) {
					sequence_CategoryBody_ClassDeclarationCompletion_SpecializationList_UnitPrefix_ValueClassDeclaration(context, (ValueClass) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getValueClassUnitDefinitionRule()) {
					sequence_CategoryBody_ClassDeclarationCompletion_SpecializationList_UnitPrefix_ValueClassDeclaration(context, (ValueClass) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNonFeatureDefinitionRule()) {
					sequence_CategoryBody_ClassDeclarationCompletion_SpecializationList_ValueClassDeclaration(context, (ValueClass) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getValueClassDefinitionOrStubRule()) {
					sequence_CategoryBody_ClassDeclarationCompletion_SpecializationList_ValueClassDeclaration(context, (ValueClass) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Annotation returns Annotation
	 *
	 * Constraint:
	 *     ownedRelatedElement+=Comment
	 */
	protected void sequence_Annotation(ISerializationContext context, Annotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NonFeatureDefinition returns Association
	 *
	 * Constraint:
	 *     (
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing?)? 
	 *         (ownedMembership+=AssociationMember | ownedImport+=PackageImport)*
	 *     )
	 */
	protected void sequence_AssociationBody_AssociationDeclaration_ClassDeclarationCompletion_SpecializationList(ISerializationContext context, Association semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     AssociationDefinitionOrStub returns Association
	//
	// Constraint:
	//     (
	//         isAbstract?='abstract'? 
	//         name=Name 
	//         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	//         (ownedMembership+=AssociationMember | ownedImport+=PackageImport)*
	//     )
	//
	// protected void sequence_AssociationBody_AssociationDeclaration_ClassDeclarationCompletion_SpecializationList(ISerializationContext context, Association semanticObject) { }
	
	/**
	 * Contexts:
	 *     UnitDefinition returns Association
	 *
	 * Constraint:
	 *     (
	 *         (ownedImport+=PackageImport | ownedMembership+=ElementImport)* 
	 *         ownedRelationship+=Annotation? 
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	 *         (ownedMembership+=AssociationMember | ownedImport+=PackageImport)*
	 *     )
	 */
	protected void sequence_AssociationBody_AssociationDeclaration_ClassDeclarationCompletion_SpecializationList_UnitPrefix(ISerializationContext context, Association semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     AssociationUnitDefinition returns Association
	//
	// Constraint:
	//     (
	//         (ownedImport+=PackageImport | ownedMembership+=ElementImport)* 
	//         ownedRelationship+=Annotation* 
	//         isAbstract?='abstract'? 
	//         name=Name 
	//         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	//         (ownedMembership+=AssociationMember | ownedImport+=PackageImport)*
	//     )
	//
	// protected void sequence_AssociationBody_AssociationDeclaration_ClassDeclarationCompletion_SpecializationList_UnitPrefix(ISerializationContext context, Association semanticObject) { }
	
	/**
	 * Contexts:
	 *     AssociationMember returns EndFeatureMembership
	 *     AssociationEndFeatureMember returns EndFeatureMembership
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=Annotation* 
	 *         visibility=VisibilityIndicator? 
	 *         (
	 *             ((isPart?='part' | isPort?='port')? direction=FeatureDirection? ownedMemberFeature=FeatureDefinition) | 
	 *             (isPart?='part' memberName=Name? memberFeature=[Feature|QualifiedName]) | 
	 *             (direction=FeatureDirection? ownedMemberFeature=NamedFeatureDefinition) | 
	 *             (memberName=Name memberFeature=[Feature|QualifiedName])
	 *         )
	 *     )
	 */
	protected void sequence_AssociationEndFeatureMember_CategoryMemberPrefix(ISerializationContext context, EndFeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NonFeatureDefinition returns Behavior
	 *     BehaviorDefinitionOrStub returns Behavior
	 *
	 * Constraint:
	 *     (
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedMembership+=ParameterMember ownedMembership+=ParameterMember*)? 
	 *         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)?
	 *     )
	 */
	protected void sequence_BehaviorDeclaration_ParameterList_SpecializationList(ISerializationContext context, Behavior semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns OperatorExpression
	 *     BinaryExpression returns OperatorExpression
	 *     BinaryExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     UnaryExpression returns OperatorExpression
	 *     SequenceAccessExpression returns OperatorExpression
	 *     SequenceAccessExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     PrimaryExpression returns OperatorExpression
	 *
	 * Constraint:
	 *     (
	 *         (operand+=BinaryExpression_OperatorExpression_1_0 ((operator=BinaryOperator operand+=Expression) | (operator='@' operand+=Expression))) | 
	 *         (operator=UnaryOperator operand+=SequenceAccessExpression) | 
	 *         (operand+=SequenceAccessExpression_OperatorExpression_1_0 operator='[' operand+=Expression)
	 *     )
	 */
	protected void sequence_BinaryExpression_SequenceAccessExpression_UnaryExpression(ISerializationContext context, OperatorExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralBoolean
	 *     BinaryExpression returns LiteralBoolean
	 *     BinaryExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     UnaryExpression returns LiteralBoolean
	 *     SequenceAccessExpression returns LiteralBoolean
	 *     SequenceAccessExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     PrimaryExpression returns LiteralBoolean
	 *     LiteralExpression returns LiteralBoolean
	 *     BooleanLiteralExpression returns LiteralBoolean
	 *
	 * Constraint:
	 *     value=BOOLEAN_VALUE
	 */
	protected void sequence_BooleanLiteralExpression(ISerializationContext context, LiteralBoolean semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.LITERAL_BOOLEAN__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.LITERAL_BOOLEAN__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanLiteralExpressionAccess().getValueBOOLEAN_VALUETerminalRuleCall_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NonFeatureDefinition returns ObjectClass
	 *
	 * Constraint:
	 *     (
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing?)? 
	 *         (ownedMembership+=CategoryMember | ownedImport+=PackageImport)*
	 *     )
	 */
	protected void sequence_CategoryBody_ClassDeclarationCompletion_ObjectClassDeclaration_SpecializationList(ISerializationContext context, ObjectClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     ObjectClassDefinitionOrStub returns ObjectClass
	//
	// Constraint:
	//     (
	//         isAbstract?='abstract'? 
	//         name=Name 
	//         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	//         (ownedMembership+=CategoryMember | ownedImport+=PackageImport)*
	//     )
	//
	// protected void sequence_CategoryBody_ClassDeclarationCompletion_ObjectClassDeclaration_SpecializationList(ISerializationContext context, ObjectClass semanticObject) { }
	
	/**
	 * Contexts:
	 *     ObjectClassUnitDefinition returns ObjectClass
	 *
	 * Constraint:
	 *     (
	 *         (ownedImport+=PackageImport | ownedMembership+=ElementImport)* 
	 *         ownedRelationship+=Annotation* 
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	 *         (ownedMembership+=CategoryMember | ownedImport+=PackageImport)*
	 *     )
	 */
	protected void sequence_CategoryBody_ClassDeclarationCompletion_ObjectClassDeclaration_SpecializationList_UnitPrefix(ISerializationContext context, ObjectClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitDefinition returns ValueClass
	 *
	 * Constraint:
	 *     (
	 *         (ownedImport+=PackageImport | ownedMembership+=ElementImport)* 
	 *         ownedRelationship+=Annotation? 
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	 *         (ownedMembership+=CategoryMember | ownedImport+=PackageImport)*
	 *     )
	 */
	protected void sequence_CategoryBody_ClassDeclarationCompletion_SpecializationList_UnitPrefix_ValueClassDeclaration(ISerializationContext context, ValueClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     ValueClassUnitDefinition returns ValueClass
	//
	// Constraint:
	//     (
	//         (ownedImport+=PackageImport | ownedMembership+=ElementImport)* 
	//         ownedRelationship+=Annotation* 
	//         isAbstract?='abstract'? 
	//         name=Name 
	//         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	//         (ownedMembership+=CategoryMember | ownedImport+=PackageImport)*
	//     )
	//
	// protected void sequence_CategoryBody_ClassDeclarationCompletion_SpecializationList_UnitPrefix_ValueClassDeclaration(ISerializationContext context, ValueClass semanticObject) { }
	
	/**
	 * Contexts:
	 *     NonFeatureDefinition returns ValueClass
	 *
	 * Constraint:
	 *     (
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing?)? 
	 *         (ownedMembership+=CategoryMember | ownedImport+=PackageImport)*
	 *     )
	 */
	protected void sequence_CategoryBody_ClassDeclarationCompletion_SpecializationList_ValueClassDeclaration(ISerializationContext context, ValueClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     ValueClassDefinitionOrStub returns ValueClass
	//
	// Constraint:
	//     (
	//         isAbstract?='abstract'? 
	//         name=Name 
	//         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	//         (ownedMembership+=CategoryMember | ownedImport+=PackageImport)*
	//     )
	//
	// protected void sequence_CategoryBody_ClassDeclarationCompletion_SpecializationList_ValueClassDeclaration(ISerializationContext context, ValueClass semanticObject) { }
	
	/**
	 * Contexts:
	 *     UnitDefinition returns ObjectClass
	 *
	 * Constraint:
	 *     (
	 *         ownedMembership+=ElementImport? 
	 *         (ownedImport+=PackageImport? ownedMembership+=ElementImport?)* 
	 *         ownedRelationship+=Annotation? 
	 *         (isAbstract?='abstract' | isAbstract?='abstract')? 
	 *         name=Name 
	 *         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	 *         (ownedMembership+=CategoryMember | ownedImport+=PackageImport)*
	 *     )
	 */
	protected void sequence_CategoryBody_ClassDeclaration_ClassDeclarationCompletion_ObjectClassDeclaration_SpecializationList_UnitPrefix(ISerializationContext context, ObjectClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NonFeatureDefinition returns Class
	 *
	 * Constraint:
	 *     (
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing?)? 
	 *         (ownedMembership+=CategoryMember | ownedImport+=PackageImport)*
	 *     )
	 */
	protected void sequence_CategoryBody_ClassDeclaration_ClassDeclarationCompletion_SpecializationList(ISerializationContext context, org.omg.sysml.lang.sysml.Class semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     ClassDefinitionOrStub returns Class
	//
	// Constraint:
	//     (
	//         isAbstract?='abstract'? 
	//         name=Name 
	//         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	//         (ownedMembership+=CategoryMember | ownedImport+=PackageImport)*
	//     )
	//
	// protected void sequence_CategoryBody_ClassDeclaration_ClassDeclarationCompletion_SpecializationList(ISerializationContext context, org.omg.sysml.lang.sysml.Class semanticObject) { }
	
	/**
	 * Contexts:
	 *     ClassUnitDefinition returns ObjectClass
	 *
	 * Constraint:
	 *     (
	 *         (ownedImport+=PackageImport | ownedMembership+=ElementImport)* 
	 *         ownedRelationship+=Annotation* 
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	 *         (ownedMembership+=CategoryMember | ownedImport+=PackageImport)*
	 *     )
	 */
	protected void sequence_CategoryBody_ClassDeclaration_ClassDeclarationCompletion_SpecializationList_UnitPrefix(ISerializationContext context, ObjectClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConnectorDefinition returns Connector
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (name=Name? ownedRelationship+=ConnectorTyping? connectorEnd+=ConnectorEnd connectorEnd+=ConnectorEnd) | 
	 *             (name=Name? ownedRelationship+=ConnectorTyping? connectorEnd+=ConnectorEnd connectorEnd+=ConnectorEnd connectorEnd+=ConnectorEnd*)
	 *         ) 
	 *         (ownedMembership+=CategoryMember | ownedImport+=PackageImport)*
	 *     )
	 */
	protected void sequence_CategoryBody_ConnectorDefinition(ISerializationContext context, Connector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedFeatureDefinition returns Feature
	 *
	 * Constraint:
	 *     (
	 *         name=Name 
	 *         isComposite?='compose'? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         multiplicity=Multiplicity? 
	 *         (isOrdered?='ordered' | isNonunique?='nonunique')* 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         valuation=FeatureValue? 
	 *         ownedMembership+=CategoryMember? 
	 *         (ownedImport+=PackageImport? ownedMembership+=CategoryMember?)*
	 *     )
	 */
	protected void sequence_CategoryBody_FeatureCompletion_FeatureDeclaration_Redefines_Subsets_SubsettingPart_TypePart(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitDefinition returns Feature
	 *
	 * Constraint:
	 *     (
	 *         (ownedImport+=PackageImport | ownedMembership+=ElementImport)* 
	 *         ownedRelationship+=Annotation? 
	 *         name=Name 
	 *         isComposite?='compose'? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         multiplicity=Multiplicity? 
	 *         isNonunique?='nonunique'? 
	 *         (isOrdered?='ordered'? isNonunique?='nonunique'?)* 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         valuation=FeatureValue? 
	 *         (ownedMembership+=CategoryMember | ownedImport+=PackageImport)*
	 *     )
	 */
	protected void sequence_CategoryBody_FeatureCompletion_FeatureDeclaration_Redefines_Subsets_SubsettingPart_TypePart_UnitPrefix(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     FeatureUnitDefinition returns Feature
	//
	// Constraint:
	//     (
	//         (ownedImport+=PackageImport | ownedMembership+=ElementImport)* 
	//         ownedRelationship+=Annotation* 
	//         name=Name 
	//         isComposite?='compose'? 
	//         ownedRelationship+=FeatureTyping? 
	//         multiplicity=Multiplicity? 
	//         (isOrdered?='ordered' | isNonunique?='nonunique')* 
	//         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	//         valuation=FeatureValue? 
	//         ownedMembership+=CategoryMember? 
	//         (ownedImport+=PackageImport? ownedMembership+=CategoryMember?)*
	//     )
	//
	// protected void sequence_CategoryBody_FeatureCompletion_FeatureDeclaration_Redefines_Subsets_SubsettingPart_TypePart_UnitPrefix(ISerializationContext context, Feature semanticObject) { }
	
	/**
	 * Contexts:
	 *     FeatureDefinition returns Feature
	 *
	 * Constraint:
	 *     (
	 *         (ownedRelationship+=Redefinition | name=Name) 
	 *         isComposite?='compose'? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         multiplicity=Multiplicity? 
	 *         isNonunique?='nonunique'? 
	 *         (isOrdered?='ordered'? isNonunique?='nonunique'?)* 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         valuation=FeatureValue? 
	 *         ownedImport+=PackageImport? 
	 *         (ownedMembership+=CategoryMember? ownedImport+=PackageImport?)*
	 *     )
	 */
	protected void sequence_CategoryBody_FeatureCompletion_FeatureDeclaration_Redefines_Subsets_SubsettingPart_TypePart_UnnamedFeatureDefinition(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnnamedFeatureDefinition returns Feature
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=Redefinition 
	 *         isComposite?='compose'? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         multiplicity=Multiplicity? 
	 *         (isOrdered?='ordered' | isNonunique?='nonunique')* 
	 *         valuation=FeatureValue? 
	 *         ownedMembership+=CategoryMember? 
	 *         (ownedImport+=PackageImport? ownedMembership+=CategoryMember?)*
	 *     )
	 */
	protected void sequence_CategoryBody_FeatureCompletion_TypePart_UnnamedFeatureDefinition(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CategoryMember returns FeatureMembership
	 *     FeatureCategoryMember returns FeatureMembership
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=Annotation* 
	 *         visibility=VisibilityIndicator? 
	 *         (
	 *             (direction=FeatureDirection? ownedMemberFeature=NamedFeatureDefinition) | 
	 *             (direction=FeatureDirection? memberName=Name memberFeature=[Feature|QualifiedName]) | 
	 *             (
	 *                 (isPart?='part' | isPort?='port')? 
	 *                 direction=FeatureDirection? 
	 *                 (ownedMemberFeature=FeatureDefinition | (memberName=Name? memberFeature=[Feature|QualifiedName]))
	 *             ) | 
	 *             ownedMemberFeature=ConnectorDefinition | 
	 *             (memberName=Name? memberFeature=[Connector|QualifiedName])
	 *         )
	 *     )
	 */
	protected void sequence_CategoryMemberPrefix_FeatureCategoryMember_FeatureMemberElement(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssociationMember returns FeatureMembership
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=Annotation? 
	 *         visibility=VisibilityIndicator? 
	 *         (
	 *             (
	 *                 (isPart?='part' | isPort?='port')? 
	 *                 direction=FeatureDirection? 
	 *                 (ownedMemberFeature=FeatureDefinition | (memberName=Name? memberFeature=[Feature|QualifiedName]))
	 *             ) | 
	 *             ownedMemberFeature=ConnectorDefinition | 
	 *             (memberName=Name? memberFeature=[Connector|QualifiedName])
	 *         )
	 *     )
	 */
	protected void sequence_CategoryMemberPrefix_FeatureMemberElement(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     AssociationFeatureMember returns FeatureMembership
	//
	// Constraint:
	//     (
	//         ownedRelationship+=Annotation* 
	//         visibility=VisibilityIndicator? 
	//         (
	//             (
	//                 (isPart?='part' | isPort?='port')? 
	//                 direction=FeatureDirection? 
	//                 (ownedMemberFeature=FeatureDefinition | (memberName=Name? memberFeature=[Feature|QualifiedName]))
	//             ) | 
	//             ownedMemberFeature=ConnectorDefinition | 
	//             (memberName=Name? memberFeature=[Connector|QualifiedName])
	//         )
	//     )
	//
	// protected void sequence_CategoryMemberPrefix_FeatureMemberElement(ISerializationContext context, FeatureMembership semanticObject) { }
	
	/**
	 * Contexts:
	 *     CategoryMember returns Membership
	 *     AssociationMember returns Membership
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=Annotation? 
	 *         visibility=VisibilityIndicator? 
	 *         (
	 *             ownedMemberElement=NonFeatureDefinition | 
	 *             (memberName=Name? memberElement=[Package|QualifiedName]) | 
	 *             (memberName=Name? memberElement=[Class|QualifiedName]) | 
	 *             (memberName=Name? memberElement=[ObjectClass|QualifiedName]) | 
	 *             (memberName=Name? memberElement=[ValueClass|QualifiedName]) | 
	 *             (memberName=Name? memberElement=[Association|QualifiedName]) | 
	 *             (memberName=Name? memberElement=[Behavior|QualifiedName]) | 
	 *             (memberName=Name? memberElement=[Function|QualifiedName]) | 
	 *             (memberElement=[Element|QualifiedName] memberName=Name?)
	 *         )
	 *     )
	 */
	protected void sequence_CategoryMemberPrefix_NonFeatureMemberElement(ISerializationContext context, Membership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     NonFeatureCategoryMember returns Membership
	//
	// Constraint:
	//     (
	//         ownedRelationship+=Annotation* 
	//         visibility=VisibilityIndicator? 
	//         (
	//             ownedMemberElement=NonFeatureDefinition | 
	//             (memberName=Name? memberElement=[Package|QualifiedName]) | 
	//             (memberName=Name? memberElement=[Class|QualifiedName]) | 
	//             (memberName=Name? memberElement=[ObjectClass|QualifiedName]) | 
	//             (memberName=Name? memberElement=[ValueClass|QualifiedName]) | 
	//             (memberName=Name? memberElement=[Association|QualifiedName]) | 
	//             (memberName=Name? memberElement=[Behavior|QualifiedName]) | 
	//             (memberName=Name? memberElement=[Function|QualifiedName]) | 
	//             (memberElement=[Element|QualifiedName] memberName=Name?)
	//         )
	//     )
	//
	// protected void sequence_CategoryMemberPrefix_NonFeatureMemberElement(ISerializationContext context, Membership semanticObject) { }
	
	/**
	 * Contexts:
	 *     Comment returns Comment
	 *
	 * Constraint:
	 *     body=DOCUMENTATION_COMMENT
	 */
	protected void sequence_Comment(ISerializationContext context, Comment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.COMMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.COMMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommentAccess().getBodyDOCUMENTATION_COMMENTTerminalRuleCall_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConnectorEnd returns ConnectorEnd
	 *
	 * Constraint:
	 *     (
	 *         (end=[Feature|QualifiedName]? feature=[Feature|QualifiedName] multiplicity=Multiplicity?) | 
	 *         (end=[Feature|QualifiedName] multiplicity=Multiplicity? feature=[Feature|QualifiedName])
	 *     )
	 */
	protected void sequence_ConnectorEnd(ISerializationContext context, ConnectorEnd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConnectorTyping returns FeatureTyping
	 *
	 * Constraint:
	 *     type=[Association|QualifiedName]
	 */
	protected void sequence_ConnectorTyping(ISerializationContext context, FeatureTyping semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.FEATURE_TYPING__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.FEATURE_TYPING__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConnectorTypingAccess().getTypeAssociationQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(SysMLPackage.Literals.FEATURE_TYPING__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ElementImport returns Membership
	 *
	 * Constraint:
	 *     (ownedRelationship+=Annotation* visibility=PackageElementVisibilityIndicator? memberElement=[Element|QualifiedName] memberName=Name?)
	 */
	protected void sequence_ElementImport_PackageMemberPrefix(ISerializationContext context, Membership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PackageMember returns Membership
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=Annotation* 
	 *         visibility=PackageElementVisibilityIndicator? 
	 *         (
	 *             ownedMemberElement=NonFeatureDefinition | 
	 *             (memberName=Name? memberElement=[Package|QualifiedName]) | 
	 *             (memberName=Name? memberElement=[Class|QualifiedName]) | 
	 *             (memberName=Name? memberElement=[ObjectClass|QualifiedName]) | 
	 *             (memberName=Name? memberElement=[ValueClass|QualifiedName]) | 
	 *             (memberName=Name? memberElement=[Association|QualifiedName]) | 
	 *             (memberName=Name? memberElement=[Behavior|QualifiedName]) | 
	 *             (memberName=Name? memberElement=[Function|QualifiedName]) | 
	 *             (memberElement=[Element|QualifiedName] memberName=Name?) | 
	 *             ownedMemberElement=NamedFeatureDefinition | 
	 *             ownedMemberElement=UnnamedFeatureDefinition | 
	 *             ((memberName=Name | memberName=Name)? memberElement=[Feature|QualifiedName])
	 *         )
	 *     )
	 */
	protected void sequence_FeaturePackageMemberElement_NonFeatureMemberElement_PackageMemberPrefix(ISerializationContext context, Membership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *     BinaryExpression returns Expression
	 *     BinaryExpression.OperatorExpression_1_0 returns Expression
	 *     UnaryExpression returns Expression
	 *     SequenceAccessExpression returns Expression
	 *     SequenceAccessExpression.OperatorExpression_1_0 returns Expression
	 *     PrimaryExpression returns Expression
	 *     FeatureReferenceExpression returns Expression
	 *
	 * Constraint:
	 *     ownedMembership+=FeatureReference
	 */
	protected void sequence_FeatureReferenceExpression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FeatureReference returns FeatureMembership
	 *
	 * Constraint:
	 *     memberFeature=[Feature|QualifiedName]
	 */
	protected void sequence_FeatureReference(ISerializationContext context, FeatureMembership semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.FEATURE_MEMBERSHIP__MEMBER_FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.FEATURE_MEMBERSHIP__MEMBER_FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFeatureReferenceAccess().getMemberFeatureFeatureQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(SysMLPackage.Literals.FEATURE_MEMBERSHIP__MEMBER_FEATURE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FeatureTyping returns FeatureTyping
	 *
	 * Constraint:
	 *     type=[Category|QualifiedName]
	 */
	protected void sequence_FeatureTyping(ISerializationContext context, FeatureTyping semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.FEATURE_TYPING__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.FEATURE_TYPING__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFeatureTypingAccess().getTypeCategoryQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(SysMLPackage.Literals.FEATURE_TYPING__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FeatureValue returns FeatureValue
	 *
	 * Constraint:
	 *     value=Expression
	 */
	protected void sequence_FeatureValue(ISerializationContext context, FeatureValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.FEATURE_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.FEATURE_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFeatureValueAccess().getValueExpressionParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NonFeatureDefinition returns Function
	 *     FunctionDefinitionOrStub returns Function
	 *
	 * Constraint:
	 *     (
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedMembership+=ParameterMember ownedMembership+=ParameterMember*)? 
	 *         ownedMembership+=ReturnParameterMember 
	 *         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)?
	 *     )
	 */
	protected void sequence_FunctionDeclaration_ParameterList_ReturnParameterPart_SpecializationList(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns InstanceCreationExpression
	 *     BinaryExpression returns InstanceCreationExpression
	 *     BinaryExpression.OperatorExpression_1_0 returns InstanceCreationExpression
	 *     UnaryExpression returns InstanceCreationExpression
	 *     SequenceAccessExpression returns InstanceCreationExpression
	 *     SequenceAccessExpression.OperatorExpression_1_0 returns InstanceCreationExpression
	 *     PrimaryExpression returns InstanceCreationExpression
	 *     InstanceCreationExpression returns InstanceCreationExpression
	 *
	 * Constraint:
	 *     (class=[Class|QualifiedName] ((argument+=Expression argument+=Expression*) | (argument+=Expression argument+=Expression*))?)
	 */
	protected void sequence_InstanceCreationExpression_NamedTuple_PositionalTuple(ISerializationContext context, InstanceCreationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Multiplicity returns Multiplicity
	 *
	 * Constraint:
	 *     (lower=NaturalLiteralExpression? upper=UnlimitedNaturalLiteralExpression)
	 */
	protected void sequence_Multiplicity(ISerializationContext context, Multiplicity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralInteger
	 *     BinaryExpression returns LiteralInteger
	 *     BinaryExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     UnaryExpression returns LiteralInteger
	 *     SequenceAccessExpression returns LiteralInteger
	 *     SequenceAccessExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     PrimaryExpression returns LiteralInteger
	 *     LiteralExpression returns LiteralInteger
	 *     NaturalLiteralExpression returns LiteralInteger
	 *     UnlimitedNaturalLiteralExpression returns LiteralInteger
	 *
	 * Constraint:
	 *     value=NATURAL_VALUE
	 */
	protected void sequence_NaturalLiteralExpression(ISerializationContext context, LiteralInteger semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.LITERAL_INTEGER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.LITERAL_INTEGER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNaturalLiteralExpressionAccess().getValueNATURAL_VALUETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralNull
	 *     BinaryExpression returns LiteralNull
	 *     BinaryExpression.OperatorExpression_1_0 returns LiteralNull
	 *     UnaryExpression returns LiteralNull
	 *     SequenceAccessExpression returns LiteralNull
	 *     SequenceAccessExpression.OperatorExpression_1_0 returns LiteralNull
	 *     PrimaryExpression returns LiteralNull
	 *     NullExpression returns LiteralNull
	 *
	 * Constraint:
	 *     {LiteralNull}
	 */
	protected void sequence_NullExpression(ISerializationContext context, LiteralNull semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NonFeatureDefinition returns Package
	 *     PackageDefinitionOrStub returns Package
	 *
	 * Constraint:
	 *     (name=Name (ownedMembership+=PackageMember | ownedImport+=PackageImport)*)
	 */
	protected void sequence_PackageDefinition(ISerializationContext context, org.omg.sysml.lang.sysml.Package semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitDefinition returns Package
	 *     PackageUnitDefinition returns Package
	 *
	 * Constraint:
	 *     (
	 *         (ownedImport+=PackageImport | ownedMembership+=ElementImport)* 
	 *         ownedRelationship+=Annotation* 
	 *         name=Name 
	 *         (ownedMembership+=PackageMember | ownedImport+=PackageImport)*
	 *     )
	 */
	protected void sequence_PackageDefinition_UnitPrefix(ISerializationContext context, org.omg.sysml.lang.sysml.Package semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PackageImport returns Import
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=Annotation* 
	 *         visibility=PackageElementVisibilityIndicator? 
	 *         (importedPackage=[Package|Name] | importedPackage=[Package|ColonQualifiedName] | importedPackage=[Package|DotQualifiedName])
	 *     )
	 */
	protected void sequence_PackageImport(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterMember returns FeatureMembership
	 *
	 * Constraint:
	 *     (direction=FeatureDirection? memberName=Name ownedMemberFeature=ParameterDefinition)
	 */
	protected void sequence_ParameterMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralReal
	 *     BinaryExpression returns LiteralReal
	 *     BinaryExpression.OperatorExpression_1_0 returns LiteralReal
	 *     UnaryExpression returns LiteralReal
	 *     SequenceAccessExpression returns LiteralReal
	 *     SequenceAccessExpression.OperatorExpression_1_0 returns LiteralReal
	 *     PrimaryExpression returns LiteralReal
	 *     LiteralExpression returns LiteralReal
	 *     RealLiteralExpression returns LiteralReal
	 *
	 * Constraint:
	 *     value=RealValue
	 */
	protected void sequence_RealLiteralExpression(ISerializationContext context, LiteralReal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.LITERAL_REAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.LITERAL_REAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealLiteralExpressionAccess().getValueRealValueParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParameterDefinition returns Parameter
	 *
	 * Constraint:
	 *     (
	 *         isComposite?='compose'? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         multiplicity=Multiplicity? 
	 *         (isOrdered?='ordered' | isNonunique?='nonunique')* 
	 *         ownedRelationship+=Subset? 
	 *         (ownedRelationship+=Redefinition? ownedRelationship+=Subset?)*
	 *     )
	 */
	protected void sequence_Redefines_Subsets_TypePart(ISerializationContext context, org.omg.sysml.lang.sysml.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Redefinition returns Redefinition
	 *
	 * Constraint:
	 *     redefinedFeature=[Feature|QualifiedName]
	 */
	protected void sequence_Redefinition(ISerializationContext context, Redefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.REDEFINITION__REDEFINED_FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.REDEFINITION__REDEFINED_FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRedefinitionAccess().getRedefinedFeatureFeatureQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(SysMLPackage.Literals.REDEFINITION__REDEFINED_FEATURE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ReturnParameterMember returns FeatureMembership
	 *
	 * Constraint:
	 *     (memberName=Name? ownedMemberFeature=ParameterDefinition)
	 */
	protected void sequence_ReturnParameterMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns SequenceConstructionExpression
	 *     BinaryExpression returns SequenceConstructionExpression
	 *     BinaryExpression.OperatorExpression_1_0 returns SequenceConstructionExpression
	 *     UnaryExpression returns SequenceConstructionExpression
	 *     SequenceAccessExpression returns SequenceConstructionExpression
	 *     SequenceAccessExpression.OperatorExpression_1_0 returns SequenceConstructionExpression
	 *     PrimaryExpression returns SequenceConstructionExpression
	 *     SequenceConstructionExpression returns SequenceConstructionExpression
	 *
	 * Constraint:
	 *     (element+=Expression element+=Expression*)?
	 */
	protected void sequence_SequenceConstructionExpression(ISerializationContext context, SequenceConstructionExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralString
	 *     BinaryExpression returns LiteralString
	 *     BinaryExpression.OperatorExpression_1_0 returns LiteralString
	 *     UnaryExpression returns LiteralString
	 *     SequenceAccessExpression returns LiteralString
	 *     SequenceAccessExpression.OperatorExpression_1_0 returns LiteralString
	 *     PrimaryExpression returns LiteralString
	 *     LiteralExpression returns LiteralString
	 *     StringLiteralExpression returns LiteralString
	 *
	 * Constraint:
	 *     value=STRING_VALUE
	 */
	protected void sequence_StringLiteralExpression(ISerializationContext context, LiteralString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.LITERAL_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.LITERAL_STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralExpressionAccess().getValueSTRING_VALUETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Subset returns Subsetting
	 *
	 * Constraint:
	 *     subsettedFeature=[Feature|QualifiedName]
	 */
	protected void sequence_Subset(ISerializationContext context, Subsetting semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.SUBSETTING__SUBSETTED_FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.SUBSETTING__SUBSETTED_FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubsetAccess().getSubsettedFeatureFeatureQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(SysMLPackage.Literals.SUBSETTING__SUBSETTED_FEATURE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Superclassing returns Superclassing
	 *
	 * Constraint:
	 *     superclass=[Class|QualifiedName]
	 */
	protected void sequence_Superclassing(ISerializationContext context, Superclassing semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.SUPERCLASSING__SUPERCLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.SUPERCLASSING__SUPERCLASS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSuperclassingAccess().getSuperclassClassQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(SysMLPackage.Literals.SUPERCLASSING__SUPERCLASS, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralUnbounded
	 *     BinaryExpression returns LiteralUnbounded
	 *     BinaryExpression.OperatorExpression_1_0 returns LiteralUnbounded
	 *     UnaryExpression returns LiteralUnbounded
	 *     SequenceAccessExpression returns LiteralUnbounded
	 *     SequenceAccessExpression.OperatorExpression_1_0 returns LiteralUnbounded
	 *     PrimaryExpression returns LiteralUnbounded
	 *     LiteralExpression returns LiteralUnbounded
	 *     UnlimitedNaturalLiteralExpression returns LiteralUnbounded
	 *
	 * Constraint:
	 *     {LiteralUnbounded}
	 */
	protected void sequence_UnlimitedNaturalLiteralExpression(ISerializationContext context, LiteralUnbounded semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
