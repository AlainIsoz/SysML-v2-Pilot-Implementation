/*
 * generated by Xtext 2.12.0
 */
package org.omg.sysml.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.omg.sysml.lang.sysml.Association;
import org.omg.sysml.lang.sysml.Comment;
import org.omg.sysml.lang.sysml.Connector;
import org.omg.sysml.lang.sysml.ConnectorEnd;
import org.omg.sysml.lang.sysml.ElementReferenceExpression;
import org.omg.sysml.lang.sysml.EndFeatureMembership;
import org.omg.sysml.lang.sysml.Feature;
import org.omg.sysml.lang.sysml.FeatureMembership;
import org.omg.sysml.lang.sysml.Generalization;
import org.omg.sysml.lang.sysml.Import;
import org.omg.sysml.lang.sysml.InstanceCreationExpression;
import org.omg.sysml.lang.sysml.LiteralBoolean;
import org.omg.sysml.lang.sysml.LiteralInteger;
import org.omg.sysml.lang.sysml.LiteralNull;
import org.omg.sysml.lang.sysml.LiteralReal;
import org.omg.sysml.lang.sysml.LiteralString;
import org.omg.sysml.lang.sysml.LiteralUnbounded;
import org.omg.sysml.lang.sysml.Membership;
import org.omg.sysml.lang.sysml.OperatorExpression;
import org.omg.sysml.lang.sysml.Redefinition;
import org.omg.sysml.lang.sysml.SequenceAccessExpression;
import org.omg.sysml.lang.sysml.SequenceConstructionExpression;
import org.omg.sysml.lang.sysml.Subset;
import org.omg.sysml.lang.sysml.SysMLPackage;
import org.omg.sysml.services.AlfGrammarAccess;

@SuppressWarnings("all")
public class AlfSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AlfGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SysMLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SysMLPackage.ASSOCIATION:
				if (rule == grammarAccess.getNonFeatureDefinitionRule()
						|| rule == grammarAccess.getAssociationDefinitionOrStubRule()) {
					sequence_AssociationBody_AssociationDeclaration(context, (Association) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnitDefinitionRule()) {
					sequence_AssociationBody_AssociationDeclaration_UnitPrefix(context, (Association) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssociationUnitDefinitionRule()) {
					sequence_AssociationBody_AssociationDeclaration_UnitPrefix(context, (Association) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.CLASS:
				if (rule == grammarAccess.getNonFeatureDefinitionRule()
						|| rule == grammarAccess.getClassDefinitionOrStubRule()) {
					sequence_ClassBody_ClassDeclaration(context, (org.omg.sysml.lang.sysml.Class) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnitDefinitionRule()) {
					sequence_ClassBody_ClassDeclaration_UnitPrefix(context, (org.omg.sysml.lang.sysml.Class) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getClassUnitDefinitionRule()) {
					sequence_ClassBody_ClassDeclaration_UnitPrefix(context, (org.omg.sysml.lang.sysml.Class) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.COMMENT:
				sequence_Comment(context, (Comment) semanticObject); 
				return; 
			case SysMLPackage.CONNECTOR:
				sequence_ConnectorDefinition(context, (Connector) semanticObject); 
				return; 
			case SysMLPackage.CONNECTOR_END:
				sequence_ConnectorEnd(context, (ConnectorEnd) semanticObject); 
				return; 
			case SysMLPackage.ELEMENT_REFERENCE_EXPRESSION:
				sequence_ElementReferenceExpression(context, (ElementReferenceExpression) semanticObject); 
				return; 
			case SysMLPackage.END_FEATURE_MEMBERSHIP:
				sequence_AssociationEndFeatureMember(context, (EndFeatureMembership) semanticObject); 
				return; 
			case SysMLPackage.FEATURE:
				if (rule == grammarAccess.getNamedFeatureDefinitionRule()) {
					sequence_ClassBody_FeatureCompletion_FeatureDeclaration_Multiplicity_TypePart(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFeatureDefinitionRule()) {
					sequence_ClassBody_FeatureCompletion_FeatureDeclaration_Multiplicity_TypePart_UnnamedFeatureDefinition(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnnamedFeatureDefinitionRule()) {
					sequence_ClassBody_FeatureCompletion_Multiplicity_TypePart_UnnamedFeatureDefinition(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnitDefinitionRule()) {
					sequence_ClassBody_FeatureDeclaration_Multiplicity_TypePart_UnitPrefix(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFeatureUnitDefinitionRule()) {
					sequence_ClassBody_FeatureDeclaration_Multiplicity_TypePart_UnitPrefix(context, (Feature) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.FEATURE_MEMBERSHIP:
				if (rule == grammarAccess.getAssociationMemberRule()
						|| rule == grammarAccess.getAssociationFeatureMemberRule()) {
					sequence_AssociationFeatureMember_FeatureMemberElement(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getClassMemberRule()
						|| rule == grammarAccess.getFeatureClassMemberRule()) {
					sequence_FeatureClassMember_FeatureMemberElement(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.GENERALIZATION:
				sequence_Generalization(context, (Generalization) semanticObject); 
				return; 
			case SysMLPackage.IMPORT:
				sequence_PackageImport(context, (Import) semanticObject); 
				return; 
			case SysMLPackage.INSTANCE_CREATION_EXPRESSION:
				sequence_InstanceCreationExpression(context, (InstanceCreationExpression) semanticObject); 
				return; 
			case SysMLPackage.LITERAL_BOOLEAN:
				sequence_BooleanLiteralExpression(context, (LiteralBoolean) semanticObject); 
				return; 
			case SysMLPackage.LITERAL_INTEGER:
				sequence_NaturalLiteralExpression(context, (LiteralInteger) semanticObject); 
				return; 
			case SysMLPackage.LITERAL_NULL:
				sequence_NullLiteralExpression(context, (LiteralNull) semanticObject); 
				return; 
			case SysMLPackage.LITERAL_REAL:
				sequence_RealLiteralExpression(context, (LiteralReal) semanticObject); 
				return; 
			case SysMLPackage.LITERAL_STRING:
				sequence_StringLiteralExpression(context, (LiteralString) semanticObject); 
				return; 
			case SysMLPackage.LITERAL_UNBOUNDED:
				sequence_UnlimitedNaturalLiteralExpression(context, (LiteralUnbounded) semanticObject); 
				return; 
			case SysMLPackage.MEMBERSHIP:
				if (rule == grammarAccess.getElementImportRule()) {
					sequence_ElementImport(context, (Membership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPackageMemberRule()) {
					sequence_FeaturePackageMemberElement_NonFeatureMemberElement_PackageMember(context, (Membership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getClassMemberRule()
						|| rule == grammarAccess.getNonFeatureClassMemberRule()
						|| rule == grammarAccess.getAssociationMemberRule()) {
					sequence_NonFeatureClassMember_NonFeatureMemberElement(context, (Membership) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.OPERATOR_EXPRESSION:
				sequence_BinaryExpression_UnaryExpression(context, (OperatorExpression) semanticObject); 
				return; 
			case SysMLPackage.PACKAGE:
				if (rule == grammarAccess.getNonFeatureDefinitionRule()
						|| rule == grammarAccess.getPackageDefinitionOrStubRule()) {
					sequence_PackageDefinition(context, (org.omg.sysml.lang.sysml.Package) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnitDefinitionRule()
						|| rule == grammarAccess.getPackageUnitDefinitionRule()) {
					sequence_PackageDefinition_UnitPrefix(context, (org.omg.sysml.lang.sysml.Package) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.REDEFINITION:
				sequence_Redefinition(context, (Redefinition) semanticObject); 
				return; 
			case SysMLPackage.SEQUENCE_ACCESS_EXPRESSION:
				sequence_SequenceAccessExpression(context, (SequenceAccessExpression) semanticObject); 
				return; 
			case SysMLPackage.SEQUENCE_CONSTRUCTION_EXPRESSION:
				sequence_SequenceConstructionExpression(context, (SequenceConstructionExpression) semanticObject); 
				return; 
			case SysMLPackage.SUBSET:
				sequence_Subset(context, (Subset) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     NonFeatureDefinition returns Association
	 *     AssociationDefinitionOrStub returns Association
	 *
	 * Constraint:
	 *     (
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedElement+=Generalization ownedElement+=Generalization*)? 
	 *         (ownedMembership+=AssociationMember | ownedImport+=PackageImport)*
	 *     )
	 */
	protected void sequence_AssociationBody_AssociationDeclaration(ISerializationContext context, Association semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitDefinition returns Association
	 *
	 * Constraint:
	 *     (
	 *         ownedMembership+=ElementImport? 
	 *         (ownedImport+=PackageImport ownedMembership+=ElementImport?)* 
	 *         ownedElement+=Comment? 
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedElement+=Generalization ownedElement+=Generalization*)? 
	 *         (ownedMembership+=AssociationMember | ownedImport+=PackageImport)*
	 *     )
	 */
	protected void sequence_AssociationBody_AssociationDeclaration_UnitPrefix(ISerializationContext context, Association semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     AssociationUnitDefinition returns Association
	//
	// Constraint:
	//     (
	//         (ownedImport+=PackageImport | ownedMembership+=ElementImport)* 
	//         ownedElement+=Comment* 
	//         isAbstract?='abstract'? 
	//         name=Name 
	//         (ownedElement+=Generalization ownedElement+=Generalization*)? 
	//         (ownedMembership+=AssociationMember | ownedImport+=PackageImport)*
	//     )
	//
	// protected void sequence_AssociationBody_AssociationDeclaration_UnitPrefix(ISerializationContext context, Association semanticObject) { }
	
	/**
	 * Contexts:
	 *     AssociationMember returns EndFeatureMembership
	 *     AssociationEndFeatureMember returns EndFeatureMembership
	 *
	 * Constraint:
	 *     (
	 *         ownedElement+=Comment* 
	 *         visibility=VisibilityIndicator? 
	 *         (
	 *             (direction=FeatureDirection? ownedMemberElement=FeatureDefinition) | 
	 *             (memberName=Name? memberElement=[Feature|QualifiedName]) | 
	 *             (direction=FeatureDirection? ownedMemberElement=NamedFeatureDefinition) | 
	 *             (memberName=Name memberElement=[Feature|QualifiedName])
	 *         )
	 *     )
	 */
	protected void sequence_AssociationEndFeatureMember(ISerializationContext context, EndFeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssociationMember returns FeatureMembership
	 *     AssociationFeatureMember returns FeatureMembership
	 *
	 * Constraint:
	 *     (
	 *         ownedElement+=Comment* 
	 *         visibility=VisibilityIndicator? 
	 *         (
	 *             ((isComposite?='part' | isPort?='port')? direction=FeatureDirection? ownedMemberElement=FeatureDefinition) | 
	 *             (isComposite?='part'? memberName=Name? memberElement=[Feature|QualifiedName]) | 
	 *             ownedMemberElement=ConnectorDefinition | 
	 *             (memberName=Name? memberElement=[Connector|QualifiedName])
	 *         )
	 *     )
	 */
	protected void sequence_AssociationFeatureMember_FeatureMemberElement(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns OperatorExpression
	 *     BinaryExpression returns OperatorExpression
	 *     BinaryExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     UnaryExpression returns OperatorExpression
	 *     SequenceAccessExpression returns OperatorExpression
	 *     SequenceAccessExpression.SequenceAccessExpression_1_0 returns OperatorExpression
	 *     PrimaryExpression returns OperatorExpression
	 *
	 * Constraint:
	 *     (
	 *         (operand+=BinaryExpression_OperatorExpression_1_0 ((operator=BinaryOperator operand+=Expression) | (operator='@' operand+=Expression))) | 
	 *         (operator=UnaryOperator operand+=SequenceAccessExpression)
	 *     )
	 */
	protected void sequence_BinaryExpression_UnaryExpression(ISerializationContext context, OperatorExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralBoolean
	 *     BinaryExpression returns LiteralBoolean
	 *     BinaryExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     UnaryExpression returns LiteralBoolean
	 *     SequenceAccessExpression returns LiteralBoolean
	 *     SequenceAccessExpression.SequenceAccessExpression_1_0 returns LiteralBoolean
	 *     PrimaryExpression returns LiteralBoolean
	 *     LiteralExpression returns LiteralBoolean
	 *     BooleanLiteralExpression returns LiteralBoolean
	 *
	 * Constraint:
	 *     value=BOOLEAN_VALUE
	 */
	protected void sequence_BooleanLiteralExpression(ISerializationContext context, LiteralBoolean semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.LITERAL_BOOLEAN__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.LITERAL_BOOLEAN__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanLiteralExpressionAccess().getValueBOOLEAN_VALUETerminalRuleCall_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NonFeatureDefinition returns Class
	 *     ClassDefinitionOrStub returns Class
	 *
	 * Constraint:
	 *     (
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedElement+=Generalization ownedElement+=Generalization*)? 
	 *         (ownedMembership+=ClassMember | ownedImport+=PackageImport)*
	 *     )
	 */
	protected void sequence_ClassBody_ClassDeclaration(ISerializationContext context, org.omg.sysml.lang.sysml.Class semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitDefinition returns Class
	 *
	 * Constraint:
	 *     (
	 *         ownedMembership+=ElementImport? 
	 *         (ownedImport+=PackageImport ownedMembership+=ElementImport?)* 
	 *         ownedElement+=Comment? 
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedElement+=Generalization ownedElement+=Generalization*)? 
	 *         (ownedMembership+=ClassMember | ownedImport+=PackageImport)*
	 *     )
	 */
	protected void sequence_ClassBody_ClassDeclaration_UnitPrefix(ISerializationContext context, org.omg.sysml.lang.sysml.Class semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     ClassUnitDefinition returns Class
	//
	// Constraint:
	//     (
	//         (ownedImport+=PackageImport | ownedMembership+=ElementImport)* 
	//         ownedElement+=Comment* 
	//         isAbstract?='abstract'? 
	//         name=Name 
	//         (ownedElement+=Generalization ownedElement+=Generalization*)? 
	//         (ownedMembership+=ClassMember | ownedImport+=PackageImport)*
	//     )
	//
	// protected void sequence_ClassBody_ClassDeclaration_UnitPrefix(ISerializationContext context, org.omg.sysml.lang.sysml.Class semanticObject) { }
	
	/**
	 * Contexts:
	 *     NamedFeatureDefinition returns Feature
	 *
	 * Constraint:
	 *     (
	 *         name=Name 
	 *         isComposite?='compose'? 
	 *         referencedType+=[Class|QualifiedName]? 
	 *         (lower=NaturalLiteralExpression? upper=UnlimitedNaturalLiteralExpression (isOrdered?='ordered' | isNonunique?='nonunique')*)? 
	 *         ownedElement+=SubsetOrRedefinition? 
	 *         value=Expression? 
	 *         ownedMembership+=ClassMember? 
	 *         (ownedImport+=PackageImport? ownedMembership+=ClassMember?)*
	 *     )
	 */
	protected void sequence_ClassBody_FeatureCompletion_FeatureDeclaration_Multiplicity_TypePart(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FeatureDefinition returns Feature
	 *
	 * Constraint:
	 *     (
	 *         (ownedElement+=SubsetOrRedefinition | name=Name) 
	 *         isComposite?='compose'? 
	 *         referencedType+=[Class|QualifiedName]? 
	 *         (lower=NaturalLiteralExpression? upper=UnlimitedNaturalLiteralExpression (isOrdered?='ordered' | isNonunique?='nonunique')*)? 
	 *         ownedElement+=SubsetOrRedefinition? 
	 *         value=Expression? 
	 *         ownedMembership+=ClassMember? 
	 *         (ownedImport+=PackageImport? ownedMembership+=ClassMember?)*
	 *     )
	 */
	protected void sequence_ClassBody_FeatureCompletion_FeatureDeclaration_Multiplicity_TypePart_UnnamedFeatureDefinition(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnnamedFeatureDefinition returns Feature
	 *
	 * Constraint:
	 *     (
	 *         ownedElement+=SubsetOrRedefinition 
	 *         isComposite?='compose'? 
	 *         referencedType+=[Class|QualifiedName]? 
	 *         (lower=NaturalLiteralExpression? upper=UnlimitedNaturalLiteralExpression (isOrdered?='ordered' | isNonunique?='nonunique')*)? 
	 *         value=Expression? 
	 *         ownedMembership+=ClassMember? 
	 *         (ownedImport+=PackageImport? ownedMembership+=ClassMember?)*
	 *     )
	 */
	protected void sequence_ClassBody_FeatureCompletion_Multiplicity_TypePart_UnnamedFeatureDefinition(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitDefinition returns Feature
	 *
	 * Constraint:
	 *     (
	 *         ownedMembership+=ElementImport? 
	 *         (ownedImport+=PackageImport ownedMembership+=ElementImport?)* 
	 *         ownedElement+=Comment? 
	 *         name=Name 
	 *         isComposite?='compose'? 
	 *         referencedType+=[Class|QualifiedName]? 
	 *         (
	 *             lower=NaturalLiteralExpression? 
	 *             upper=UnlimitedNaturalLiteralExpression 
	 *             isNonunique?='nonunique'? 
	 *             (isOrdered?='ordered'? isNonunique?='nonunique'?)*
	 *         )? 
	 *         ownedElement+=SubsetOrRedefinition? 
	 *         (ownedMembership+=ClassMember | ownedImport+=PackageImport)*
	 *     )
	 */
	protected void sequence_ClassBody_FeatureDeclaration_Multiplicity_TypePart_UnitPrefix(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     FeatureUnitDefinition returns Feature
	//
	// Constraint:
	//     (
	//         (ownedImport+=PackageImport | ownedMembership+=ElementImport)* 
	//         ownedElement+=Comment* 
	//         name=Name 
	//         isComposite?='compose'? 
	//         referencedType+=[Class|QualifiedName]? 
	//         (lower=NaturalLiteralExpression? upper=UnlimitedNaturalLiteralExpression (isOrdered?='ordered' | isNonunique?='nonunique')*)? 
	//         ownedElement+=SubsetOrRedefinition? 
	//         ownedMembership+=ClassMember? 
	//         (ownedImport+=PackageImport? ownedMembership+=ClassMember?)*
	//     )
	//
	// protected void sequence_ClassBody_FeatureDeclaration_Multiplicity_TypePart_UnitPrefix(ISerializationContext context, Feature semanticObject) { }
	
	/**
	 * Contexts:
	 *     Comment returns Comment
	 *
	 * Constraint:
	 *     body=DOCUMENTATION_COMMENT
	 */
	protected void sequence_Comment(ISerializationContext context, Comment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.COMMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.COMMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommentAccess().getBodyDOCUMENTATION_COMMENTTerminalRuleCall_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConnectorDefinition returns Connector
	 *
	 * Constraint:
	 *     (
	 *         (name=Name? association=[Association|QualifiedName]? connectorEnd+=ConnectorEnd connectorEnd+=ConnectorEnd) | 
	 *         (name=Name? association=[Association|QualifiedName]? connectorEnd+=ConnectorEnd connectorEnd+=ConnectorEnd connectorEnd+=ConnectorEnd*)
	 *     )
	 */
	protected void sequence_ConnectorDefinition(ISerializationContext context, Connector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConnectorEnd returns ConnectorEnd
	 *
	 * Constraint:
	 *     (end=[Feature|QualifiedName]? feature=[Feature|QualifiedName] (lower=NaturalLiteralExpression? upper=UnlimitedNaturalLiteralExpression)?)
	 */
	protected void sequence_ConnectorEnd(ISerializationContext context, ConnectorEnd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementImport returns Membership
	 *
	 * Constraint:
	 *     (visibility=PackageElementVisibilityIndicator? memberElement=[Element|QualifiedName] memberName=Name?)
	 */
	protected void sequence_ElementImport(ISerializationContext context, Membership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ElementReferenceExpression
	 *     BinaryExpression returns ElementReferenceExpression
	 *     BinaryExpression.OperatorExpression_1_0 returns ElementReferenceExpression
	 *     UnaryExpression returns ElementReferenceExpression
	 *     SequenceAccessExpression returns ElementReferenceExpression
	 *     SequenceAccessExpression.SequenceAccessExpression_1_0 returns ElementReferenceExpression
	 *     PrimaryExpression returns ElementReferenceExpression
	 *     ElementReferenceExpression returns ElementReferenceExpression
	 *
	 * Constraint:
	 *     referent=[Element|QualifiedName]
	 */
	protected void sequence_ElementReferenceExpression(ISerializationContext context, ElementReferenceExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.ELEMENT_REFERENCE_EXPRESSION__REFERENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.ELEMENT_REFERENCE_EXPRESSION__REFERENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementReferenceExpressionAccess().getReferentElementQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(SysMLPackage.Literals.ELEMENT_REFERENCE_EXPRESSION__REFERENT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassMember returns FeatureMembership
	 *     FeatureClassMember returns FeatureMembership
	 *
	 * Constraint:
	 *     (
	 *         ownedElement+=Comment* 
	 *         visibility=VisibilityIndicator? 
	 *         (
	 *             (direction=FeatureDirection? ownedMemberElement=NamedFeatureDefinition) | 
	 *             (memberName=Name memberElement=[Feature|QualifiedName]) | 
	 *             ((isComposite?='part' | isPort?='port')? direction=FeatureDirection? ownedMemberElement=FeatureDefinition) | 
	 *             (isComposite?='part'? memberName=Name? memberElement=[Feature|QualifiedName]) | 
	 *             ownedMemberElement=ConnectorDefinition | 
	 *             (memberName=Name? memberElement=[Connector|QualifiedName])
	 *         )
	 *     )
	 */
	protected void sequence_FeatureClassMember_FeatureMemberElement(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PackageMember returns Membership
	 *
	 * Constraint:
	 *     (
	 *         ownedElement+=Comment* 
	 *         visibility=PackageElementVisibilityIndicator? 
	 *         (
	 *             ownedMemberElement=NonFeatureDefinition | 
	 *             (memberName=Name? memberElement=[Package|QualifiedName]) | 
	 *             (memberName=Name? memberElement=[Class|QualifiedName]) | 
	 *             (memberName=Name? memberElement=[Association|QualifiedName]) | 
	 *             (memberElement=[Element|QualifiedName] memberName=Name?) | 
	 *             ownedMemberElement=NamedFeatureDefinition | 
	 *             ownedMemberElement=UnnamedFeatureDefinition | 
	 *             ((memberName=Name | memberName=Name)? memberElement=[Feature|QualifiedName])
	 *         )
	 *     )
	 */
	protected void sequence_FeaturePackageMemberElement_NonFeatureMemberElement_PackageMember(ISerializationContext context, Membership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Generalization returns Generalization
	 *
	 * Constraint:
	 *     general=[Class|QualifiedName]
	 */
	protected void sequence_Generalization(ISerializationContext context, Generalization semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.GENERALIZATION__GENERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.GENERALIZATION__GENERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGeneralizationAccess().getGeneralClassQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(SysMLPackage.Literals.GENERALIZATION__GENERAL, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns InstanceCreationExpression
	 *     BinaryExpression returns InstanceCreationExpression
	 *     BinaryExpression.OperatorExpression_1_0 returns InstanceCreationExpression
	 *     UnaryExpression returns InstanceCreationExpression
	 *     SequenceAccessExpression returns InstanceCreationExpression
	 *     SequenceAccessExpression.SequenceAccessExpression_1_0 returns InstanceCreationExpression
	 *     PrimaryExpression returns InstanceCreationExpression
	 *     InstanceCreationExpression returns InstanceCreationExpression
	 *
	 * Constraint:
	 *     (class=[Class|QualifiedName] (argument+=Expression argument+=Expression*)?)
	 */
	protected void sequence_InstanceCreationExpression(ISerializationContext context, InstanceCreationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralInteger
	 *     BinaryExpression returns LiteralInteger
	 *     BinaryExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     UnaryExpression returns LiteralInteger
	 *     SequenceAccessExpression returns LiteralInteger
	 *     SequenceAccessExpression.SequenceAccessExpression_1_0 returns LiteralInteger
	 *     PrimaryExpression returns LiteralInteger
	 *     LiteralExpression returns LiteralInteger
	 *     NaturalLiteralExpression returns LiteralInteger
	 *     UnlimitedNaturalLiteralExpression returns LiteralInteger
	 *
	 * Constraint:
	 *     value=NATURAL_VALUE
	 */
	protected void sequence_NaturalLiteralExpression(ISerializationContext context, LiteralInteger semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.LITERAL_INTEGER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.LITERAL_INTEGER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNaturalLiteralExpressionAccess().getValueNATURAL_VALUETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassMember returns Membership
	 *     NonFeatureClassMember returns Membership
	 *     AssociationMember returns Membership
	 *
	 * Constraint:
	 *     (
	 *         ownedElement+=Comment* 
	 *         visibility=VisibilityIndicator? 
	 *         (
	 *             ownedMemberElement=NonFeatureDefinition | 
	 *             (memberName=Name? memberElement=[Package|QualifiedName]) | 
	 *             (memberName=Name? memberElement=[Class|QualifiedName]) | 
	 *             (memberName=Name? memberElement=[Association|QualifiedName]) | 
	 *             (memberElement=[Element|QualifiedName] memberName=Name?)
	 *         )
	 *     )
	 */
	protected void sequence_NonFeatureClassMember_NonFeatureMemberElement(ISerializationContext context, Membership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralNull
	 *     BinaryExpression returns LiteralNull
	 *     BinaryExpression.OperatorExpression_1_0 returns LiteralNull
	 *     UnaryExpression returns LiteralNull
	 *     SequenceAccessExpression returns LiteralNull
	 *     SequenceAccessExpression.SequenceAccessExpression_1_0 returns LiteralNull
	 *     PrimaryExpression returns LiteralNull
	 *     LiteralExpression returns LiteralNull
	 *     NullLiteralExpression returns LiteralNull
	 *
	 * Constraint:
	 *     {LiteralNull}
	 */
	protected void sequence_NullLiteralExpression(ISerializationContext context, LiteralNull semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NonFeatureDefinition returns Package
	 *     PackageDefinitionOrStub returns Package
	 *
	 * Constraint:
	 *     (name=Name (ownedMembership+=PackageMember | ownedImport+=PackageImport)*)
	 */
	protected void sequence_PackageDefinition(ISerializationContext context, org.omg.sysml.lang.sysml.Package semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitDefinition returns Package
	 *     PackageUnitDefinition returns Package
	 *
	 * Constraint:
	 *     (
	 *         (ownedImport+=PackageImport | ownedMembership+=ElementImport)* 
	 *         ownedElement+=Comment* 
	 *         name=Name 
	 *         (ownedMembership+=PackageMember | ownedImport+=PackageImport)*
	 *     )
	 */
	protected void sequence_PackageDefinition_UnitPrefix(ISerializationContext context, org.omg.sysml.lang.sysml.Package semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PackageImport returns Import
	 *
	 * Constraint:
	 *     (
	 *         visibility=PackageElementVisibilityIndicator? 
	 *         (importedPackage=[Package|Name] | importedPackage=[Package|ColonQualifiedName] | importedPackage=[Package|DotQualifiedName])
	 *     )
	 */
	protected void sequence_PackageImport(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralReal
	 *     BinaryExpression returns LiteralReal
	 *     BinaryExpression.OperatorExpression_1_0 returns LiteralReal
	 *     UnaryExpression returns LiteralReal
	 *     SequenceAccessExpression returns LiteralReal
	 *     SequenceAccessExpression.SequenceAccessExpression_1_0 returns LiteralReal
	 *     PrimaryExpression returns LiteralReal
	 *     LiteralExpression returns LiteralReal
	 *     RealLiteralExpression returns LiteralReal
	 *
	 * Constraint:
	 *     value=RealValue
	 */
	protected void sequence_RealLiteralExpression(ISerializationContext context, LiteralReal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.LITERAL_REAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.LITERAL_REAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealLiteralExpressionAccess().getValueRealValueParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SubsetOrRedefinition returns Redefinition
	 *     Redefinition returns Redefinition
	 *
	 * Constraint:
	 *     redefinedFeature=[Feature|QualifiedName]
	 */
	protected void sequence_Redefinition(ISerializationContext context, Redefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.REDEFINITION__REDEFINED_FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.REDEFINITION__REDEFINED_FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRedefinitionAccess().getRedefinedFeatureFeatureQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(SysMLPackage.Literals.REDEFINITION__REDEFINED_FEATURE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns SequenceAccessExpression
	 *     BinaryExpression returns SequenceAccessExpression
	 *     BinaryExpression.OperatorExpression_1_0 returns SequenceAccessExpression
	 *     UnaryExpression returns SequenceAccessExpression
	 *     SequenceAccessExpression returns SequenceAccessExpression
	 *     SequenceAccessExpression.SequenceAccessExpression_1_0 returns SequenceAccessExpression
	 *     PrimaryExpression returns SequenceAccessExpression
	 *
	 * Constraint:
	 *     (primary=SequenceAccessExpression_SequenceAccessExpression_1_0 index=Expression)
	 */
	protected void sequence_SequenceAccessExpression(ISerializationContext context, SequenceAccessExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.SEQUENCE_ACCESS_EXPRESSION__PRIMARY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.SEQUENCE_ACCESS_EXPRESSION__PRIMARY));
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.SEQUENCE_ACCESS_EXPRESSION__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.SEQUENCE_ACCESS_EXPRESSION__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSequenceAccessExpressionAccess().getSequenceAccessExpressionPrimaryAction_1_0(), semanticObject.getPrimary());
		feeder.accept(grammarAccess.getSequenceAccessExpressionAccess().getIndexExpressionParserRuleCall_1_2_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns SequenceConstructionExpression
	 *     BinaryExpression returns SequenceConstructionExpression
	 *     BinaryExpression.OperatorExpression_1_0 returns SequenceConstructionExpression
	 *     UnaryExpression returns SequenceConstructionExpression
	 *     SequenceAccessExpression returns SequenceConstructionExpression
	 *     SequenceAccessExpression.SequenceAccessExpression_1_0 returns SequenceConstructionExpression
	 *     PrimaryExpression returns SequenceConstructionExpression
	 *     SequenceConstructionExpression returns SequenceConstructionExpression
	 *
	 * Constraint:
	 *     (element+=Expression element+=Expression*)?
	 */
	protected void sequence_SequenceConstructionExpression(ISerializationContext context, SequenceConstructionExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralString
	 *     BinaryExpression returns LiteralString
	 *     BinaryExpression.OperatorExpression_1_0 returns LiteralString
	 *     UnaryExpression returns LiteralString
	 *     SequenceAccessExpression returns LiteralString
	 *     SequenceAccessExpression.SequenceAccessExpression_1_0 returns LiteralString
	 *     PrimaryExpression returns LiteralString
	 *     LiteralExpression returns LiteralString
	 *     StringLiteralExpression returns LiteralString
	 *
	 * Constraint:
	 *     value=STRING_VALUE
	 */
	protected void sequence_StringLiteralExpression(ISerializationContext context, LiteralString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.LITERAL_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.LITERAL_STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralExpressionAccess().getValueSTRING_VALUETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SubsetOrRedefinition returns Subset
	 *     Subset returns Subset
	 *
	 * Constraint:
	 *     subsettedFeature=[Feature|QualifiedName]
	 */
	protected void sequence_Subset(ISerializationContext context, Subset semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.SUBSET__SUBSETTED_FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.SUBSET__SUBSETTED_FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubsetAccess().getSubsettedFeatureFeatureQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(SysMLPackage.Literals.SUBSET__SUBSETTED_FEATURE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralUnbounded
	 *     BinaryExpression returns LiteralUnbounded
	 *     BinaryExpression.OperatorExpression_1_0 returns LiteralUnbounded
	 *     UnaryExpression returns LiteralUnbounded
	 *     SequenceAccessExpression returns LiteralUnbounded
	 *     SequenceAccessExpression.SequenceAccessExpression_1_0 returns LiteralUnbounded
	 *     PrimaryExpression returns LiteralUnbounded
	 *     LiteralExpression returns LiteralUnbounded
	 *     UnlimitedNaturalLiteralExpression returns LiteralUnbounded
	 *
	 * Constraint:
	 *     {LiteralUnbounded}
	 */
	protected void sequence_UnlimitedNaturalLiteralExpression(ISerializationContext context, LiteralUnbounded semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
