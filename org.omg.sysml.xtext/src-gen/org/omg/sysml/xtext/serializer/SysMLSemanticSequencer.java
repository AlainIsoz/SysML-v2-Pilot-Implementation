/*
 * generated by Xtext 2.18.0.M3
 */
package org.omg.sysml.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.omg.sysml.lang.sysml.AcceptActionUsage;
import org.omg.sysml.lang.sysml.ActionUsage;
import org.omg.sysml.lang.sysml.Activity;
import org.omg.sysml.lang.sysml.Annotation;
import org.omg.sysml.lang.sysml.AssociationBlock;
import org.omg.sysml.lang.sysml.BindingConnector;
import org.omg.sysml.lang.sysml.Block;
import org.omg.sysml.lang.sysml.BlockExpression;
import org.omg.sysml.lang.sysml.Comment;
import org.omg.sysml.lang.sysml.ConditionalSuccession;
import org.omg.sysml.lang.sysml.ConjugatedPortMembership;
import org.omg.sysml.lang.sysml.ConnectionUsage;
import org.omg.sysml.lang.sysml.DecisionNode;
import org.omg.sysml.lang.sysml.EndFeatureMembership;
import org.omg.sysml.lang.sysml.Feature;
import org.omg.sysml.lang.sysml.FeatureMembership;
import org.omg.sysml.lang.sysml.FeatureReferenceExpression;
import org.omg.sysml.lang.sysml.FeatureTyping;
import org.omg.sysml.lang.sysml.FeatureValue;
import org.omg.sysml.lang.sysml.ForkNode;
import org.omg.sysml.lang.sysml.Import;
import org.omg.sysml.lang.sysml.InterfaceDefinition;
import org.omg.sysml.lang.sysml.InterfaceUsage;
import org.omg.sysml.lang.sysml.InvocationExpression;
import org.omg.sysml.lang.sysml.ItemFeature;
import org.omg.sysml.lang.sysml.ItemFlow;
import org.omg.sysml.lang.sysml.ItemFlowEnd;
import org.omg.sysml.lang.sysml.ItemFlowFeature;
import org.omg.sysml.lang.sysml.JoinNode;
import org.omg.sysml.lang.sysml.LiteralBoolean;
import org.omg.sysml.lang.sysml.LiteralInteger;
import org.omg.sysml.lang.sysml.LiteralReal;
import org.omg.sysml.lang.sysml.LiteralString;
import org.omg.sysml.lang.sysml.LiteralUnbounded;
import org.omg.sysml.lang.sysml.Membership;
import org.omg.sysml.lang.sysml.MergeNode;
import org.omg.sysml.lang.sysml.Multiplicity;
import org.omg.sysml.lang.sysml.NullExpression;
import org.omg.sysml.lang.sysml.OperatorExpression;
import org.omg.sysml.lang.sysml.ParameterMembership;
import org.omg.sysml.lang.sysml.PartProperty;
import org.omg.sysml.lang.sysml.PerformActionUsage;
import org.omg.sysml.lang.sysml.PortDefinition;
import org.omg.sysml.lang.sysml.PortMembership;
import org.omg.sysml.lang.sysml.PortUsage;
import org.omg.sysml.lang.sysml.QueryPathExpression;
import org.omg.sysml.lang.sysml.QueryPathStepExpression;
import org.omg.sysml.lang.sysml.QueryQualifierExpression;
import org.omg.sysml.lang.sysml.Redefinition;
import org.omg.sysml.lang.sysml.ReferenceProperty;
import org.omg.sysml.lang.sysml.SendActionUsage;
import org.omg.sysml.lang.sysml.SequenceConstructionExpression;
import org.omg.sysml.lang.sysml.SourceEnd;
import org.omg.sysml.lang.sysml.Subsetting;
import org.omg.sysml.lang.sysml.Succession;
import org.omg.sysml.lang.sysml.SuccessionItemFlow;
import org.omg.sysml.lang.sysml.Superclassing;
import org.omg.sysml.lang.sysml.SysMLPackage;
import org.omg.sysml.lang.sysml.TargetEnd;
import org.omg.sysml.lang.sysml.ValueProperty;
import org.omg.sysml.lang.sysml.ValueType;
import org.omg.sysml.xtext.services.SysMLGrammarAccess;

@SuppressWarnings("all")
public class SysMLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SysMLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SysMLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SysMLPackage.ACCEPT_ACTION_USAGE:
				sequence_AcceptActionNode_ActivityBody_MultiplicityPart_Typing(context, (AcceptActionUsage) semanticObject); 
				return; 
			case SysMLPackage.ACTION_USAGE:
				if (rule == grammarAccess.getAbstractActionUsageRule()) {
					sequence_AbstractActivityBody_ActionDeclaration_ActionParameterList_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_ValuePart(context, (ActionUsage) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getActivityNodeRule()
						|| rule == grammarAccess.getActionNodeRule()) {
					sequence_ActionDeclaration_ActionNode_ActionParameterList_ActivityBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_ValuePart(context, (ActionUsage) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getActionUsageRule()) {
					sequence_ActionDeclaration_ActionParameterList_ActivityBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_ValuePart(context, (ActionUsage) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnitRule()) {
					sequence_Action_ActionParameterList_ActivityBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UnitPrefix_ValuePart(context, (ActionUsage) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getActionUnitRule()) {
					sequence_Action_ActionParameterList_ActivityBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UnitPrefix_ValuePart(context, (ActionUsage) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.ACTIVITY:
				if (rule == grammarAccess.getActivityOrStubRule()) {
					sequence_ActivityBody_ActivityDeclaration_ParameterList_SuperclassingList(context, (Activity) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnitRule()) {
					sequence_ActivityBody_ActivityDeclaration_ParameterList_SuperclassingList_UnitPrefix(context, (Activity) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getActivityUnitRule()) {
					sequence_ActivityBody_ActivityDeclaration_ParameterList_SuperclassingList_UnitPrefix(context, (Activity) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.ANNOTATION:
				if (rule == grammarAccess.getAnnotationRule()) {
					sequence_Annotation(context, (Annotation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEmptyAnnotationRule()) {
					sequence_EmptyAnnotation(context, (Annotation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrefixAnnotationRule()) {
					sequence_PrefixAnnotation(context, (Annotation) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.ASSOCIATION_BLOCK:
				if (rule == grammarAccess.getAssociationBlockOrStubRule()) {
					sequence_AssociationBlockBody_AssociationBlockDeclaration_ClassifierDeclarationCompletion_SuperclassingList(context, (AssociationBlock) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnitRule()) {
					sequence_AssociationBlockBody_AssociationBlockDeclaration_ClassifierDeclarationCompletion_SuperclassingList_UnitPrefix(context, (AssociationBlock) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssociationBlockUnitRule()) {
					sequence_AssociationBlockBody_AssociationBlockDeclaration_ClassifierDeclarationCompletion_SuperclassingList_UnitPrefix(context, (AssociationBlock) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.BINDING_CONNECTOR:
				sequence_BindingConnector_DefinitionBody_MultiplicityPart_Typing(context, (BindingConnector) semanticObject); 
				return; 
			case SysMLPackage.BLOCK:
				if (rule == grammarAccess.getBlockOrStubRule()) {
					sequence_BlockDeclaration_ClassifierDeclarationCompletion_DefinitionBody_SuperclassingList(context, (Block) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnitRule()) {
					sequence_BlockDeclaration_ClassifierDeclarationCompletion_DefinitionBody_SuperclassingList_UnitPrefix(context, (Block) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBlockUnitRule()) {
					sequence_BlockDeclaration_ClassifierDeclarationCompletion_DefinitionBody_SuperclassingList_UnitPrefix(context, (Block) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.BLOCK_EXPRESSION:
				sequence_BodyExpression(context, (BlockExpression) semanticObject); 
				return; 
			case SysMLPackage.COMMENT:
				if (rule == grammarAccess.getCommentRule()) {
					sequence_Comment(context, (Comment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDocumentationRule()) {
					sequence_Documentation(context, (Comment) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.CONDITIONAL_SUCCESSION:
				if (rule == grammarAccess.getConditionalSuccessionRule()) {
					sequence_ConditionalSuccession(context, (ConditionalSuccession) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDefaultSuccessionRule()) {
					sequence_DefaultSuccession(context, (ConditionalSuccession) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.CONJUGATED_PORT_MEMBERSHIP:
				sequence_ConjugatedPortMember_DefinitionMemberPrefix(context, (ConjugatedPortMembership) semanticObject); 
				return; 
			case SysMLPackage.CONNECTION_USAGE:
				if (rule == grammarAccess.getAbstractConnectorRule()) {
					sequence_AbstractAssociationBlockBody_ConnectionPart(context, (ConnectionUsage) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAbstractConnectionUsageRule()) {
					sequence_AbstractAssociationBlockBody_ConnectionPart_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration(context, (ConnectionUsage) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConnectorRule()) {
					sequence_AssociationBlockBody_ConnectionPart(context, (ConnectionUsage) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConnectionUsageRule()) {
					sequence_AssociationBlockBody_ConnectionPart_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration(context, (ConnectionUsage) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.DECISION_NODE:
				sequence_DecisionNode_MultiplicityPart_Typing(context, (DecisionNode) semanticObject); 
				return; 
			case SysMLPackage.END_FEATURE_MEMBERSHIP:
				if (rule == grammarAccess.getAssociationMemberRule()
						|| rule == grammarAccess.getAssociationEndMemberRule()) {
					sequence_AssociationEndMember_DefinitionMemberPrefix(context, (EndFeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConnectorEndMemberRule()) {
					sequence_ConnectorEndMember(context, (EndFeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getInterfaceMemberRule()
						|| rule == grammarAccess.getInterfaceEndMemberRule()) {
					sequence_DefinitionMemberPrefix_InterfaceEndMember(context, (EndFeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEmptySourceEndMemberRule()) {
					sequence_EmptySourceEndMember(context, (EndFeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEmptyTargetEndMemberRule()) {
					sequence_EmptyTargetEndMember(context, (EndFeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getItemFlowEndMemberRule()) {
					sequence_ItemFlowEndMember(context, (EndFeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMultiplicitySourceEndMemberRule()) {
					sequence_MultiplicitySourceEndMember(context, (EndFeatureMembership) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.FEATURE:
				if (rule == grammarAccess.getConnectorEndRule()) {
					sequence_ConnectorEnd(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeReferenceRule()) {
					sequence_TypeReference(context, (Feature) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.FEATURE_MEMBERSHIP:
				if (rule == grammarAccess.getActionMemberRule()) {
					sequence_ActionMember_DefinitionMemberPrefix(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDefinitionMemberRule()
						|| rule == grammarAccess.getNestedUsageMemberRule()
						|| rule == grammarAccess.getAssociationMemberRule()
						|| rule == grammarAccess.getInterfaceMemberRule()) {
					sequence_ActionMember_DefinitionMemberPrefix_PrimaryUsageMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getActionParameterFlowMemberRule()) {
					sequence_ActionParameterFlowMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getActivityNodeMemberRule()) {
					sequence_ActivityNodeMember_DefinitionMemberPrefix(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getActivityMemberRule()) {
					sequence_ActivityNodeMember_DefinitionMemberPrefix_PrimaryUsageMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBodyMemberRule()) {
					sequence_BodyMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConditionalSuccessionMemberRule()) {
					sequence_ConditionalSuccessionMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDefaultSuccessionMemberRule()) {
					sequence_DefaultSuccessionMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryUsageMemberRule()) {
					sequence_DefinitionMemberPrefix_PrimaryUsageMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEmptyItemFeatureMemberRule()) {
					sequence_EmptyItemFeatureMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEmptySuccessionMemberRule()) {
					sequence_EmptySuccessionMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionMemberRule()) {
					sequence_ExpressionMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFeatureReferenceRule()) {
					sequence_FeatureReference(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getItemFeatureMemberRule()) {
					sequence_ItemFeatureMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getItemFlowFeatureMemberRule()) {
					sequence_ItemFlowFeatureMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNamedExpressionMemberRule()) {
					sequence_NamedExpressionMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeReferenceMemberRule()) {
					sequence_TypeReferenceMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.FEATURE_REFERENCE_EXPRESSION:
				sequence_FeatureReferenceExpression(context, (FeatureReferenceExpression) semanticObject); 
				return; 
			case SysMLPackage.FEATURE_TYPING:
				if (rule == grammarAccess.getExpressionTypingRule()) {
					sequence_ExpressionTyping(context, (FeatureTyping) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFeatureTypingRule()) {
					sequence_FeatureTyping(context, (FeatureTyping) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.FEATURE_VALUE:
				sequence_FeatureValue(context, (FeatureValue) semanticObject); 
				return; 
			case SysMLPackage.FORK_NODE:
				sequence_ForkNode_MultiplicityPart_Typing(context, (ForkNode) semanticObject); 
				return; 
			case SysMLPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case SysMLPackage.INTERFACE_DEFINITION:
				if (rule == grammarAccess.getInterfaceDefinitionOrStubRule()) {
					sequence_ClassifierDeclarationCompletion_InterfaceBody_InterfaceDeclaration_SuperclassingList(context, (InterfaceDefinition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnitRule()) {
					sequence_ClassifierDeclarationCompletion_InterfaceBody_InterfaceDeclaration_SuperclassingList_UnitPrefix(context, (InterfaceDefinition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getInterfaceDefinitionUnitRule()) {
					sequence_ClassifierDeclarationCompletion_InterfaceBody_InterfaceDeclaration_SuperclassingList_UnitPrefix(context, (InterfaceDefinition) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.INTERFACE_USAGE:
				if (rule == grammarAccess.getAbstractInterfaceUsageRule()) {
					sequence_AbstractInterfaceBody_ConnectionPart_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration(context, (InterfaceUsage) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getInterfaceUsageRule()) {
					sequence_ConnectionPart_InterfaceBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration(context, (InterfaceUsage) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.INVOCATION_EXPRESSION:
				sequence_InvocationExpression_NamedTuple_PositionalTuple(context, (InvocationExpression) semanticObject); 
				return; 
			case SysMLPackage.ITEM_FEATURE:
				if (rule == grammarAccess.getEmptyItemFeatureRule()) {
					sequence_EmptyItemFeature(context, (ItemFeature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getItemFeatureTypingRule()) {
					sequence_ItemFeatureTyping(context, (ItemFeature) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.ITEM_FLOW:
				if (rule == grammarAccess.getAbstractItemFlowRule()) {
					sequence_AbstractDefinitionBody_ItemFlowDeclaration_MultiplicityPart_Typing(context, (ItemFlow) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getActionParameterFlowRule()) {
					sequence_ActionParameterFlow(context, (ItemFlow) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getItemFlowRule()) {
					sequence_DefinitionBody_ItemFlowDeclaration_MultiplicityPart_Typing(context, (ItemFlow) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.ITEM_FLOW_END:
				sequence_ItemFlowEnd(context, (ItemFlowEnd) semanticObject); 
				return; 
			case SysMLPackage.ITEM_FLOW_FEATURE:
				sequence_ItemFlowFeature(context, (ItemFlowFeature) semanticObject); 
				return; 
			case SysMLPackage.JOIN_NODE:
				sequence_JoinNode_MultiplicityPart_Typing(context, (JoinNode) semanticObject); 
				return; 
			case SysMLPackage.LITERAL_BOOLEAN:
				sequence_BooleanLiteralExpression(context, (LiteralBoolean) semanticObject); 
				return; 
			case SysMLPackage.LITERAL_INTEGER:
				sequence_NaturalLiteralExpression(context, (LiteralInteger) semanticObject); 
				return; 
			case SysMLPackage.LITERAL_REAL:
				sequence_RealLiteralExpression(context, (LiteralReal) semanticObject); 
				return; 
			case SysMLPackage.LITERAL_STRING:
				sequence_StringLiteralExpression(context, (LiteralString) semanticObject); 
				return; 
			case SysMLPackage.LITERAL_UNBOUNDED:
				sequence_UnlimitedNaturalLiteralExpression(context, (LiteralUnbounded) semanticObject); 
				return; 
			case SysMLPackage.MEMBERSHIP:
				if (rule == grammarAccess.getDefinitionMemberRule()
						|| rule == grammarAccess.getNestedDefinitionMemberRule()
						|| rule == grammarAccess.getAssociationMemberRule()
						|| rule == grammarAccess.getInterfaceMemberRule()
						|| rule == grammarAccess.getActivityMemberRule()) {
					sequence_DefinitionMemberPrefix_PackagedDefinitionMember(context, (Membership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPackageMemberRule()) {
					sequence_PackageMemberPrefix_PackagedDefinitionMember_PackagedUsageMember(context, (Membership) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.MERGE_NODE:
				sequence_MergeNode_MultiplicityPart_Typing(context, (MergeNode) semanticObject); 
				return; 
			case SysMLPackage.MULTIPLICITY:
				sequence_Multiplicity(context, (Multiplicity) semanticObject); 
				return; 
			case SysMLPackage.NULL_EXPRESSION:
				sequence_NullExpression(context, (NullExpression) semanticObject); 
				return; 
			case SysMLPackage.OPERATOR_EXPRESSION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getConditionalExpressionRule()
						|| action == grammarAccess.getConditionalExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getNullCoalescingExpressionRule()
						|| action == grammarAccess.getNullCoalescingExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getConditionalOrExpressionRule()
						|| action == grammarAccess.getConditionalOrExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getConditionalAndExpressionRule()
						|| action == grammarAccess.getConditionalAndExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getEqualityExpressionRule()
						|| action == grammarAccess.getEqualityExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getClassificationExpressionRule()
						|| action == grammarAccess.getClassificationExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getUnitsExpressionRule()
						|| action == grammarAccess.getUnitsExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getUnaryExpressionRule()
						|| rule == grammarAccess.getSequenceAccessExpressionRule()
						|| action == grammarAccess.getSequenceAccessExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| action == grammarAccess.getPrimaryExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getBaseExpressionRule()) {
					sequence_AdditiveExpression_AndExpression_ClassExtentExpression_ClassificationExpression_ConditionalAndExpression_ConditionalExpression_ConditionalOrExpression_EqualityExpression_MultiplicativeExpression_NullCoalescingExpression_OrExpression_PrimaryExpression_RelationalExpression_SequenceAccessExpression_UnaryExpression_UnitsExpression_XorExpression(context, (OperatorExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getClassExtentExpressionRule()) {
					sequence_ClassExtentExpression(context, (OperatorExpression) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.PACKAGE:
				if (rule == grammarAccess.getAnonymousPackageRule()) {
					sequence_PackageBody(context, (org.omg.sysml.lang.sysml.Package) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPackageOrStubRule()) {
					sequence_Package_PackageBody(context, (org.omg.sysml.lang.sysml.Package) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnitRule()) {
					sequence_Package_PackageBody_UnitPrefix(context, (org.omg.sysml.lang.sysml.Package) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPackageUnitRule()) {
					sequence_Package_PackageBody_UnitPrefix(context, (org.omg.sysml.lang.sysml.Package) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.PARAMETER:
				if (rule == grammarAccess.getBodyParameterRule()) {
					sequence_BodyParameter_Typing(context, (org.omg.sysml.lang.sysml.Parameter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getParameterRule()) {
					sequence_MultiplicityPart_Typing(context, (org.omg.sysml.lang.sysml.Parameter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getActionParameterRule()) {
					sequence_MultiplicityPart_Typing_ValuePart(context, (org.omg.sysml.lang.sysml.Parameter) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.PARAMETER_MEMBERSHIP:
				if (rule == grammarAccess.getActionParameterMemberRule()) {
					sequence_ActionParameterMember(context, (ParameterMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBodyParameterMemberRule()) {
					sequence_BodyParameterMember(context, (ParameterMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getParameterMemberRule()) {
					sequence_ParameterMember(context, (ParameterMembership) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.PART_PROPERTY:
				if (rule == grammarAccess.getAbstractPartPropertyRule()) {
					sequence_AbstractDefinitionBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration_ValuePart(context, (PartProperty) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnitRule()) {
					sequence_DefinitionBody_MultiplicityPart_Part_Redefines_Subsets_SubsettingPart_Typing_UnitPrefix_ValuePart(context, (PartProperty) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPartUnitRule()) {
					sequence_DefinitionBody_MultiplicityPart_Part_Redefines_Subsets_SubsettingPart_Typing_UnitPrefix_ValuePart(context, (PartProperty) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPartPropertyRule()) {
					sequence_DefinitionBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration_ValuePart(context, (PartProperty) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.PERFORM_ACTION_USAGE:
				if (rule == grammarAccess.getActivityNodeRule()
						|| rule == grammarAccess.getPerformActionNodeRule()) {
					sequence_ActionParameterList_ActivityBody_MultiplicityPart_PerformActionNode_Redefines_Subsets_SubsettingPart_Typing_ValuePart(context, (PerformActionUsage) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPerformActionUsageRule()) {
					sequence_ActionParameterList_ActivityBody_MultiplicityPart_PerformActionUsage_Redefines_Subsets_SubsettingPart_Typing_ValuePart(context, (PerformActionUsage) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.PORT_DEFINITION:
				sequence_ClassifierDeclarationCompletion_DefinitionBody_PortDeclaration_SuperclassingList(context, (PortDefinition) semanticObject); 
				return; 
			case SysMLPackage.PORT_MEMBERSHIP:
				sequence_DefinitionMemberPrefix_PortMember(context, (PortMembership) semanticObject); 
				return; 
			case SysMLPackage.PORT_USAGE:
				if (rule == grammarAccess.getAbstractConjugatedPortUsageRule()) {
					sequence_AbstractDefinitionBody_ConjugatePortTyping_ConjugatePortUsageDeclaration_MultiplicityPart_Redefines_Subsets_SubsettingPart_ValuePart(context, (PortUsage) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAbstractPortUsageRule()) {
					sequence_AbstractDefinitionBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration_ValuePart(context, (PortUsage) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConjugatedPortUsageRule()) {
					sequence_ConjugatePortTyping_ConjugatePortUsageDeclaration_DefinitionBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_ValuePart(context, (PortUsage) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPortUsageRule()) {
					sequence_DefinitionBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration_ValuePart(context, (PortUsage) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.QUERY_PATH_EXPRESSION:
				sequence_QueryNameExpression(context, (QueryPathExpression) semanticObject); 
				return; 
			case SysMLPackage.QUERY_PATH_STEP_EXPRESSION:
				sequence_QueryPathExpression(context, (QueryPathStepExpression) semanticObject); 
				return; 
			case SysMLPackage.QUERY_QUALIFIER_EXPRESSION:
				sequence_QueryPathExpression(context, (QueryQualifierExpression) semanticObject); 
				return; 
			case SysMLPackage.REDEFINITION:
				sequence_Redefinition(context, (Redefinition) semanticObject); 
				return; 
			case SysMLPackage.REFERENCE_PROPERTY:
				if (rule == grammarAccess.getAbstractReferencePropertyRule()) {
					sequence_AbstractDefinitionBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration_ValuePart(context, (ReferenceProperty) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getReferencePropertyRule()) {
					sequence_DefinitionBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration_ValuePart(context, (ReferenceProperty) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.SEND_ACTION_USAGE:
				sequence_ActivityBody_MultiplicityPart_SendActionNode_Typing(context, (SendActionUsage) semanticObject); 
				return; 
			case SysMLPackage.SEQUENCE_CONSTRUCTION_EXPRESSION:
				sequence_SequenceConstructionExpression(context, (SequenceConstructionExpression) semanticObject); 
				return; 
			case SysMLPackage.SOURCE_END:
				if (rule == grammarAccess.getEmptySourceEndRule()) {
					sequence_EmptySourceEnd(context, (SourceEnd) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMultiplicitySourceEndRule()) {
					sequence_MultiplicitySourceEnd(context, (SourceEnd) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.SUBSETTING:
				sequence_Subset(context, (Subsetting) semanticObject); 
				return; 
			case SysMLPackage.SUCCESSION:
				if (rule == grammarAccess.getAbstractSuccessionRule()) {
					sequence_AbstractSuccession_MultiplicityPart_SuccessionDeclaration_Typing(context, (Succession) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEmptySuccessionRule()) {
					sequence_EmptySuccession(context, (Succession) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSuccessionRule()) {
					sequence_MultiplicityPart_SuccessionDeclaration_Typing(context, (Succession) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTargetSuccessionRule()) {
					sequence_TargetSuccession(context, (Succession) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.SUCCESSION_ITEM_FLOW:
				if (rule == grammarAccess.getAbstractSuccessionItemFlowRule()) {
					sequence_AbstractDefinitionBody_ItemFlowDeclaration_MultiplicityPart_Typing(context, (SuccessionItemFlow) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getActionParameterFlowRule()) {
					sequence_ActionParameterFlow(context, (SuccessionItemFlow) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSuccessionItemFlowRule()) {
					sequence_DefinitionBody_ItemFlowDeclaration_MultiplicityPart_Typing(context, (SuccessionItemFlow) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.SUPERCLASSING:
				sequence_Superclassing(context, (Superclassing) semanticObject); 
				return; 
			case SysMLPackage.TARGET_END:
				sequence_EmptyTargetEnd(context, (TargetEnd) semanticObject); 
				return; 
			case SysMLPackage.VALUE_PROPERTY:
				if (rule == grammarAccess.getAbstractValuePropertyRule()) {
					sequence_AbstractDefinitionBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration_ValuePart(context, (ValueProperty) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnitRule()) {
					sequence_DefinitionBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UnitPrefix_Value_ValuePart(context, (ValueProperty) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getValueUnitRule()) {
					sequence_DefinitionBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UnitPrefix_Value_ValuePart(context, (ValueProperty) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getValuePropertyRule()) {
					sequence_DefinitionBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration_ValuePart(context, (ValueProperty) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.VALUE_TYPE:
				if (rule == grammarAccess.getUnitRule()) {
					sequence_ClassifierDeclarationCompletion_DefinitionBody_SuperclassingList_UnitPrefix_ValueTypeDeclaration(context, (ValueType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getValueTypeUnitRule()) {
					sequence_ClassifierDeclarationCompletion_DefinitionBody_SuperclassingList_UnitPrefix_ValueTypeDeclaration(context, (ValueType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getValueTypeOrStubRule()) {
					sequence_ClassifierDeclarationCompletion_DefinitionBody_SuperclassingList_ValueTypeDeclaration(context, (ValueType) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AbstractActionUsage returns ActionUsage
	 *
	 * Constraint:
	 *     (
	 *         (name=Name | ownedRelationship+=Redefinition)? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         isOrdered?='ordered'? 
	 *         (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *         (
	 *             ownedRelationship+=ActionParameterMember 
	 *             ownedRelationship+=ActionParameterFlowMember? 
	 *             (ownedRelationship+=ActionParameterMember ownedRelationship+=ActionParameterFlowMember?)*
	 *         )? 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         ownedRelationship+=FeatureValue? 
	 *         (isAbstract?=';' | (isAbstract?='{' (ownedRelationship+=ActivityMember | ownedRelationship+=Import)*))
	 *     )
	 */
	protected void sequence_AbstractActivityBody_ActionDeclaration_ActionParameterList_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_ValuePart(ISerializationContext context, ActionUsage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractConnector returns ConnectionUsage
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (ownedRelationship+=ConnectorEndMember ownedRelationship+=ConnectorEndMember) | 
	 *             (ownedRelationship+=ConnectorEndMember ownedRelationship+=ConnectorEndMember ownedRelationship+=ConnectorEndMember*)
	 *         ) 
	 *         (isAbstract?=';' | (isAbstract?='{' (ownedRelationship+=AssociationMember | ownedRelationship+=Import)*))
	 *     )
	 */
	protected void sequence_AbstractAssociationBlockBody_ConnectionPart(ISerializationContext context, ConnectionUsage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractConnectionUsage returns ConnectionUsage
	 *
	 * Constraint:
	 *     (
	 *         (name=Name | ownedRelationship+=Redefinition)? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         isOrdered?='ordered'? 
	 *         (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         (
	 *             (ownedRelationship+=ConnectorEndMember ownedRelationship+=ConnectorEndMember) | 
	 *             (ownedRelationship+=ConnectorEndMember ownedRelationship+=ConnectorEndMember ownedRelationship+=ConnectorEndMember*)
	 *         ) 
	 *         (isAbstract?=';' | (isAbstract?='{' (ownedRelationship+=AssociationMember | ownedRelationship+=Import)*))
	 *     )
	 */
	protected void sequence_AbstractAssociationBlockBody_ConnectionPart_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration(ISerializationContext context, ConnectionUsage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractConjugatedPortUsage returns PortUsage
	 *
	 * Constraint:
	 *     (
	 *         (name=Name | ownedRelationship+=Redefinition)? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         isOrdered?='ordered'? 
	 *         (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         ownedRelationship+=FeatureValue? 
	 *         (isAbstract?=';' | (isAbstract?='{' (ownedRelationship+=DefinitionMember | ownedRelationship+=Import)*))
	 *     )
	 */
	protected void sequence_AbstractDefinitionBody_ConjugatePortTyping_ConjugatePortUsageDeclaration_MultiplicityPart_Redefines_Subsets_SubsettingPart_ValuePart(ISerializationContext context, PortUsage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractItemFlow returns ItemFlow
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 name=Name? 
	 *                 ownedRelationship+=FeatureTyping? 
	 *                 ownedRelationship+=Multiplicity? 
	 *                 isOrdered?='ordered'? 
	 *                 (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *                 (ownedRelationship+=ItemFeatureMember | ownedRelationship+=EmptyItemFeatureMember)
	 *             ) | 
	 *             ownedRelationship+=EmptyItemFeatureMember
	 *         ) 
	 *         ownedRelationship+=ItemFlowEndMember 
	 *         ownedRelationship+=ItemFlowEndMember 
	 *         (isAbstract?=';' | (isAbstract?='{' (ownedRelationship+=DefinitionMember | ownedRelationship+=Import)*))
	 *     )
	 */
	protected void sequence_AbstractDefinitionBody_ItemFlowDeclaration_MultiplicityPart_Typing(ISerializationContext context, ItemFlow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractSuccessionItemFlow returns SuccessionItemFlow
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 name=Name? 
	 *                 ownedRelationship+=FeatureTyping? 
	 *                 ownedRelationship+=Multiplicity? 
	 *                 isOrdered?='ordered'? 
	 *                 (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *                 (ownedRelationship+=ItemFeatureMember | ownedRelationship+=EmptyItemFeatureMember)
	 *             ) | 
	 *             ownedRelationship+=EmptyItemFeatureMember
	 *         ) 
	 *         ownedRelationship+=ItemFlowEndMember 
	 *         ownedRelationship+=ItemFlowEndMember 
	 *         (isAbstract?=';' | (isAbstract?='{' (ownedRelationship+=DefinitionMember | ownedRelationship+=Import)*))
	 *     )
	 */
	protected void sequence_AbstractDefinitionBody_ItemFlowDeclaration_MultiplicityPart_Typing(ISerializationContext context, SuccessionItemFlow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractPartProperty returns PartProperty
	 *
	 * Constraint:
	 *     (
	 *         (name=Name | ownedRelationship+=Redefinition)? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         isOrdered?='ordered'? 
	 *         (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         ownedRelationship+=FeatureValue? 
	 *         (isAbstract?=';' | (isAbstract?='{' (ownedRelationship+=DefinitionMember | ownedRelationship+=Import)*))
	 *     )
	 */
	protected void sequence_AbstractDefinitionBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration_ValuePart(ISerializationContext context, PartProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractPortUsage returns PortUsage
	 *
	 * Constraint:
	 *     (
	 *         (name=Name | ownedRelationship+=Redefinition)? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         isOrdered?='ordered'? 
	 *         (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         ownedRelationship+=FeatureValue? 
	 *         (isAbstract?=';' | (isAbstract?='{' (ownedRelationship+=DefinitionMember | ownedRelationship+=Import)*))
	 *     )
	 */
	protected void sequence_AbstractDefinitionBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration_ValuePart(ISerializationContext context, PortUsage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractReferenceProperty returns ReferenceProperty
	 *
	 * Constraint:
	 *     (
	 *         (name=Name | ownedRelationship+=Redefinition)? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         isOrdered?='ordered'? 
	 *         (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         ownedRelationship+=FeatureValue? 
	 *         (isAbstract?=';' | (isAbstract?='{' (ownedRelationship+=DefinitionMember | ownedRelationship+=Import)*))
	 *     )
	 */
	protected void sequence_AbstractDefinitionBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration_ValuePart(ISerializationContext context, ReferenceProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractValueProperty returns ValueProperty
	 *
	 * Constraint:
	 *     (
	 *         (name=Name | ownedRelationship+=Redefinition)? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         isOrdered?='ordered'? 
	 *         (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         ownedRelationship+=FeatureValue? 
	 *         (isAbstract?=';' | (isAbstract?='{' (ownedRelationship+=DefinitionMember | ownedRelationship+=Import)*))
	 *     )
	 */
	protected void sequence_AbstractDefinitionBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration_ValuePart(ISerializationContext context, ValueProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractInterfaceUsage returns InterfaceUsage
	 *
	 * Constraint:
	 *     (
	 *         (name=Name | ownedRelationship+=Redefinition)? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         isOrdered?='ordered'? 
	 *         (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         (
	 *             (ownedRelationship+=ConnectorEndMember ownedRelationship+=ConnectorEndMember) | 
	 *             (ownedRelationship+=ConnectorEndMember ownedRelationship+=ConnectorEndMember ownedRelationship+=ConnectorEndMember*)
	 *         ) 
	 *         (isAbstract?=';' | (isAbstract?='{' (ownedRelationship+=InterfaceMember | ownedRelationship+=Import)*))
	 *     )
	 */
	protected void sequence_AbstractInterfaceBody_ConnectionPart_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration(ISerializationContext context, InterfaceUsage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractSuccession returns Succession
	 *
	 * Constraint:
	 *     (
	 *         name=Name? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         (isOrdered?='ordered' | isNonunique?='nonunique')* 
	 *         ownedRelationship+=ConnectorEndMember 
	 *         ownedRelationship+=ConnectorEndMember 
	 *         isAbstract?=';'
	 *     )
	 */
	protected void sequence_AbstractSuccession_MultiplicityPart_SuccessionDeclaration_Typing(ISerializationContext context, Succession semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActivityNode returns AcceptActionUsage
	 *     AcceptActionNode returns AcceptActionUsage
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=EmptySuccessionMember? 
	 *         (name=Name ownedRelationship+=FeatureTyping? ownedRelationship+=Multiplicity? (isOrdered?='ordered' | isNonunique?='nonunique')*)? 
	 *         ownedRelationship+=ItemFeatureMember 
	 *         (ownedRelationship+=ActivityMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_AcceptActionNode_ActivityBody_MultiplicityPart_Typing(ISerializationContext context, AcceptActionUsage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActivityNode returns ActionUsage
	 *     ActionNode returns ActionUsage
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=EmptySuccessionMember? 
	 *         isAbstract?='abstract'? 
	 *         isComposite?='action'? 
	 *         (name=Name | ownedRelationship+=Redefinition)? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         isOrdered?='ordered'? 
	 *         (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *         (
	 *             ownedRelationship+=ActionParameterMember 
	 *             ownedRelationship+=ActionParameterFlowMember? 
	 *             (ownedRelationship+=ActionParameterMember ownedRelationship+=ActionParameterFlowMember?)*
	 *         )? 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         ownedRelationship+=FeatureValue? 
	 *         (ownedRelationship+=ActivityMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_ActionDeclaration_ActionNode_ActionParameterList_ActivityBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_ValuePart(ISerializationContext context, ActionUsage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActionUsage returns ActionUsage
	 *
	 * Constraint:
	 *     (
	 *         (name=Name | ownedRelationship+=Redefinition)? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         isOrdered?='ordered'? 
	 *         (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *         (
	 *             ownedRelationship+=ActionParameterMember 
	 *             ownedRelationship+=ActionParameterFlowMember? 
	 *             (ownedRelationship+=ActionParameterMember ownedRelationship+=ActionParameterFlowMember?)*
	 *         )? 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         ownedRelationship+=FeatureValue? 
	 *         ownedRelationship+=ActivityMember? 
	 *         (ownedRelationship+=Import? ownedRelationship+=ActivityMember?)*
	 *     )
	 */
	protected void sequence_ActionDeclaration_ActionParameterList_ActivityBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_ValuePart(ISerializationContext context, ActionUsage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActionMember returns FeatureMembership
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=PrefixAnnotation* 
	 *         visibility=VisibilityIndicator? 
	 *         (
	 *             (isComposite?='action'? ownedRelatedElement+=ActionUsage) | 
	 *             (isComposite?='action'? ownedRelatedElement+=AbstractActionUsage) | 
	 *             (memberName=Name? memberFeature=[ActionUsage|QualifiedName]) | 
	 *             (isComposite?='do'? ownedRelatedElement+=PerformActionUsage)
	 *         )
	 *     )
	 */
	protected void sequence_ActionMember_DefinitionMemberPrefix(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DefinitionMember returns FeatureMembership
	 *     NestedUsageMember returns FeatureMembership
	 *     AssociationMember returns FeatureMembership
	 *     InterfaceMember returns FeatureMembership
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=PrefixAnnotation* 
	 *         visibility=VisibilityIndicator? 
	 *         (
	 *             (isComposite?='part' ownedRelatedElement+=PartProperty) | 
	 *             (isComposite?='part' ownedRelatedElement+=AbstractPartProperty) | 
	 *             (isComposite?='part' memberName=Name? memberFeature=[PartProperty|QualifiedName]) | 
	 *             (direction=FeatureDirection? ownedRelatedElement+=ReferenceProperty) | 
	 *             (direction=FeatureDirection? ownedRelatedElement+=AbstractReferenceProperty) | 
	 *             (direction=FeatureDirection? memberName=Name? memberFeature=[ReferenceProperty|QualifiedName]) | 
	 *             (direction=FeatureDirection? ownedRelatedElement+=ValueProperty) | 
	 *             (direction=FeatureDirection? ownedRelatedElement+=AbstractValueProperty) | 
	 *             (direction=FeatureDirection? memberName=Name? memberFeature=[ValueProperty|QualifiedName]) | 
	 *             ownedRelatedElement+=InterfaceUsage | 
	 *             ownedRelatedElement+=AbstractInterfaceUsage | 
	 *             (memberName=Name? memberFeature=[InterfaceUsage|QualifiedName]) | 
	 *             ownedRelatedElement+=ConnectionUsage | 
	 *             ownedRelatedElement+=AbstractConnectionUsage | 
	 *             ownedRelatedElement+=Connector | 
	 *             ownedRelatedElement+=AbstractConnector | 
	 *             (memberName=Name? memberFeature=[ConnectionUsage|QualifiedName]) | 
	 *             ownedRelatedElement+=BindingConnector | 
	 *             ownedRelatedElement+=Succession | 
	 *             ownedRelatedElement+=AbstractSuccession | 
	 *             (memberName=Name? memberFeature=[Succession|QualifiedName]) | 
	 *             ownedRelatedElement+=ItemFlow | 
	 *             ownedRelatedElement+=AbstractItemFlow | 
	 *             (memberName=Name? memberFeature=[ItemFlow|QualifiedName]) | 
	 *             ownedRelatedElement+=SuccessionItemFlow | 
	 *             ownedRelatedElement+=AbstractSuccessionItemFlow | 
	 *             (memberName=Name? memberFeature=[SuccessionItemFlow|QualifiedName]) | 
	 *             (isComposite?='action'? ownedRelatedElement+=ActionUsage) | 
	 *             (isComposite?='action'? ownedRelatedElement+=AbstractActionUsage) | 
	 *             (memberName=Name? memberFeature=[ActionUsage|QualifiedName]) | 
	 *             (isComposite?='do'? ownedRelatedElement+=PerformActionUsage)
	 *         )
	 *     )
	 */
	protected void sequence_ActionMember_DefinitionMemberPrefix_PrimaryUsageMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActionParameterFlowMember returns FeatureMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=ActionParameterFlow
	 */
	protected void sequence_ActionParameterFlowMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActionParameterFlow returns ItemFlow
	 *
	 * Constraint:
	 *     (ownedRelationship+=EmptyItemFeatureMember ownedRelationship+=ItemFlowEndMember)
	 */
	protected void sequence_ActionParameterFlow(ISerializationContext context, ItemFlow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActionParameterFlow returns SuccessionItemFlow
	 *
	 * Constraint:
	 *     (ownedRelationship+=EmptyItemFeatureMember ownedRelationship+=ItemFlowEndMember)
	 */
	protected void sequence_ActionParameterFlow(ISerializationContext context, SuccessionItemFlow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActivityNode returns PerformActionUsage
	 *     PerformActionNode returns PerformActionUsage
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=EmptySuccessionMember? 
	 *         isComposite?='do'? 
	 *         (name=Name ownedRelationship+=FeatureTyping? ownedRelationship+=Multiplicity? (isOrdered?='ordered' | isNonunique?='nonunique')*)? 
	 *         ownedRelationship+=Subset 
	 *         (
	 *             ownedRelationship+=ActionParameterMember 
	 *             ownedRelationship+=ActionParameterFlowMember? 
	 *             (ownedRelationship+=ActionParameterMember ownedRelationship+=ActionParameterFlowMember?)*
	 *         )? 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         ownedRelationship+=FeatureValue? 
	 *         (ownedRelationship+=ActivityMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_ActionParameterList_ActivityBody_MultiplicityPart_PerformActionNode_Redefines_Subsets_SubsettingPart_Typing_ValuePart(ISerializationContext context, PerformActionUsage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PerformActionUsage returns PerformActionUsage
	 *
	 * Constraint:
	 *     (
	 *         (name=Name ownedRelationship+=FeatureTyping? ownedRelationship+=Multiplicity? (isOrdered?='ordered' | isNonunique?='nonunique')*)? 
	 *         ownedRelationship+=Subset 
	 *         (
	 *             ownedRelationship+=ActionParameterMember 
	 *             ownedRelationship+=ActionParameterFlowMember? 
	 *             (ownedRelationship+=ActionParameterMember ownedRelationship+=ActionParameterFlowMember?)*
	 *         )? 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         ownedRelationship+=FeatureValue? 
	 *         (ownedRelationship+=ActivityMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_ActionParameterList_ActivityBody_MultiplicityPart_PerformActionUsage_Redefines_Subsets_SubsettingPart_Typing_ValuePart(ISerializationContext context, PerformActionUsage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActionParameterMember returns ParameterMembership
	 *
	 * Constraint:
	 *     (direction=FeatureDirection? memberName=Name? ownedRelatedElement+=ActionParameter)
	 */
	protected void sequence_ActionParameterMember(ISerializationContext context, ParameterMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns ActionUsage
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=PrefixAnnotation? 
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         isOrdered?='ordered'? 
	 *         (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *         (
	 *             ownedRelationship+=ActionParameterMember 
	 *             ownedRelationship+=ActionParameterFlowMember? 
	 *             (ownedRelationship+=ActionParameterMember ownedRelationship+=ActionParameterFlowMember?)*
	 *         )? 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         ownedRelationship+=FeatureValue? 
	 *         (ownedRelationship+=ActivityMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_Action_ActionParameterList_ActivityBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UnitPrefix_ValuePart(ISerializationContext context, ActionUsage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     ActionUnit returns ActionUsage
	//
	// Constraint:
	//     (
	//         ownedRelationship+=PrefixAnnotation* 
	//         isAbstract?='abstract'? 
	//         name=Name 
	//         ownedRelationship+=FeatureTyping? 
	//         ownedRelationship+=Multiplicity? 
	//         (isOrdered?='ordered' | isNonunique?='nonunique')* 
	//         (
	//             ownedRelationship+=ActionParameterMember 
	//             ownedRelationship+=ActionParameterFlowMember? 
	//             (ownedRelationship+=ActionParameterMember ownedRelationship+=ActionParameterFlowMember?)*
	//         )? 
	//         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	//         ownedRelationship+=FeatureValue? 
	//         ownedRelationship+=ActivityMember? 
	//         (ownedRelationship+=Import? ownedRelationship+=ActivityMember?)*
	//     )
	//
	// protected void sequence_Action_ActionParameterList_ActivityBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UnitPrefix_ValuePart(ISerializationContext context, ActionUsage semanticObject) { }
	
	/**
	 * Contexts:
	 *     ActivityOrStub returns Activity
	 *
	 * Constraint:
	 *     (
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedRelationship+=ParameterMember ownedRelationship+=ParameterMember*)? 
	 *         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	 *         (ownedRelationship+=ActivityMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_ActivityBody_ActivityDeclaration_ParameterList_SuperclassingList(ISerializationContext context, Activity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns Activity
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=PrefixAnnotation? 
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedRelationship+=ParameterMember ownedRelationship+=ParameterMember*)? 
	 *         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	 *         (ownedRelationship+=ActivityMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_ActivityBody_ActivityDeclaration_ParameterList_SuperclassingList_UnitPrefix(ISerializationContext context, Activity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     ActivityUnit returns Activity
	//
	// Constraint:
	//     (
	//         ownedRelationship+=PrefixAnnotation* 
	//         isAbstract?='abstract'? 
	//         name=Name 
	//         (ownedRelationship+=ParameterMember ownedRelationship+=ParameterMember*)? 
	//         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	//         (ownedRelationship+=ActivityMember | ownedRelationship+=Import)*
	//     )
	//
	// protected void sequence_ActivityBody_ActivityDeclaration_ParameterList_SuperclassingList_UnitPrefix(ISerializationContext context, Activity semanticObject) { }
	
	/**
	 * Contexts:
	 *     ActivityNode returns SendActionUsage
	 *     SendActionNode returns SendActionUsage
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=EmptySuccessionMember? 
	 *         (name=Name ownedRelationship+=FeatureTyping? ownedRelationship+=Multiplicity? (isOrdered?='ordered' | isNonunique?='nonunique')*)? 
	 *         ownedRelationship+=ExpressionMember 
	 *         ownedRelationship+=ExpressionMember 
	 *         (ownedRelationship+=ActivityMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_ActivityBody_MultiplicityPart_SendActionNode_Typing(ISerializationContext context, SendActionUsage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActivityNodeMember returns FeatureMembership
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=PrefixAnnotation* 
	 *         visibility=VisibilityIndicator? 
	 *         (ownedRelatedElement+=ActivityNode | memberFeature=[Feature|QualifiedName] | ownedRelatedElement+=TargetSuccession)
	 *     )
	 */
	protected void sequence_ActivityNodeMember_DefinitionMemberPrefix(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActivityMember returns FeatureMembership
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=PrefixAnnotation* 
	 *         visibility=VisibilityIndicator? 
	 *         (
	 *             (isComposite?='part' ownedRelatedElement+=PartProperty) | 
	 *             (isComposite?='part' ownedRelatedElement+=AbstractPartProperty) | 
	 *             (isComposite?='part' memberName=Name? memberFeature=[PartProperty|QualifiedName]) | 
	 *             (direction=FeatureDirection? ownedRelatedElement+=ReferenceProperty) | 
	 *             (direction=FeatureDirection? ownedRelatedElement+=AbstractReferenceProperty) | 
	 *             (direction=FeatureDirection? memberName=Name? memberFeature=[ReferenceProperty|QualifiedName]) | 
	 *             (direction=FeatureDirection? ownedRelatedElement+=ValueProperty) | 
	 *             (direction=FeatureDirection? ownedRelatedElement+=AbstractValueProperty) | 
	 *             (direction=FeatureDirection? memberName=Name? memberFeature=[ValueProperty|QualifiedName]) | 
	 *             ownedRelatedElement+=InterfaceUsage | 
	 *             ownedRelatedElement+=AbstractInterfaceUsage | 
	 *             (memberName=Name? memberFeature=[InterfaceUsage|QualifiedName]) | 
	 *             ownedRelatedElement+=ConnectionUsage | 
	 *             ownedRelatedElement+=AbstractConnectionUsage | 
	 *             ownedRelatedElement+=Connector | 
	 *             ownedRelatedElement+=AbstractConnector | 
	 *             (memberName=Name? memberFeature=[ConnectionUsage|QualifiedName]) | 
	 *             ownedRelatedElement+=BindingConnector | 
	 *             ownedRelatedElement+=Succession | 
	 *             ownedRelatedElement+=AbstractSuccession | 
	 *             (memberName=Name? memberFeature=[Succession|QualifiedName]) | 
	 *             ownedRelatedElement+=ItemFlow | 
	 *             ownedRelatedElement+=AbstractItemFlow | 
	 *             (memberName=Name? memberFeature=[ItemFlow|QualifiedName]) | 
	 *             ownedRelatedElement+=SuccessionItemFlow | 
	 *             ownedRelatedElement+=AbstractSuccessionItemFlow | 
	 *             (memberName=Name? memberFeature=[SuccessionItemFlow|QualifiedName]) | 
	 *             ownedRelatedElement+=ActivityNode | 
	 *             memberFeature=[Feature|QualifiedName] | 
	 *             ownedRelatedElement+=TargetSuccession
	 *         )
	 *     )
	 */
	protected void sequence_ActivityNodeMember_DefinitionMemberPrefix_PrimaryUsageMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns OperatorExpression
	 *     ConditionalExpression returns OperatorExpression
	 *     ConditionalExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     NullCoalescingExpression returns OperatorExpression
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     ConditionalOrExpression returns OperatorExpression
	 *     ConditionalOrExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     ConditionalAndExpression returns OperatorExpression
	 *     ConditionalAndExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     OrExpression returns OperatorExpression
	 *     OrExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     XorExpression returns OperatorExpression
	 *     XorExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     AndExpression returns OperatorExpression
	 *     AndExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     EqualityExpression returns OperatorExpression
	 *     EqualityExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     ClassificationExpression returns OperatorExpression
	 *     ClassificationExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     RelationalExpression returns OperatorExpression
	 *     RelationalExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     AdditiveExpression returns OperatorExpression
	 *     AdditiveExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     MultiplicativeExpression returns OperatorExpression
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     UnitsExpression returns OperatorExpression
	 *     UnitsExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     UnaryExpression returns OperatorExpression
	 *     SequenceAccessExpression returns OperatorExpression
	 *     SequenceAccessExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     PrimaryExpression returns OperatorExpression
	 *     PrimaryExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     BaseExpression returns OperatorExpression
	 *
	 * Constraint:
	 *     (
	 *         (operand+=ConditionalExpression_OperatorExpression_1_0 operator=ConditionalTestOperator operand+=Expression operand+=ConditionalExpression) | 
	 *         (operand+=NullCoalescingExpression_OperatorExpression_1_0 operator=NullCoalescingOperator operand+=ConditionalOrExpression) | 
	 *         (operand+=ConditionalOrExpression_OperatorExpression_1_0 operator=ConditionalOrOperator operand+=ConditionalAndExpression) | 
	 *         (operand+=ConditionalAndExpression_OperatorExpression_1_0 operator=ConditionalAndOperator operand+=OrExpression) | 
	 *         (operand+=OrExpression_OperatorExpression_1_0 operator=OrOperator operand+=XorExpression) | 
	 *         (operand+=XorExpression_OperatorExpression_1_0 operator=XorOperator operand+=AndExpression) | 
	 *         (operand+=AndExpression_OperatorExpression_1_0 operator=AndOperator operand+=EqualityExpression) | 
	 *         (operand+=EqualityExpression_OperatorExpression_1_0 operator=EqualityOperator operand+=ClassificationExpression) | 
	 *         (operand+=ClassificationExpression_OperatorExpression_1_0 operator=ClassificationOperator ownedRelationship+=TypeReferenceMember) | 
	 *         (operand+=RelationalExpression_OperatorExpression_1_0 operator=RelationalOperator operand+=AdditiveExpression) | 
	 *         (operand+=AdditiveExpression_OperatorExpression_1_0 operator=AdditiveOperator operand+=MultiplicativeExpression) | 
	 *         (operand+=MultiplicativeExpression_OperatorExpression_1_0 operator=MultiplicativeOperator operand+=UnitsExpression) | 
	 *         (operand+=UnitsExpression_OperatorExpression_1_0 operator='@' operand+=Expression) | 
	 *         (operator=UnaryOperator operand+=SequenceAccessExpression) | 
	 *         (operand+=SequenceAccessExpression_OperatorExpression_1_0 operator='[' operand+=Expression) | 
	 *         (operand+=PrimaryExpression_OperatorExpression_1_0 operator=Name ownedRelationship+=BodyMember+) | 
	 *         (ownedRelationship+=TypeReferenceMember operator='allInstances')
	 *     )
	 */
	protected void sequence_AdditiveExpression_AndExpression_ClassExtentExpression_ClassificationExpression_ConditionalAndExpression_ConditionalExpression_ConditionalOrExpression_EqualityExpression_MultiplicativeExpression_NullCoalescingExpression_OrExpression_PrimaryExpression_RelationalExpression_SequenceAccessExpression_UnaryExpression_UnitsExpression_XorExpression(ISerializationContext context, OperatorExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Annotation returns Annotation
	 *
	 * Constraint:
	 *     annotatedElement=[Element|QualifiedName]?
	 */
	protected void sequence_Annotation(ISerializationContext context, Annotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssociationBlockOrStub returns AssociationBlock
	 *
	 * Constraint:
	 *     (
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	 *         (ownedRelationship+=AssociationMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_AssociationBlockBody_AssociationBlockDeclaration_ClassifierDeclarationCompletion_SuperclassingList(ISerializationContext context, AssociationBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns AssociationBlock
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=PrefixAnnotation? 
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	 *         (ownedRelationship+=AssociationMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_AssociationBlockBody_AssociationBlockDeclaration_ClassifierDeclarationCompletion_SuperclassingList_UnitPrefix(ISerializationContext context, AssociationBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     AssociationBlockUnit returns AssociationBlock
	//
	// Constraint:
	//     (
	//         ownedRelationship+=PrefixAnnotation* 
	//         isAbstract?='abstract'? 
	//         name=Name 
	//         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	//         (ownedRelationship+=AssociationMember | ownedRelationship+=Import)*
	//     )
	//
	// protected void sequence_AssociationBlockBody_AssociationBlockDeclaration_ClassifierDeclarationCompletion_SuperclassingList_UnitPrefix(ISerializationContext context, AssociationBlock semanticObject) { }
	
	/**
	 * Contexts:
	 *     Connector returns ConnectionUsage
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (ownedRelationship+=ConnectorEndMember ownedRelationship+=ConnectorEndMember) | 
	 *             (ownedRelationship+=ConnectorEndMember ownedRelationship+=ConnectorEndMember ownedRelationship+=ConnectorEndMember*)
	 *         ) 
	 *         (ownedRelationship+=AssociationMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_AssociationBlockBody_ConnectionPart(ISerializationContext context, ConnectionUsage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConnectionUsage returns ConnectionUsage
	 *
	 * Constraint:
	 *     (
	 *         (name=Name | ownedRelationship+=Redefinition)? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         isOrdered?='ordered'? 
	 *         (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         (
	 *             (ownedRelationship+=ConnectorEndMember ownedRelationship+=ConnectorEndMember) | 
	 *             (ownedRelationship+=ConnectorEndMember ownedRelationship+=ConnectorEndMember ownedRelationship+=ConnectorEndMember*)
	 *         ) 
	 *         (ownedRelationship+=AssociationMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_AssociationBlockBody_ConnectionPart_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration(ISerializationContext context, ConnectionUsage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssociationMember returns EndFeatureMembership
	 *     AssociationEndMember returns EndFeatureMembership
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=PrefixAnnotation* 
	 *         visibility=VisibilityIndicator? 
	 *         (
	 *             (isComposite?='part' ownedRelatedElement+=PartProperty) | 
	 *             (isComposite?='part' ownedRelatedElement+=AbstractPartProperty) | 
	 *             (isComposite?='part' memberName=Name? memberFeature=[PartProperty|QualifiedName]) | 
	 *             ownedRelatedElement+=ReferenceProperty | 
	 *             ownedRelatedElement+=AbstractReferenceProperty | 
	 *             (memberName=Name? memberFeature=[ReferenceProperty|QualifiedName]) | 
	 *             (isComposite?='action'? ownedRelatedElement+=ActionUsage) | 
	 *             (isComposite?='action'? ownedRelatedElement+=AbstractActionUsage) | 
	 *             (memberName=Name? memberFeature=[ActionUsage|QualifiedName]) | 
	 *             (isPort?='port' ownedRelatedElement+=PortUsage) | 
	 *             (isPort?='port' ownedRelatedElement+=AbstractPortUsage) | 
	 *             (isPort?='port' memberName=Name? memberFeature=[PortUsage|QualifiedName])
	 *         )
	 *     )
	 */
	protected void sequence_AssociationEndMember_DefinitionMemberPrefix(ISerializationContext context, EndFeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BindingConnector returns BindingConnector
	 *
	 * Constraint:
	 *     (
	 *         name=Name? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         (isOrdered?='ordered' | isNonunique?='nonunique')* 
	 *         ownedRelationship+=ConnectorEndMember 
	 *         ownedRelationship+=ConnectorEndMember 
	 *         (ownedRelationship+=DefinitionMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_BindingConnector_DefinitionBody_MultiplicityPart_Typing(ISerializationContext context, BindingConnector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockOrStub returns Block
	 *
	 * Constraint:
	 *     (
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	 *         (ownedRelationship+=DefinitionMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_BlockDeclaration_ClassifierDeclarationCompletion_DefinitionBody_SuperclassingList(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns Block
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=PrefixAnnotation? 
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	 *         (ownedRelationship+=DefinitionMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_BlockDeclaration_ClassifierDeclarationCompletion_DefinitionBody_SuperclassingList_UnitPrefix(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     BlockUnit returns Block
	//
	// Constraint:
	//     (
	//         ownedRelationship+=PrefixAnnotation* 
	//         isAbstract?='abstract'? 
	//         name=Name 
	//         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	//         (ownedRelationship+=DefinitionMember | ownedRelationship+=Import)*
	//     )
	//
	// protected void sequence_BlockDeclaration_ClassifierDeclarationCompletion_DefinitionBody_SuperclassingList_UnitPrefix(ISerializationContext context, Block semanticObject) { }
	
	/**
	 * Contexts:
	 *     BodyExpression returns BlockExpression
	 *
	 * Constraint:
	 *     (
	 *         (ownedRelationship+=BodyParameterMember ownedRelationship+=BodyParameterMember* ownedRelationship+=ExpressionMember) | 
	 *         ownedRelationship+=ExpressionTyping
	 *     )
	 */
	protected void sequence_BodyExpression(ISerializationContext context, BlockExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BodyMember returns FeatureMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=BodyExpression
	 */
	protected void sequence_BodyMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BodyParameterMember returns ParameterMembership
	 *
	 * Constraint:
	 *     (memberName=Name ownedRelatedElement+=BodyParameter)
	 */
	protected void sequence_BodyParameterMember(ISerializationContext context, ParameterMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BodyParameter returns Parameter
	 *
	 * Constraint:
	 *     ownedRelationship+=FeatureTyping?
	 */
	protected void sequence_BodyParameter_Typing(ISerializationContext context, org.omg.sysml.lang.sysml.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralBoolean
	 *     ConditionalExpression returns LiteralBoolean
	 *     ConditionalExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     NullCoalescingExpression returns LiteralBoolean
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     ConditionalOrExpression returns LiteralBoolean
	 *     ConditionalOrExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     ConditionalAndExpression returns LiteralBoolean
	 *     ConditionalAndExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     OrExpression returns LiteralBoolean
	 *     OrExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     XorExpression returns LiteralBoolean
	 *     XorExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     AndExpression returns LiteralBoolean
	 *     AndExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     EqualityExpression returns LiteralBoolean
	 *     EqualityExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     ClassificationExpression returns LiteralBoolean
	 *     ClassificationExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     RelationalExpression returns LiteralBoolean
	 *     RelationalExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     AdditiveExpression returns LiteralBoolean
	 *     AdditiveExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     MultiplicativeExpression returns LiteralBoolean
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     UnitsExpression returns LiteralBoolean
	 *     UnitsExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     UnaryExpression returns LiteralBoolean
	 *     SequenceAccessExpression returns LiteralBoolean
	 *     SequenceAccessExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     PrimaryExpression returns LiteralBoolean
	 *     PrimaryExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     BaseExpression returns LiteralBoolean
	 *     LiteralExpression returns LiteralBoolean
	 *     BooleanLiteralExpression returns LiteralBoolean
	 *
	 * Constraint:
	 *     value=BOOLEAN_VALUE
	 */
	protected void sequence_BooleanLiteralExpression(ISerializationContext context, LiteralBoolean semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.LITERAL_BOOLEAN__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.LITERAL_BOOLEAN__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanLiteralExpressionAccess().getValueBOOLEAN_VALUETerminalRuleCall_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassExtentExpression returns OperatorExpression
	 *
	 * Constraint:
	 *     (ownedRelationship+=TypeReferenceMember operator='allInstances')
	 */
	protected void sequence_ClassExtentExpression(ISerializationContext context, OperatorExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PortDefinitionOrStub returns PortDefinition
	 *
	 * Constraint:
	 *     (
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	 *         (ownedRelationship+=DefinitionMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_ClassifierDeclarationCompletion_DefinitionBody_PortDeclaration_SuperclassingList(ISerializationContext context, PortDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns ValueType
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=PrefixAnnotation? 
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	 *         (ownedRelationship+=DefinitionMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_ClassifierDeclarationCompletion_DefinitionBody_SuperclassingList_UnitPrefix_ValueTypeDeclaration(ISerializationContext context, ValueType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     ValueTypeUnit returns ValueType
	//
	// Constraint:
	//     (
	//         ownedRelationship+=PrefixAnnotation* 
	//         isAbstract?='abstract'? 
	//         name=Name 
	//         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	//         (ownedRelationship+=DefinitionMember | ownedRelationship+=Import)*
	//     )
	//
	// protected void sequence_ClassifierDeclarationCompletion_DefinitionBody_SuperclassingList_UnitPrefix_ValueTypeDeclaration(ISerializationContext context, ValueType semanticObject) { }
	
	/**
	 * Contexts:
	 *     ValueTypeOrStub returns ValueType
	 *
	 * Constraint:
	 *     (
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	 *         (ownedRelationship+=DefinitionMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_ClassifierDeclarationCompletion_DefinitionBody_SuperclassingList_ValueTypeDeclaration(ISerializationContext context, ValueType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InterfaceDefinitionOrStub returns InterfaceDefinition
	 *
	 * Constraint:
	 *     (
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	 *         (ownedRelationship+=InterfaceMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_ClassifierDeclarationCompletion_InterfaceBody_InterfaceDeclaration_SuperclassingList(ISerializationContext context, InterfaceDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns InterfaceDefinition
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=PrefixAnnotation? 
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	 *         (ownedRelationship+=InterfaceMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_ClassifierDeclarationCompletion_InterfaceBody_InterfaceDeclaration_SuperclassingList_UnitPrefix(ISerializationContext context, InterfaceDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     InterfaceDefinitionUnit returns InterfaceDefinition
	//
	// Constraint:
	//     (
	//         ownedRelationship+=PrefixAnnotation* 
	//         isAbstract?='abstract'? 
	//         name=Name 
	//         (ownedRelationship+=Superclassing ownedRelationship+=Superclassing*)? 
	//         (ownedRelationship+=InterfaceMember | ownedRelationship+=Import)*
	//     )
	//
	// protected void sequence_ClassifierDeclarationCompletion_InterfaceBody_InterfaceDeclaration_SuperclassingList_UnitPrefix(ISerializationContext context, InterfaceDefinition semanticObject) { }
	
	/**
	 * Contexts:
	 *     Comment returns Comment
	 *
	 * Constraint:
	 *     (((name=Name? ownedRelationship+=Annotation) | ownedRelationship+=EmptyAnnotation) body=ML_COMMENT)
	 */
	protected void sequence_Comment(ISerializationContext context, Comment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionalSuccessionMember returns FeatureMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=ConditionalSuccession
	 */
	protected void sequence_ConditionalSuccessionMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionalSuccession returns ConditionalSuccession
	 *
	 * Constraint:
	 *     (ownedRelationship+=ExpressionMember ownedRelationship+=EmptySourceEndMember ownedRelationship+=ConnectorEndMember)
	 */
	protected void sequence_ConditionalSuccession(ISerializationContext context, ConditionalSuccession semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConjugatedPortUsage returns PortUsage
	 *
	 * Constraint:
	 *     (
	 *         (name=Name | ownedRelationship+=Redefinition)? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         isOrdered?='ordered'? 
	 *         (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         ownedRelationship+=FeatureValue? 
	 *         ownedRelationship+=DefinitionMember? 
	 *         (ownedRelationship+=Import? ownedRelationship+=DefinitionMember?)*
	 *     )
	 */
	protected void sequence_ConjugatePortTyping_ConjugatePortUsageDeclaration_DefinitionBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_ValuePart(ISerializationContext context, PortUsage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DefinitionMember returns ConjugatedPortMembership
	 *     NestedUsageMember returns ConjugatedPortMembership
	 *     ConjugatedPortMember returns ConjugatedPortMembership
	 *     AssociationMember returns ConjugatedPortMembership
	 *     InterfaceMember returns ConjugatedPortMembership
	 *     ActivityMember returns ConjugatedPortMembership
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=PrefixAnnotation* 
	 *         visibility=VisibilityIndicator? 
	 *         ((isPort?='port' ownedRelatedElement+=ConjugatedPortUsage) | (isPort?='port' ownedRelatedElement+=AbstractConjugatedPortUsage))
	 *     )
	 */
	protected void sequence_ConjugatedPortMember_DefinitionMemberPrefix(ISerializationContext context, ConjugatedPortMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InterfaceUsage returns InterfaceUsage
	 *
	 * Constraint:
	 *     (
	 *         (name=Name | ownedRelationship+=Redefinition)? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         isOrdered?='ordered'? 
	 *         (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         (
	 *             (ownedRelationship+=ConnectorEndMember ownedRelationship+=ConnectorEndMember) | 
	 *             (ownedRelationship+=ConnectorEndMember ownedRelationship+=ConnectorEndMember ownedRelationship+=ConnectorEndMember*)
	 *         ) 
	 *         (ownedRelationship+=InterfaceMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_ConnectionPart_InterfaceBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration(ISerializationContext context, InterfaceUsage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConnectorEndMember returns EndFeatureMembership
	 *
	 * Constraint:
	 *     (memberName=Name? ownedRelatedElement+=ConnectorEnd)
	 */
	protected void sequence_ConnectorEndMember(ISerializationContext context, EndFeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConnectorEnd returns Feature
	 *
	 * Constraint:
	 *     (ownedRelationship+=Subset ownedRelationship+=Multiplicity?)
	 */
	protected void sequence_ConnectorEnd(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActivityNode returns DecisionNode
	 *     ControlNode returns DecisionNode
	 *     DecisionNode returns DecisionNode
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=EmptySuccessionMember? 
	 *         (name=Name ownedRelationship+=FeatureTyping? ownedRelationship+=Multiplicity? (isOrdered?='ordered' | isNonunique?='nonunique')*)? 
	 *         (ownedRelationship+=ConditionalSuccessionMember ownedRelationship+=ConditionalSuccessionMember* ownedRelationship+=DefaultSuccessionMember?)?
	 *     )
	 */
	protected void sequence_DecisionNode_MultiplicityPart_Typing(ISerializationContext context, DecisionNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DefaultSuccessionMember returns FeatureMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=DefaultSuccession
	 */
	protected void sequence_DefaultSuccessionMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DefaultSuccession returns ConditionalSuccession
	 *
	 * Constraint:
	 *     (ownedRelationship+=EmptySourceEndMember ownedRelationship+=ConnectorEndMember)
	 */
	protected void sequence_DefaultSuccession(ISerializationContext context, ConditionalSuccession semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ItemFlow returns ItemFlow
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 name=Name? 
	 *                 ownedRelationship+=FeatureTyping? 
	 *                 ownedRelationship+=Multiplicity? 
	 *                 isOrdered?='ordered'? 
	 *                 (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *                 (ownedRelationship+=ItemFeatureMember | ownedRelationship+=EmptyItemFeatureMember)
	 *             ) | 
	 *             ownedRelationship+=EmptyItemFeatureMember
	 *         ) 
	 *         ownedRelationship+=ItemFlowEndMember 
	 *         ownedRelationship+=ItemFlowEndMember 
	 *         (ownedRelationship+=DefinitionMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_DefinitionBody_ItemFlowDeclaration_MultiplicityPart_Typing(ISerializationContext context, ItemFlow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SuccessionItemFlow returns SuccessionItemFlow
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 name=Name? 
	 *                 ownedRelationship+=FeatureTyping? 
	 *                 ownedRelationship+=Multiplicity? 
	 *                 isOrdered?='ordered'? 
	 *                 (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *                 (ownedRelationship+=ItemFeatureMember | ownedRelationship+=EmptyItemFeatureMember)
	 *             ) | 
	 *             ownedRelationship+=EmptyItemFeatureMember
	 *         ) 
	 *         ownedRelationship+=ItemFlowEndMember 
	 *         ownedRelationship+=ItemFlowEndMember 
	 *         (ownedRelationship+=DefinitionMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_DefinitionBody_ItemFlowDeclaration_MultiplicityPart_Typing(ISerializationContext context, SuccessionItemFlow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns PartProperty
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=PrefixAnnotation? 
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         isOrdered?='ordered'? 
	 *         (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         ownedRelationship+=FeatureValue? 
	 *         (ownedRelationship+=DefinitionMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_DefinitionBody_MultiplicityPart_Part_Redefines_Subsets_SubsettingPart_Typing_UnitPrefix_ValuePart(ISerializationContext context, PartProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     PartUnit returns PartProperty
	//
	// Constraint:
	//     (
	//         ownedRelationship+=PrefixAnnotation* 
	//         isAbstract?='abstract'? 
	//         name=Name 
	//         ownedRelationship+=FeatureTyping? 
	//         ownedRelationship+=Multiplicity? 
	//         (isOrdered?='ordered' | isNonunique?='nonunique')* 
	//         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	//         ownedRelationship+=FeatureValue? 
	//         ownedRelationship+=DefinitionMember? 
	//         (ownedRelationship+=Import? ownedRelationship+=DefinitionMember?)*
	//     )
	//
	// protected void sequence_DefinitionBody_MultiplicityPart_Part_Redefines_Subsets_SubsettingPart_Typing_UnitPrefix_ValuePart(ISerializationContext context, PartProperty semanticObject) { }
	
	/**
	 * Contexts:
	 *     Unit returns ValueProperty
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=PrefixAnnotation? 
	 *         isAbstract?='abstract'? 
	 *         name=Name 
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         isOrdered?='ordered'? 
	 *         (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         ownedRelationship+=FeatureValue? 
	 *         (ownedRelationship+=DefinitionMember | ownedRelationship+=Import)*
	 *     )
	 */
	protected void sequence_DefinitionBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UnitPrefix_Value_ValuePart(ISerializationContext context, ValueProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     ValueUnit returns ValueProperty
	//
	// Constraint:
	//     (
	//         ownedRelationship+=PrefixAnnotation* 
	//         isAbstract?='abstract'? 
	//         name=Name 
	//         ownedRelationship+=FeatureTyping? 
	//         ownedRelationship+=Multiplicity? 
	//         (isOrdered?='ordered' | isNonunique?='nonunique')* 
	//         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	//         ownedRelationship+=FeatureValue? 
	//         ownedRelationship+=DefinitionMember? 
	//         (ownedRelationship+=Import? ownedRelationship+=DefinitionMember?)*
	//     )
	//
	// protected void sequence_DefinitionBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UnitPrefix_Value_ValuePart(ISerializationContext context, ValueProperty semanticObject) { }
	
	/**
	 * Contexts:
	 *     PartProperty returns PartProperty
	 *
	 * Constraint:
	 *     (
	 *         (name=Name | ownedRelationship+=Redefinition)? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         isOrdered?='ordered'? 
	 *         (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         ownedRelationship+=FeatureValue? 
	 *         ownedRelationship+=DefinitionMember? 
	 *         (ownedRelationship+=Import? ownedRelationship+=DefinitionMember?)*
	 *     )
	 */
	protected void sequence_DefinitionBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration_ValuePart(ISerializationContext context, PartProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PortUsage returns PortUsage
	 *
	 * Constraint:
	 *     (
	 *         (name=Name | ownedRelationship+=Redefinition)? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         isOrdered?='ordered'? 
	 *         (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         ownedRelationship+=FeatureValue? 
	 *         ownedRelationship+=DefinitionMember? 
	 *         (ownedRelationship+=Import? ownedRelationship+=DefinitionMember?)*
	 *     )
	 */
	protected void sequence_DefinitionBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration_ValuePart(ISerializationContext context, PortUsage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReferenceProperty returns ReferenceProperty
	 *
	 * Constraint:
	 *     (
	 *         (name=Name | ownedRelationship+=Redefinition)? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         isOrdered?='ordered'? 
	 *         (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         ownedRelationship+=FeatureValue? 
	 *         ownedRelationship+=DefinitionMember? 
	 *         (ownedRelationship+=Import? ownedRelationship+=DefinitionMember?)*
	 *     )
	 */
	protected void sequence_DefinitionBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration_ValuePart(ISerializationContext context, ReferenceProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueProperty returns ValueProperty
	 *
	 * Constraint:
	 *     (
	 *         (name=Name | ownedRelationship+=Redefinition)? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         isOrdered?='ordered'? 
	 *         (isNonunique?='nonunique'? isOrdered?='ordered'?)* 
	 *         ((ownedRelationship+=Subset ownedRelationship+=Subset*) | (ownedRelationship+=Redefinition ownedRelationship+=Redefinition*))* 
	 *         ownedRelationship+=FeatureValue? 
	 *         ownedRelationship+=DefinitionMember? 
	 *         (ownedRelationship+=Import? ownedRelationship+=DefinitionMember?)*
	 *     )
	 */
	protected void sequence_DefinitionBody_MultiplicityPart_Redefines_Subsets_SubsettingPart_Typing_UsageDeclaration_ValuePart(ISerializationContext context, ValueProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InterfaceMember returns EndFeatureMembership
	 *     InterfaceEndMember returns EndFeatureMembership
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=PrefixAnnotation* 
	 *         visibility=VisibilityIndicator? 
	 *         (
	 *             (isPort?='end' direction=FeatureDirection? ownedRelatedElement+=PortUsage) | 
	 *             (isPort?='end' direction=FeatureDirection? ownedRelatedElement+=AbstractPortUsage) | 
	 *             (isPort?='end' direction=FeatureDirection? memberName=Name? memberFeature=[PortUsage|QualifiedName])
	 *         )
	 *     )
	 */
	protected void sequence_DefinitionMemberPrefix_InterfaceEndMember(ISerializationContext context, EndFeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DefinitionMember returns Membership
	 *     NestedDefinitionMember returns Membership
	 *     AssociationMember returns Membership
	 *     InterfaceMember returns Membership
	 *     ActivityMember returns Membership
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=PrefixAnnotation* 
	 *         visibility=VisibilityIndicator? 
	 *         (
	 *             ownedRelatedElement+=PackageOrStub | 
	 *             (memberName=Name? memberElement=[Package|QualifiedName]) | 
	 *             ownedRelatedElement+=BlockOrStub | 
	 *             (memberName=Name? memberElement=[Block|QualifiedName]) | 
	 *             ownedRelatedElement+=ValueTypeOrStub | 
	 *             (memberName=Name? memberElement=[ValueType|QualifiedName]) | 
	 *             ownedRelatedElement+=AssociationBlockOrStub | 
	 *             (memberName=Name? memberElement=[AssociationBlock|QualifiedName]) | 
	 *             ownedRelatedElement+=InterfaceDefinitionOrStub | 
	 *             (memberName=Name? memberElement=[InterfaceDefinition|QualifiedName]) | 
	 *             ownedRelatedElement+=PortDefinitionOrStub | 
	 *             (memberName=Name? memberElement=[PortDefinition|QualifiedName]) | 
	 *             ownedRelatedElement+=ActivityOrStub | 
	 *             (memberName=Name? memberElement=[Activity|QualifiedName]) | 
	 *             (memberElement=[Element|QualifiedName] memberName=Name?) | 
	 *             ownedRelatedElement+=Comment | 
	 *             (memberName=Name? memberElement=[Comment|QualifiedName])
	 *         )
	 *     )
	 */
	protected void sequence_DefinitionMemberPrefix_PackagedDefinitionMember(ISerializationContext context, Membership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DefinitionMember returns PortMembership
	 *     NestedUsageMember returns PortMembership
	 *     PortMember returns PortMembership
	 *     AssociationMember returns PortMembership
	 *     InterfaceMember returns PortMembership
	 *     ActivityMember returns PortMembership
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=PrefixAnnotation* 
	 *         visibility=VisibilityIndicator? 
	 *         ((isPort?='port' ownedRelatedElement+=PortUsage) | (isPort?='port' ownedRelatedElement+=AbstractPortUsage))
	 *     )
	 */
	protected void sequence_DefinitionMemberPrefix_PortMember(ISerializationContext context, PortMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryUsageMember returns FeatureMembership
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=PrefixAnnotation* 
	 *         visibility=VisibilityIndicator? 
	 *         (
	 *             (isComposite?='part' ownedRelatedElement+=PartProperty) | 
	 *             (isComposite?='part' ownedRelatedElement+=AbstractPartProperty) | 
	 *             (isComposite?='part' memberName=Name? memberFeature=[PartProperty|QualifiedName]) | 
	 *             (direction=FeatureDirection? ownedRelatedElement+=ReferenceProperty) | 
	 *             (direction=FeatureDirection? ownedRelatedElement+=AbstractReferenceProperty) | 
	 *             (direction=FeatureDirection? memberName=Name? memberFeature=[ReferenceProperty|QualifiedName]) | 
	 *             (direction=FeatureDirection? ownedRelatedElement+=ValueProperty) | 
	 *             (direction=FeatureDirection? ownedRelatedElement+=AbstractValueProperty) | 
	 *             (direction=FeatureDirection? memberName=Name? memberFeature=[ValueProperty|QualifiedName]) | 
	 *             ownedRelatedElement+=InterfaceUsage | 
	 *             ownedRelatedElement+=AbstractInterfaceUsage | 
	 *             (memberName=Name? memberFeature=[InterfaceUsage|QualifiedName]) | 
	 *             ownedRelatedElement+=ConnectionUsage | 
	 *             ownedRelatedElement+=AbstractConnectionUsage | 
	 *             ownedRelatedElement+=Connector | 
	 *             ownedRelatedElement+=AbstractConnector | 
	 *             (memberName=Name? memberFeature=[ConnectionUsage|QualifiedName]) | 
	 *             ownedRelatedElement+=BindingConnector | 
	 *             ownedRelatedElement+=Succession | 
	 *             ownedRelatedElement+=AbstractSuccession | 
	 *             (memberName=Name? memberFeature=[Succession|QualifiedName]) | 
	 *             ownedRelatedElement+=ItemFlow | 
	 *             ownedRelatedElement+=AbstractItemFlow | 
	 *             (memberName=Name? memberFeature=[ItemFlow|QualifiedName]) | 
	 *             ownedRelatedElement+=SuccessionItemFlow | 
	 *             ownedRelatedElement+=AbstractSuccessionItemFlow | 
	 *             (memberName=Name? memberFeature=[SuccessionItemFlow|QualifiedName])
	 *         )
	 *     )
	 */
	protected void sequence_DefinitionMemberPrefix_PrimaryUsageMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Documentation returns Comment
	 *
	 * Constraint:
	 *     (name=Name? body=DOCUMENTATION_COMMENT)
	 */
	protected void sequence_Documentation(ISerializationContext context, Comment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmptyAnnotation returns Annotation
	 *
	 * Constraint:
	 *     {Annotation}
	 */
	protected void sequence_EmptyAnnotation(ISerializationContext context, Annotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmptyItemFeatureMember returns FeatureMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=EmptyItemFeature
	 */
	protected void sequence_EmptyItemFeatureMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmptyItemFeature returns ItemFeature
	 *
	 * Constraint:
	 *     {ItemFeature}
	 */
	protected void sequence_EmptyItemFeature(ISerializationContext context, ItemFeature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmptySourceEndMember returns EndFeatureMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=EmptySourceEnd
	 */
	protected void sequence_EmptySourceEndMember(ISerializationContext context, EndFeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmptySourceEnd returns SourceEnd
	 *
	 * Constraint:
	 *     {SourceEnd}
	 */
	protected void sequence_EmptySourceEnd(ISerializationContext context, SourceEnd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmptySuccessionMember returns FeatureMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=EmptySuccession
	 */
	protected void sequence_EmptySuccessionMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmptySuccession returns Succession
	 *
	 * Constraint:
	 *     (ownedRelationship+=MultiplicitySourceEndMember ownedRelationship+=EmptyTargetEndMember)
	 */
	protected void sequence_EmptySuccession(ISerializationContext context, Succession semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmptyTargetEndMember returns EndFeatureMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=EmptyTargetEnd
	 */
	protected void sequence_EmptyTargetEndMember(ISerializationContext context, EndFeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmptyTargetEnd returns TargetEnd
	 *
	 * Constraint:
	 *     {TargetEnd}
	 */
	protected void sequence_EmptyTargetEnd(ISerializationContext context, TargetEnd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionMember returns FeatureMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=Expression
	 */
	protected void sequence_ExpressionMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionTyping returns FeatureTyping
	 *
	 * Constraint:
	 *     type=[Function|QualifiedName]
	 */
	protected void sequence_ExpressionTyping(ISerializationContext context, FeatureTyping semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.FEATURE_TYPING__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.FEATURE_TYPING__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionTypingAccess().getTypeFunctionQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(SysMLPackage.Literals.FEATURE_TYPING__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FeatureReferenceExpression
	 *     ConditionalExpression returns FeatureReferenceExpression
	 *     ConditionalExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     NullCoalescingExpression returns FeatureReferenceExpression
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     ConditionalOrExpression returns FeatureReferenceExpression
	 *     ConditionalOrExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     ConditionalAndExpression returns FeatureReferenceExpression
	 *     ConditionalAndExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     OrExpression returns FeatureReferenceExpression
	 *     OrExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     XorExpression returns FeatureReferenceExpression
	 *     XorExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     AndExpression returns FeatureReferenceExpression
	 *     AndExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     EqualityExpression returns FeatureReferenceExpression
	 *     EqualityExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     ClassificationExpression returns FeatureReferenceExpression
	 *     ClassificationExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     RelationalExpression returns FeatureReferenceExpression
	 *     RelationalExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     AdditiveExpression returns FeatureReferenceExpression
	 *     AdditiveExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     MultiplicativeExpression returns FeatureReferenceExpression
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     UnitsExpression returns FeatureReferenceExpression
	 *     UnitsExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     UnaryExpression returns FeatureReferenceExpression
	 *     SequenceAccessExpression returns FeatureReferenceExpression
	 *     SequenceAccessExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     PrimaryExpression returns FeatureReferenceExpression
	 *     PrimaryExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     BaseExpression returns FeatureReferenceExpression
	 *     FeatureReferenceExpression returns FeatureReferenceExpression
	 *     QueryPathExpression returns FeatureReferenceExpression
	 *     QueryPathExpression.QueryQualifierExpression_1_1 returns FeatureReferenceExpression
	 *     QueryPathExpression.QueryPathStepExpression_2_1 returns FeatureReferenceExpression
	 *     QueryHeadExpression returns FeatureReferenceExpression
	 *
	 * Constraint:
	 *     ownedRelationship+=FeatureReference
	 */
	protected void sequence_FeatureReferenceExpression(ISerializationContext context, FeatureReferenceExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FeatureReference returns FeatureMembership
	 *
	 * Constraint:
	 *     memberFeature=[Feature|QualifiedName]
	 */
	protected void sequence_FeatureReference(ISerializationContext context, FeatureMembership semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.FEATURE_MEMBERSHIP__MEMBER_FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.FEATURE_MEMBERSHIP__MEMBER_FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFeatureReferenceAccess().getMemberFeatureFeatureQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(SysMLPackage.Literals.FEATURE_MEMBERSHIP__MEMBER_FEATURE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FeatureTyping returns FeatureTyping
	 *
	 * Constraint:
	 *     type=[Type|QualifiedName]
	 */
	protected void sequence_FeatureTyping(ISerializationContext context, FeatureTyping semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.FEATURE_TYPING__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.FEATURE_TYPING__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFeatureTypingAccess().getTypeTypeQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(SysMLPackage.Literals.FEATURE_TYPING__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FeatureValue returns FeatureValue
	 *
	 * Constraint:
	 *     ownedRelatedElement+=Expression
	 */
	protected void sequence_FeatureValue(ISerializationContext context, FeatureValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActivityNode returns ForkNode
	 *     ControlNode returns ForkNode
	 *     ForkNode returns ForkNode
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=EmptySuccessionMember? 
	 *         isComposite?='fork' 
	 *         (name=Name ownedRelationship+=FeatureTyping? ownedRelationship+=Multiplicity? (isOrdered?='ordered' | isNonunique?='nonunique')*)?
	 *     )
	 */
	protected void sequence_ForkNode_MultiplicityPart_Typing(ISerializationContext context, ForkNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=PrefixAnnotation* 
	 *         visibility=PackageElementVisibilityIndicator? 
	 *         (importedPackage=[Package|Name] | importedPackage=[Package|ColonQualifiedName] | importedPackage=[Package|DotQualifiedName])
	 *     )
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns InvocationExpression
	 *     ConditionalExpression returns InvocationExpression
	 *     ConditionalExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     NullCoalescingExpression returns InvocationExpression
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     ConditionalOrExpression returns InvocationExpression
	 *     ConditionalOrExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     ConditionalAndExpression returns InvocationExpression
	 *     ConditionalAndExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     OrExpression returns InvocationExpression
	 *     OrExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     XorExpression returns InvocationExpression
	 *     XorExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     AndExpression returns InvocationExpression
	 *     AndExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     EqualityExpression returns InvocationExpression
	 *     EqualityExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     ClassificationExpression returns InvocationExpression
	 *     ClassificationExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     RelationalExpression returns InvocationExpression
	 *     RelationalExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     AdditiveExpression returns InvocationExpression
	 *     AdditiveExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     MultiplicativeExpression returns InvocationExpression
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     UnitsExpression returns InvocationExpression
	 *     UnitsExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     UnaryExpression returns InvocationExpression
	 *     SequenceAccessExpression returns InvocationExpression
	 *     SequenceAccessExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     PrimaryExpression returns InvocationExpression
	 *     PrimaryExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     BaseExpression returns InvocationExpression
	 *     InvocationExpression returns InvocationExpression
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=FeatureTyping 
	 *         (
	 *             (ownedRelationship+=ExpressionMember ownedRelationship+=ExpressionMember*) | 
	 *             (ownedRelationship+=NamedExpressionMember ownedRelationship+=NamedExpressionMember*)
	 *         )?
	 *     )
	 */
	protected void sequence_InvocationExpression_NamedTuple_PositionalTuple(ISerializationContext context, InvocationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ItemFeatureMember returns FeatureMembership
	 *
	 * Constraint:
	 *     (memberName=Name? ownedRelatedElement+=ItemFeatureTyping)
	 */
	protected void sequence_ItemFeatureMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ItemFeatureTyping returns ItemFeature
	 *
	 * Constraint:
	 *     (ownedRelationship+=FeatureTyping ownedRelationship+=Multiplicity?)
	 */
	protected void sequence_ItemFeatureTyping(ISerializationContext context, ItemFeature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ItemFlowEndMember returns EndFeatureMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=ItemFlowEnd
	 */
	protected void sequence_ItemFlowEndMember(ISerializationContext context, EndFeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ItemFlowEnd returns ItemFlowEnd
	 *
	 * Constraint:
	 *     ownedRelationship+=ItemFlowFeatureMember
	 */
	protected void sequence_ItemFlowEnd(ISerializationContext context, ItemFlowEnd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ItemFlowFeatureMember returns FeatureMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=ItemFlowFeature
	 */
	protected void sequence_ItemFlowFeatureMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ItemFlowFeature returns ItemFlowFeature
	 *
	 * Constraint:
	 *     ownedRelationship+=Redefinition
	 */
	protected void sequence_ItemFlowFeature(ISerializationContext context, ItemFlowFeature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActivityNode returns JoinNode
	 *     ControlNode returns JoinNode
	 *     JoinNode returns JoinNode
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=EmptySuccessionMember? 
	 *         isComposite?='join' 
	 *         (name=Name ownedRelationship+=FeatureTyping? ownedRelationship+=Multiplicity? (isOrdered?='ordered' | isNonunique?='nonunique')*)?
	 *     )
	 */
	protected void sequence_JoinNode_MultiplicityPart_Typing(ISerializationContext context, JoinNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActivityNode returns MergeNode
	 *     ControlNode returns MergeNode
	 *     MergeNode returns MergeNode
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=EmptySuccessionMember? 
	 *         isComposite?='merge' 
	 *         (name=Name ownedRelationship+=FeatureTyping? ownedRelationship+=Multiplicity? (isOrdered?='ordered' | isNonunique?='nonunique')*)?
	 *     )
	 */
	protected void sequence_MergeNode_MultiplicityPart_Typing(ISerializationContext context, MergeNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Succession returns Succession
	 *
	 * Constraint:
	 *     (
	 *         name=Name? 
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         (isOrdered?='ordered' | isNonunique?='nonunique')* 
	 *         ownedRelationship+=ConnectorEndMember 
	 *         ownedRelationship+=ConnectorEndMember
	 *     )
	 */
	protected void sequence_MultiplicityPart_SuccessionDeclaration_Typing(ISerializationContext context, Succession semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (ownedRelationship+=FeatureTyping? ownedRelationship+=Multiplicity? (isOrdered?='ordered' | isNonunique?='nonunique')*)
	 */
	protected void sequence_MultiplicityPart_Typing(ISerializationContext context, org.omg.sysml.lang.sysml.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActionParameter returns Parameter
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=FeatureTyping? 
	 *         ownedRelationship+=Multiplicity? 
	 *         (isOrdered?='ordered' | isNonunique?='nonunique')* 
	 *         ownedRelationship+=FeatureValue?
	 *     )
	 */
	protected void sequence_MultiplicityPart_Typing_ValuePart(ISerializationContext context, org.omg.sysml.lang.sysml.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultiplicitySourceEndMember returns EndFeatureMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=MultiplicitySourceEnd
	 */
	protected void sequence_MultiplicitySourceEndMember(ISerializationContext context, EndFeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultiplicitySourceEnd returns SourceEnd
	 *
	 * Constraint:
	 *     ownedRelationship+=Multiplicity?
	 */
	protected void sequence_MultiplicitySourceEnd(ISerializationContext context, SourceEnd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Multiplicity returns Multiplicity
	 *
	 * Constraint:
	 *     (ownedRelatedElement+=NaturalLiteralExpression? ownedRelatedElement+=UnlimitedNaturalLiteralExpression)
	 */
	protected void sequence_Multiplicity(ISerializationContext context, Multiplicity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedExpressionMember returns FeatureMembership
	 *
	 * Constraint:
	 *     (memberName=Name ownedRelatedElement+=Expression)
	 */
	protected void sequence_NamedExpressionMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralInteger
	 *     ConditionalExpression returns LiteralInteger
	 *     ConditionalExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     NullCoalescingExpression returns LiteralInteger
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     ConditionalOrExpression returns LiteralInteger
	 *     ConditionalOrExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     ConditionalAndExpression returns LiteralInteger
	 *     ConditionalAndExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     OrExpression returns LiteralInteger
	 *     OrExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     XorExpression returns LiteralInteger
	 *     XorExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     AndExpression returns LiteralInteger
	 *     AndExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     EqualityExpression returns LiteralInteger
	 *     EqualityExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     ClassificationExpression returns LiteralInteger
	 *     ClassificationExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     RelationalExpression returns LiteralInteger
	 *     RelationalExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     AdditiveExpression returns LiteralInteger
	 *     AdditiveExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     MultiplicativeExpression returns LiteralInteger
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     UnitsExpression returns LiteralInteger
	 *     UnitsExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     UnaryExpression returns LiteralInteger
	 *     SequenceAccessExpression returns LiteralInteger
	 *     SequenceAccessExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     PrimaryExpression returns LiteralInteger
	 *     PrimaryExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     BaseExpression returns LiteralInteger
	 *     LiteralExpression returns LiteralInteger
	 *     NaturalLiteralExpression returns LiteralInteger
	 *     UnlimitedNaturalLiteralExpression returns LiteralInteger
	 *
	 * Constraint:
	 *     value=NATURAL_VALUE
	 */
	protected void sequence_NaturalLiteralExpression(ISerializationContext context, LiteralInteger semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.LITERAL_INTEGER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.LITERAL_INTEGER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNaturalLiteralExpressionAccess().getValueNATURAL_VALUETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NullExpression
	 *     ConditionalExpression returns NullExpression
	 *     ConditionalExpression.OperatorExpression_1_0 returns NullExpression
	 *     NullCoalescingExpression returns NullExpression
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns NullExpression
	 *     ConditionalOrExpression returns NullExpression
	 *     ConditionalOrExpression.OperatorExpression_1_0 returns NullExpression
	 *     ConditionalAndExpression returns NullExpression
	 *     ConditionalAndExpression.OperatorExpression_1_0 returns NullExpression
	 *     OrExpression returns NullExpression
	 *     OrExpression.OperatorExpression_1_0 returns NullExpression
	 *     XorExpression returns NullExpression
	 *     XorExpression.OperatorExpression_1_0 returns NullExpression
	 *     AndExpression returns NullExpression
	 *     AndExpression.OperatorExpression_1_0 returns NullExpression
	 *     EqualityExpression returns NullExpression
	 *     EqualityExpression.OperatorExpression_1_0 returns NullExpression
	 *     ClassificationExpression returns NullExpression
	 *     ClassificationExpression.OperatorExpression_1_0 returns NullExpression
	 *     RelationalExpression returns NullExpression
	 *     RelationalExpression.OperatorExpression_1_0 returns NullExpression
	 *     AdditiveExpression returns NullExpression
	 *     AdditiveExpression.OperatorExpression_1_0 returns NullExpression
	 *     MultiplicativeExpression returns NullExpression
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns NullExpression
	 *     UnitsExpression returns NullExpression
	 *     UnitsExpression.OperatorExpression_1_0 returns NullExpression
	 *     UnaryExpression returns NullExpression
	 *     SequenceAccessExpression returns NullExpression
	 *     SequenceAccessExpression.OperatorExpression_1_0 returns NullExpression
	 *     PrimaryExpression returns NullExpression
	 *     PrimaryExpression.OperatorExpression_1_0 returns NullExpression
	 *     BaseExpression returns NullExpression
	 *     NullExpression returns NullExpression
	 *
	 * Constraint:
	 *     {NullExpression}
	 */
	protected void sequence_NullExpression(ISerializationContext context, NullExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnonymousPackage returns Package
	 *
	 * Constraint:
	 *     (ownedRelationship+=PackageMember | ownedRelationship+=Import)*
	 */
	protected void sequence_PackageBody(ISerializationContext context, org.omg.sysml.lang.sysml.Package semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PackageMember returns Membership
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=PrefixAnnotation* 
	 *         visibility=PackageElementVisibilityIndicator? 
	 *         (
	 *             ownedRelatedElement+=PackageOrStub | 
	 *             (memberName=Name? memberElement=[Package|QualifiedName]) | 
	 *             ownedRelatedElement+=BlockOrStub | 
	 *             (memberName=Name? memberElement=[Block|QualifiedName]) | 
	 *             ownedRelatedElement+=ValueTypeOrStub | 
	 *             (memberName=Name? memberElement=[ValueType|QualifiedName]) | 
	 *             ownedRelatedElement+=AssociationBlockOrStub | 
	 *             (memberName=Name? memberElement=[AssociationBlock|QualifiedName]) | 
	 *             ownedRelatedElement+=InterfaceDefinitionOrStub | 
	 *             (memberName=Name? memberElement=[InterfaceDefinition|QualifiedName]) | 
	 *             ownedRelatedElement+=PortDefinitionOrStub | 
	 *             (memberName=Name? memberElement=[PortDefinition|QualifiedName]) | 
	 *             ownedRelatedElement+=ActivityOrStub | 
	 *             (memberName=Name? memberElement=[Activity|QualifiedName]) | 
	 *             (memberElement=[Element|QualifiedName] memberName=Name?) | 
	 *             ownedRelatedElement+=Comment | 
	 *             (memberName=Name? memberElement=[Comment|QualifiedName]) | 
	 *             ownedRelatedElement+=PartProperty | 
	 *             ownedRelatedElement+=AbstractPartProperty | 
	 *             (memberName=Name? memberElement=[PartProperty|QualifiedName]) | 
	 *             ownedRelatedElement+=ValueProperty | 
	 *             ownedRelatedElement+=AbstractValueProperty | 
	 *             ((memberName=Name | memberName=Name)? memberElement=[ValueProperty|QualifiedName]) | 
	 *             ownedRelatedElement+=ActionUsage | 
	 *             ownedRelatedElement+=AbstractActionUsage | 
	 *             (memberName=Name? memberElement=[ActionUsage|QualifiedName])
	 *         )
	 *     )
	 */
	protected void sequence_PackageMemberPrefix_PackagedDefinitionMember_PackagedUsageMember(ISerializationContext context, Membership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PackageOrStub returns Package
	 *
	 * Constraint:
	 *     (name=Name (ownedRelationship+=PackageMember | ownedRelationship+=Import)*)
	 */
	protected void sequence_Package_PackageBody(ISerializationContext context, org.omg.sysml.lang.sysml.Package semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns Package
	 *
	 * Constraint:
	 *     ((ownedRelationship+=PrefixAnnotation* name=Name)? (ownedRelationship+=PackageMember | ownedRelationship+=Import)*)
	 */
	protected void sequence_Package_PackageBody_UnitPrefix(ISerializationContext context, org.omg.sysml.lang.sysml.Package semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     PackageUnit returns Package
	//
	// Constraint:
	//     (ownedRelationship+=PrefixAnnotation* name=Name (ownedRelationship+=PackageMember | ownedRelationship+=Import)*)
	//
	// protected void sequence_Package_PackageBody_UnitPrefix(ISerializationContext context, org.omg.sysml.lang.sysml.Package semanticObject) { }
	
	/**
	 * Contexts:
	 *     ParameterMember returns ParameterMembership
	 *
	 * Constraint:
	 *     (direction=FeatureDirection? memberName=Name ownedRelatedElement+=Parameter)
	 */
	protected void sequence_ParameterMember(ISerializationContext context, ParameterMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrefixAnnotation returns Annotation
	 *
	 * Constraint:
	 *     ownedRelatedElement+=Documentation
	 */
	protected void sequence_PrefixAnnotation(ISerializationContext context, Annotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     QueryNameExpression returns QueryPathExpression
	 *
	 * Constraint:
	 *     ownedRelationship+=FeatureReference
	 */
	protected void sequence_QueryNameExpression(ISerializationContext context, QueryPathExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns QueryPathStepExpression
	 *     ConditionalExpression returns QueryPathStepExpression
	 *     ConditionalExpression.OperatorExpression_1_0 returns QueryPathStepExpression
	 *     NullCoalescingExpression returns QueryPathStepExpression
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns QueryPathStepExpression
	 *     ConditionalOrExpression returns QueryPathStepExpression
	 *     ConditionalOrExpression.OperatorExpression_1_0 returns QueryPathStepExpression
	 *     ConditionalAndExpression returns QueryPathStepExpression
	 *     ConditionalAndExpression.OperatorExpression_1_0 returns QueryPathStepExpression
	 *     OrExpression returns QueryPathStepExpression
	 *     OrExpression.OperatorExpression_1_0 returns QueryPathStepExpression
	 *     XorExpression returns QueryPathStepExpression
	 *     XorExpression.OperatorExpression_1_0 returns QueryPathStepExpression
	 *     AndExpression returns QueryPathStepExpression
	 *     AndExpression.OperatorExpression_1_0 returns QueryPathStepExpression
	 *     EqualityExpression returns QueryPathStepExpression
	 *     EqualityExpression.OperatorExpression_1_0 returns QueryPathStepExpression
	 *     ClassificationExpression returns QueryPathStepExpression
	 *     ClassificationExpression.OperatorExpression_1_0 returns QueryPathStepExpression
	 *     RelationalExpression returns QueryPathStepExpression
	 *     RelationalExpression.OperatorExpression_1_0 returns QueryPathStepExpression
	 *     AdditiveExpression returns QueryPathStepExpression
	 *     AdditiveExpression.OperatorExpression_1_0 returns QueryPathStepExpression
	 *     MultiplicativeExpression returns QueryPathStepExpression
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns QueryPathStepExpression
	 *     UnitsExpression returns QueryPathStepExpression
	 *     UnitsExpression.OperatorExpression_1_0 returns QueryPathStepExpression
	 *     UnaryExpression returns QueryPathStepExpression
	 *     SequenceAccessExpression returns QueryPathStepExpression
	 *     SequenceAccessExpression.OperatorExpression_1_0 returns QueryPathStepExpression
	 *     PrimaryExpression returns QueryPathStepExpression
	 *     PrimaryExpression.OperatorExpression_1_0 returns QueryPathStepExpression
	 *     BaseExpression returns QueryPathStepExpression
	 *     QueryPathExpression returns QueryPathStepExpression
	 *     QueryPathExpression.QueryPathStepExpression_2_1 returns QueryPathStepExpression
	 *     QueryPathExpression.QueryQualifierExpression_2_3_1 returns QueryPathStepExpression
	 *
	 * Constraint:
	 *     (operand+=QueryPathExpression_QueryPathStepExpression_2_1 operand+=QueryNameExpression)
	 */
	protected void sequence_QueryPathExpression(ISerializationContext context, QueryPathStepExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns QueryQualifierExpression
	 *     ConditionalExpression returns QueryQualifierExpression
	 *     ConditionalExpression.OperatorExpression_1_0 returns QueryQualifierExpression
	 *     NullCoalescingExpression returns QueryQualifierExpression
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns QueryQualifierExpression
	 *     ConditionalOrExpression returns QueryQualifierExpression
	 *     ConditionalOrExpression.OperatorExpression_1_0 returns QueryQualifierExpression
	 *     ConditionalAndExpression returns QueryQualifierExpression
	 *     ConditionalAndExpression.OperatorExpression_1_0 returns QueryQualifierExpression
	 *     OrExpression returns QueryQualifierExpression
	 *     OrExpression.OperatorExpression_1_0 returns QueryQualifierExpression
	 *     XorExpression returns QueryQualifierExpression
	 *     XorExpression.OperatorExpression_1_0 returns QueryQualifierExpression
	 *     AndExpression returns QueryQualifierExpression
	 *     AndExpression.OperatorExpression_1_0 returns QueryQualifierExpression
	 *     EqualityExpression returns QueryQualifierExpression
	 *     EqualityExpression.OperatorExpression_1_0 returns QueryQualifierExpression
	 *     ClassificationExpression returns QueryQualifierExpression
	 *     ClassificationExpression.OperatorExpression_1_0 returns QueryQualifierExpression
	 *     RelationalExpression returns QueryQualifierExpression
	 *     RelationalExpression.OperatorExpression_1_0 returns QueryQualifierExpression
	 *     AdditiveExpression returns QueryQualifierExpression
	 *     AdditiveExpression.OperatorExpression_1_0 returns QueryQualifierExpression
	 *     MultiplicativeExpression returns QueryQualifierExpression
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns QueryQualifierExpression
	 *     UnitsExpression returns QueryQualifierExpression
	 *     UnitsExpression.OperatorExpression_1_0 returns QueryQualifierExpression
	 *     UnaryExpression returns QueryQualifierExpression
	 *     SequenceAccessExpression returns QueryQualifierExpression
	 *     SequenceAccessExpression.OperatorExpression_1_0 returns QueryQualifierExpression
	 *     PrimaryExpression returns QueryQualifierExpression
	 *     PrimaryExpression.OperatorExpression_1_0 returns QueryQualifierExpression
	 *     BaseExpression returns QueryQualifierExpression
	 *     QueryPathExpression returns QueryQualifierExpression
	 *     QueryPathExpression.QueryPathStepExpression_2_1 returns QueryQualifierExpression
	 *
	 * Constraint:
	 *     (
	 *         (operand+=QueryPathExpression_QueryQualifierExpression_1_1 ownedRelationship+=BodyMember) | 
	 *         (operand+=QueryPathExpression_QueryQualifierExpression_2_3_1 ownedRelationship+=BodyMember)
	 *     )
	 */
	protected void sequence_QueryPathExpression(ISerializationContext context, QueryQualifierExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralReal
	 *     ConditionalExpression returns LiteralReal
	 *     ConditionalExpression.OperatorExpression_1_0 returns LiteralReal
	 *     NullCoalescingExpression returns LiteralReal
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns LiteralReal
	 *     ConditionalOrExpression returns LiteralReal
	 *     ConditionalOrExpression.OperatorExpression_1_0 returns LiteralReal
	 *     ConditionalAndExpression returns LiteralReal
	 *     ConditionalAndExpression.OperatorExpression_1_0 returns LiteralReal
	 *     OrExpression returns LiteralReal
	 *     OrExpression.OperatorExpression_1_0 returns LiteralReal
	 *     XorExpression returns LiteralReal
	 *     XorExpression.OperatorExpression_1_0 returns LiteralReal
	 *     AndExpression returns LiteralReal
	 *     AndExpression.OperatorExpression_1_0 returns LiteralReal
	 *     EqualityExpression returns LiteralReal
	 *     EqualityExpression.OperatorExpression_1_0 returns LiteralReal
	 *     ClassificationExpression returns LiteralReal
	 *     ClassificationExpression.OperatorExpression_1_0 returns LiteralReal
	 *     RelationalExpression returns LiteralReal
	 *     RelationalExpression.OperatorExpression_1_0 returns LiteralReal
	 *     AdditiveExpression returns LiteralReal
	 *     AdditiveExpression.OperatorExpression_1_0 returns LiteralReal
	 *     MultiplicativeExpression returns LiteralReal
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns LiteralReal
	 *     UnitsExpression returns LiteralReal
	 *     UnitsExpression.OperatorExpression_1_0 returns LiteralReal
	 *     UnaryExpression returns LiteralReal
	 *     SequenceAccessExpression returns LiteralReal
	 *     SequenceAccessExpression.OperatorExpression_1_0 returns LiteralReal
	 *     PrimaryExpression returns LiteralReal
	 *     PrimaryExpression.OperatorExpression_1_0 returns LiteralReal
	 *     BaseExpression returns LiteralReal
	 *     LiteralExpression returns LiteralReal
	 *     RealLiteralExpression returns LiteralReal
	 *
	 * Constraint:
	 *     value=RealValue
	 */
	protected void sequence_RealLiteralExpression(ISerializationContext context, LiteralReal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.LITERAL_REAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.LITERAL_REAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealLiteralExpressionAccess().getValueRealValueParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Redefinition returns Redefinition
	 *
	 * Constraint:
	 *     redefinedFeature=[Feature|QualifiedName]
	 */
	protected void sequence_Redefinition(ISerializationContext context, Redefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.REDEFINITION__REDEFINED_FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.REDEFINITION__REDEFINED_FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRedefinitionAccess().getRedefinedFeatureFeatureQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(SysMLPackage.Literals.REDEFINITION__REDEFINED_FEATURE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns SequenceConstructionExpression
	 *     ConditionalExpression returns SequenceConstructionExpression
	 *     ConditionalExpression.OperatorExpression_1_0 returns SequenceConstructionExpression
	 *     NullCoalescingExpression returns SequenceConstructionExpression
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns SequenceConstructionExpression
	 *     ConditionalOrExpression returns SequenceConstructionExpression
	 *     ConditionalOrExpression.OperatorExpression_1_0 returns SequenceConstructionExpression
	 *     ConditionalAndExpression returns SequenceConstructionExpression
	 *     ConditionalAndExpression.OperatorExpression_1_0 returns SequenceConstructionExpression
	 *     OrExpression returns SequenceConstructionExpression
	 *     OrExpression.OperatorExpression_1_0 returns SequenceConstructionExpression
	 *     XorExpression returns SequenceConstructionExpression
	 *     XorExpression.OperatorExpression_1_0 returns SequenceConstructionExpression
	 *     AndExpression returns SequenceConstructionExpression
	 *     AndExpression.OperatorExpression_1_0 returns SequenceConstructionExpression
	 *     EqualityExpression returns SequenceConstructionExpression
	 *     EqualityExpression.OperatorExpression_1_0 returns SequenceConstructionExpression
	 *     ClassificationExpression returns SequenceConstructionExpression
	 *     ClassificationExpression.OperatorExpression_1_0 returns SequenceConstructionExpression
	 *     RelationalExpression returns SequenceConstructionExpression
	 *     RelationalExpression.OperatorExpression_1_0 returns SequenceConstructionExpression
	 *     AdditiveExpression returns SequenceConstructionExpression
	 *     AdditiveExpression.OperatorExpression_1_0 returns SequenceConstructionExpression
	 *     MultiplicativeExpression returns SequenceConstructionExpression
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns SequenceConstructionExpression
	 *     UnitsExpression returns SequenceConstructionExpression
	 *     UnitsExpression.OperatorExpression_1_0 returns SequenceConstructionExpression
	 *     UnaryExpression returns SequenceConstructionExpression
	 *     SequenceAccessExpression returns SequenceConstructionExpression
	 *     SequenceAccessExpression.OperatorExpression_1_0 returns SequenceConstructionExpression
	 *     PrimaryExpression returns SequenceConstructionExpression
	 *     PrimaryExpression.OperatorExpression_1_0 returns SequenceConstructionExpression
	 *     BaseExpression returns SequenceConstructionExpression
	 *     SequenceConstructionExpression returns SequenceConstructionExpression
	 *
	 * Constraint:
	 *     (element+=Expression element+=Expression*)?
	 */
	protected void sequence_SequenceConstructionExpression(ISerializationContext context, SequenceConstructionExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralString
	 *     ConditionalExpression returns LiteralString
	 *     ConditionalExpression.OperatorExpression_1_0 returns LiteralString
	 *     NullCoalescingExpression returns LiteralString
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns LiteralString
	 *     ConditionalOrExpression returns LiteralString
	 *     ConditionalOrExpression.OperatorExpression_1_0 returns LiteralString
	 *     ConditionalAndExpression returns LiteralString
	 *     ConditionalAndExpression.OperatorExpression_1_0 returns LiteralString
	 *     OrExpression returns LiteralString
	 *     OrExpression.OperatorExpression_1_0 returns LiteralString
	 *     XorExpression returns LiteralString
	 *     XorExpression.OperatorExpression_1_0 returns LiteralString
	 *     AndExpression returns LiteralString
	 *     AndExpression.OperatorExpression_1_0 returns LiteralString
	 *     EqualityExpression returns LiteralString
	 *     EqualityExpression.OperatorExpression_1_0 returns LiteralString
	 *     ClassificationExpression returns LiteralString
	 *     ClassificationExpression.OperatorExpression_1_0 returns LiteralString
	 *     RelationalExpression returns LiteralString
	 *     RelationalExpression.OperatorExpression_1_0 returns LiteralString
	 *     AdditiveExpression returns LiteralString
	 *     AdditiveExpression.OperatorExpression_1_0 returns LiteralString
	 *     MultiplicativeExpression returns LiteralString
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns LiteralString
	 *     UnitsExpression returns LiteralString
	 *     UnitsExpression.OperatorExpression_1_0 returns LiteralString
	 *     UnaryExpression returns LiteralString
	 *     SequenceAccessExpression returns LiteralString
	 *     SequenceAccessExpression.OperatorExpression_1_0 returns LiteralString
	 *     PrimaryExpression returns LiteralString
	 *     PrimaryExpression.OperatorExpression_1_0 returns LiteralString
	 *     BaseExpression returns LiteralString
	 *     LiteralExpression returns LiteralString
	 *     StringLiteralExpression returns LiteralString
	 *
	 * Constraint:
	 *     value=STRING_VALUE
	 */
	protected void sequence_StringLiteralExpression(ISerializationContext context, LiteralString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.LITERAL_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.LITERAL_STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralExpressionAccess().getValueSTRING_VALUETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Subset returns Subsetting
	 *
	 * Constraint:
	 *     subsettedFeature=[Feature|QualifiedName]
	 */
	protected void sequence_Subset(ISerializationContext context, Subsetting semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.SUBSETTING__SUBSETTED_FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.SUBSETTING__SUBSETTED_FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubsetAccess().getSubsettedFeatureFeatureQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(SysMLPackage.Literals.SUBSETTING__SUBSETTED_FEATURE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Superclassing returns Superclassing
	 *
	 * Constraint:
	 *     superclass=[Classifier|QualifiedName]
	 */
	protected void sequence_Superclassing(ISerializationContext context, Superclassing semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.SUPERCLASSING__SUPERCLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.SUPERCLASSING__SUPERCLASS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSuperclassingAccess().getSuperclassClassifierQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(SysMLPackage.Literals.SUPERCLASSING__SUPERCLASS, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TargetSuccession returns Succession
	 *
	 * Constraint:
	 *     (ownedRelationship+=MultiplicitySourceEndMember ownedRelationship+=ConnectorEndMember)
	 */
	protected void sequence_TargetSuccession(ISerializationContext context, Succession semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeReferenceMember returns FeatureMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=TypeReference
	 */
	protected void sequence_TypeReferenceMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeReference returns Feature
	 *
	 * Constraint:
	 *     ownedRelationship+=FeatureTyping
	 */
	protected void sequence_TypeReference(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralUnbounded
	 *     ConditionalExpression returns LiteralUnbounded
	 *     ConditionalExpression.OperatorExpression_1_0 returns LiteralUnbounded
	 *     NullCoalescingExpression returns LiteralUnbounded
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns LiteralUnbounded
	 *     ConditionalOrExpression returns LiteralUnbounded
	 *     ConditionalOrExpression.OperatorExpression_1_0 returns LiteralUnbounded
	 *     ConditionalAndExpression returns LiteralUnbounded
	 *     ConditionalAndExpression.OperatorExpression_1_0 returns LiteralUnbounded
	 *     OrExpression returns LiteralUnbounded
	 *     OrExpression.OperatorExpression_1_0 returns LiteralUnbounded
	 *     XorExpression returns LiteralUnbounded
	 *     XorExpression.OperatorExpression_1_0 returns LiteralUnbounded
	 *     AndExpression returns LiteralUnbounded
	 *     AndExpression.OperatorExpression_1_0 returns LiteralUnbounded
	 *     EqualityExpression returns LiteralUnbounded
	 *     EqualityExpression.OperatorExpression_1_0 returns LiteralUnbounded
	 *     ClassificationExpression returns LiteralUnbounded
	 *     ClassificationExpression.OperatorExpression_1_0 returns LiteralUnbounded
	 *     RelationalExpression returns LiteralUnbounded
	 *     RelationalExpression.OperatorExpression_1_0 returns LiteralUnbounded
	 *     AdditiveExpression returns LiteralUnbounded
	 *     AdditiveExpression.OperatorExpression_1_0 returns LiteralUnbounded
	 *     MultiplicativeExpression returns LiteralUnbounded
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns LiteralUnbounded
	 *     UnitsExpression returns LiteralUnbounded
	 *     UnitsExpression.OperatorExpression_1_0 returns LiteralUnbounded
	 *     UnaryExpression returns LiteralUnbounded
	 *     SequenceAccessExpression returns LiteralUnbounded
	 *     SequenceAccessExpression.OperatorExpression_1_0 returns LiteralUnbounded
	 *     PrimaryExpression returns LiteralUnbounded
	 *     PrimaryExpression.OperatorExpression_1_0 returns LiteralUnbounded
	 *     BaseExpression returns LiteralUnbounded
	 *     LiteralExpression returns LiteralUnbounded
	 *     UnlimitedNaturalLiteralExpression returns LiteralUnbounded
	 *
	 * Constraint:
	 *     {LiteralUnbounded}
	 */
	protected void sequence_UnlimitedNaturalLiteralExpression(ISerializationContext context, LiteralUnbounded semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
