/*
 * generated by Xtext 2.18.0.M3
 */
package org.omg.sysml.xtext.validation


import org.eclipse.xtext.validation.Check
import org.omg.kerml.xtext.validation.KerMLValidator
import org.omg.sysml.lang.sysml.Subsetting
import org.omg.sysml.lang.sysml.SysMLPackage
import org.omg.sysml.lang.sysml.Type
import org.omg.sysml.lang.sysml.Redefinition
import org.omg.sysml.lang.sysml.MultiplicityRange
import org.omg.sysml.lang.sysml.LiteralInteger
import org.omg.sysml.lang.sysml.Connector
import org.omg.sysml.lang.sysml.LiteralUnbounded
import java.util.Set
import org.omg.sysml.lang.sysml.Expression
import org.omg.sysml.lang.sysml.Multiplicity

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class SysMLValidator extends KerMLValidator {
	
	public static val INVALID_MULTIPLICITY_ILLEGALLOWERBOUND = 'Invalid Multiplicity - Illegal lower bound'
	
	public static val INVALID_SUBSETTING_OWNINGTYPECONFORMANCE = 'Invalid Subsetting - OwningType conformance'
	public static val INVALID_REDEFINITION_OWNINGTYPECONFORMANCE = 'Invalid Redefinition - OwningType conformance'
	public static val INVALID_SUBSETTING_MULTIPLICITYCONFORMANCE = 'Invalid Subsetting - Multiplicity conformance'
	public static val INVALID_REDEFINITION_MULTIPLICITYCONFORMANCE = 'Invalid Redefinition - Multiplicity conformance'
	public static val INVALID_SUBSETTING_UNIQUENESS_CONFORMANCE = 'Invalid Subsetting - Uniqueness conformance'
	
	@Check
	def checkMultiplicityLowerBound(Multiplicity mult) {
		if (mult instanceof MultiplicityRange && (mult as MultiplicityRange).getLowerBound() instanceof LiteralUnbounded) {
			error("Multiplicity lower bound cannot be *", SysMLPackage.eINSTANCE.multiplicityRange_LowerBound, 
				org.omg.sysml.xtext.validation.SysMLValidator.INVALID_MULTIPLICITY_ILLEGALLOWERBOUND
			);
		}		
	}
	
	@Check
	def checkSubsettingConformance(Subsetting sub) { 
		
		var subsettingFeatureName = sub.subsettingFeature?.name
		var subsettedFeatureName = sub.subsettedFeature?.name
		var subsettingOwningType = sub.subsettingFeature?.owningType
		var subsettedOwningType = sub.subsettedFeature?.owningType
		
		//due to how connector is implemented - no validation is performed
		if ( subsettingOwningType === null || subsettedOwningType === null ||
			subsettingOwningType instanceof Connector || subsettedOwningType instanceof Connector ) 
			return;
			
		// Multiplicity conformance
		
		var setted_m = sub.subsettedFeature?.multiplicity
		var setting_m = sub.subsettingFeature?.multiplicity
		var Expression setting_m_l = null;
		var Expression setting_m_u = null;
		
		// Only check multiplicity conformance if the subsettingFeature owns its multiplicity element.
		if (setted_m instanceof MultiplicityRange && setting_m instanceof MultiplicityRange && setting_m.owningType === sub.subsettingFeature) {
			var setted_m_l = (setted_m as MultiplicityRange)?.lowerBound
			var setted_m_u = (setted_m as MultiplicityRange)?.upperBound
			
			setting_m_l = (setting_m as MultiplicityRange)?.lowerBound
			setting_m_u = (setting_m as MultiplicityRange)?.upperBound
			
			// Lower bound (only check if the Subsetting is a Redefinition): setting must be >= setted
			if (sub instanceof Redefinition) {
				if (setting_m_l instanceof LiteralInteger && setted_m_l instanceof LiteralInteger && (setting_m_l as LiteralInteger).value < (setted_m_l as LiteralInteger).value) {
					error("Redefinition.redefiningFeature(" + subsettingFeatureName + ")'s lowerBound multiplicity(" +  (setting_m_l as LiteralInteger).value + ") shall be greater than or equal to Redefinition.redefinedFeature(" + subsettedFeatureName + ")'s lowerBound multiplicity(" +  (setted_m_l as LiteralInteger).value + ").", sub, 
						SysMLPackage.eINSTANCE.redefinition_RedefiningFeature, org.omg.sysml.xtext.validation.SysMLValidator.INVALID_REDEFINITION_MULTIPLICITYCONFORMANCE)
				}
			}
			
			// Upper bound: setting must be <= setted
			if ( setting_m_u instanceof LiteralUnbounded && !(setted_m_u instanceof LiteralUnbounded)) {
				error("Subsetting.subsettingFeature("+ subsettingFeatureName + ")'s upperBound multiplicity shall be less than or equal to Subsetting.subsettedFeature(" + subsettedFeatureName + ")'s upperBound multiplicity.", sub, 
						SysMLPackage.eINSTANCE.subsetting_SubsettingFeature, org.omg.sysml.xtext.validation.SysMLValidator.INVALID_SUBSETTING_MULTIPLICITYCONFORMANCE)
			}
			if ( setting_m_u instanceof LiteralInteger && setted_m_u instanceof LiteralInteger && (setting_m_u as LiteralInteger).value > (setted_m_u as LiteralInteger).value) {
				error("Subsetting.subsettingFeature("+ subsettingFeatureName + ")'s upperBound multiplicity(" +  (setting_m_u as LiteralInteger).value + ") shall be less than or equal to Subsetting.subsettedFeature(" + subsettedFeatureName + ")'s upperBound multiplicity(" + (setted_m_u as LiteralInteger).value + ").", sub, 
					SysMLPackage.eINSTANCE.subsetting_SubsettingFeature, org.omg.sysml.xtext.validation.SysMLValidator.INVALID_SUBSETTING_MULTIPLICITYCONFORMANCE)
			}			
		}

		// Uniqueness conformance
		if (sub.subsettedFeature !== null && sub.subsettedFeature.unique && sub.subsettingFeature !== null && !sub.subsettingFeature.unique){
			if (setting_m_u instanceof LiteralUnbounded || (setting_m_u as LiteralInteger).value > 1) {//less than or equal to 1 is ok
				error("Subsetting.subsettedFeature(" + subsettedFeatureName +") is unique then subsettingFeature(" + subsettingFeatureName + ") shall be unique.", sub, 
						SysMLPackage.eINSTANCE.subsetting_SubsettingFeature, org.omg.sysml.xtext.validation.SysMLValidator.INVALID_SUBSETTING_UNIQUENESS_CONFORMANCE)
			}
		}
					
		// OwningtType conformance (only check for Redefinition)
		if (sub instanceof Redefinition) {
			if (subsettingOwningType == subsettedOwningType){
				error("Redefinition.redefiningFeature.owningType shall not the same as Redefinition.redefinedFeature.owningType", sub, 
					SysMLPackage.eINSTANCE.redefinition_RedefinedFeature, org.omg.sysml.xtext.validation.SysMLValidator.INVALID_REDEFINITION_OWNINGTYPECONFORMANCE)
			}
			else if (!subsettingOwningType.conformsTo(subsettedOwningType)){
				error("Redefinition.redefiningFeature.owningType(" + sub.subsettingFeature + ") is not the same/direct/indirect specialization of Redefinition.redefinedFeature.owningType(" + sub.subsettedFeature.name + ")", sub, 
				SysMLPackage.eINSTANCE.redefinition_RedefinedFeature, org.omg.sysml.xtext.validation.SysMLValidator.INVALID_REDEFINITION_OWNINGTYPECONFORMANCE)
			}
		}
	}
	
	protected def boolean conformsTo(Type subtype, Type supertype) {
		subtype.conformsTo(supertype, newHashSet);
	}
	
	// Note: Generalizations are allowed to be cyclic.
	protected def boolean conformsTo(Type subtype, Type supertype, Set<Type> visited) {
		if (subtype === supertype) {
			true
		} else {
			visited.add(subtype)
			if (subtype.isConjugated) {
				var originalType = subtype.ownedConjugator.originalType
				!visited.contains(originalType) && originalType.conformsTo(supertype)
			} else {
				subtype.ownedGeneralization.exists[!visited.contains(general) && general.conformsTo(supertype, visited)]
			}
		}
	}

}
