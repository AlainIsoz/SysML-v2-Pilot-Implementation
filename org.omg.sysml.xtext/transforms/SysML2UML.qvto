/*****************************************************************************
 * Copyright (c) 2018 Model Driven Solutions, Inc.
 *    
 * Contributors:
 *  Ed Seidewitz
 * 
 *****************************************************************************/

modeltype SysML uses "http://www.omg.org/spec/SysML";
modeltype UML uses "http://www.eclipse.org/uml2/5.0.0/UML";
modeltype Ecore uses "http://www.eclipse.org/emf/2002/Ecore";

transformation SysML2UML(in sysml: SysML, out uml: UML);

main() {
	var model := object Model {
		name := "Model";
		packagedElement += sysml.rootObjects()[Container]->map toPackageableElement();
	};
}

/* CONTAINERS */

// PackageMember

abstract mapping PackageMember::toNamedElement(): NamedElement {
	name := self.name;
}

abstract mapping PackageMember::toPackageableElement(): PackageableElement
	disjuncts
		Container::toPackageableElement,
		Feature::toPackageableElement,
		Part::toInstanceSpecification;

// Container

abstract mapping Container::toPackageableElement(): PackageableElement
	disjuncts
		Package::toPackage,
		Definition::toClassifier;

// Package

mapping SysML::Package::toPackage(): UML::Package
	inherits PackageMember::toNamedElement {
	packagedElement += self.member->map toPackageableElement();
	packagedElement += self.member[Part]->map toClass();
}

/* DEFINITIONS */

// Definition

mapping Definition::toClassifier(): Classifier
	disjuncts
		ValueTypeDefinition::toDataType,
		BlockDefinition::toClass;

// ValueTypeDefinition
	
mapping ValueTypeDefinition::toDataType(): DataType 
	inherits PackageMember::toNamedElement {
	if self.type <> null then {
		generalization += object Generalization {
			general := self.type.map toDataType();
		}
	} endif;
	ownedAttribute := self.feature->map toProperty();
}

// BlockDefinition

mapping BlockDefinition::toClass(): Class 
	inherits PackageMember::toNamedElement {
	ownedAttribute := self.feature->map toProperty();
}

/* USAGES */

// Part

helper Part::mapType(): Classifier {
	return if self.definition <> null then self.definition.map toClassifier() 
		   else if self.base <> null then self.base.map toClass()
		   else null 
		   endif endif;
}

abstract mapping Part::toNamedElement(): NamedElement 
	inherits PackageMember::toNamedElement {
	if name = null then {
		name := self.base.name;
	} endif;
}

mapping Part::toProperty(): Property
	inherits Part::toNamedElement {
	type := self.late resolveone(Class);
	if self.multiplicity <> null then {
		self.multiplicity.mapMultiplicity(result);
	} endif;
	aggregation := AggregationKind::composite;
}

mapping Part::toInstanceSpecification(): InstanceSpecification
	inherits Part::toNamedElement {
	classifier += self.mapType();
}

mapping Part::toClass(): Class
	inherits Part::toNamedElement {
	if name = null then {
		name := self.base.name;
	} endif;
	var features := self.member->map toFeature();
	ownedAttribute += features[Property];
	ownedConnector += features[UML::Connector];
	nestedClassifier += self.member[Part]->map toClass();
	
	var superclass := self.mapType();		
	if superclass <> null then {
		generalization += object Generalization {
			general := superclass;
		}
	} endif;
}

// Member

mapping Member::toFeature(): UML::Feature
	disjuncts
		Feature::toFeature,
		Part::toProperty,
		Connector::toConnector;
		
// Multiplicity

helper Multiplicity::mapMultiplicity(inout element: MultiplicityElement) {
	if self.upperBound.unbounded then {
		element.upper := -1;
	} else if self.upperBound.value <> null then {
		element.upper := self.upperBound.value;
	} else {
		element.upperValue :=object OpaqueExpression {
			body := self.upperBound._var;
		};
	} endif endif;
	if self.lowerBound.value <> null then {
		element.lower := self.lowerBound.value;
	} else if self.lowerBound._var <> null then {
		element.lowerValue := object OpaqueExpression {
			body := self.lowerBound._var;
		}
	} else if self.upperBound.unbounded then {
		element.lower := 0;
	} else if element.upperValue <> null then {		
		element.lowerValue := element.upperValue.clone()
	} else {
		element.lower := element.upper;
	} endif endif endif endif;
}
		
/* FEATURES */

// Feature

mapping Feature::toFeature(): UML::Feature
	disjuncts
		BasicFeature::toProperty,
		ConnectableFeature::toProperty;

abstract mapping Feature::toProperty(): Property
	inherits PackageMember::toNamedElement {
	if self.definition <> null then {
		type := self.definition.map toClassifier();
	} endif;
	if self.multiplicity <> null then {
		self.multiplicity.mapMultiplicity(result);
	} endif;
}

mapping Feature::toPackageableElement(): PackageableElement
	disjuncts
		BasicFeature::toInstanceSpecification,
		ConnectableFeature::toInstanceSpecification;

abstract mapping Feature::toInstanceSpecification(): InstanceSpecification 
	inherits PackageMember::toNamedElement {
	if self.definition <> null then {
		classifier += self.definition.map toClassifier();
	} endif;
}

// BasicFeature

helper BasicFeature::mapExpression(): ValueSpecification {
	return if self.expression = null then null 
	       else self.expression.map toValueSpecification() 
	       endif;
}

mapping BasicFeature::toProperty(): Property
	inherits Feature::toProperty {
	defaultValue := self.mapExpression();
}

mapping BasicFeature::toInstanceSpecification(): InstanceSpecification
	inherits Feature::toInstanceSpecification {
	specification := self.mapExpression();
}

// ConnectableFeature

mapping ConnectableFeature::toProperty(): Port 
	inherits Feature::toProperty {
	isConjugated := self.direction.OUT <> null;
}

mapping ConnectableFeature::toInstanceSpecification(): InstanceSpecification
	inherits Feature::toInstanceSpecification {	
}

helper ConnectableFeature::mapToConnectorEnd(): ConnectorEnd {
	return object ConnectorEnd {
		role := self.late resolveone(Port);
		partWithPort := self.oclAsType(EObject).eContainer().late resolveone(Property);
	}
}

/* RELATIONSHIPS */

// Connector

mapping SysML::Connector::toConnector(): UML::Connector {
	name := self.name;
	_end += self.source.mapToConnectorEnd();
	_end += self.target.mapToConnectorEnd();
}

/* EXPRESSIONS */

abstract mapping Expression::toValueSpecification(): ValueSpecification
	disjuncts
		NumericLiteral::toLiteralSpecification,
		FeatureReferenceExpression::toOpaqueExpression;

mapping FeatureReferenceExpression::toOpaqueExpression(): OpaqueExpression {
	body += self.feature.name;
}

abstract mapping NumericLiteral::toLiteralSpecification(): LiteralSpecification
	disjuncts
		IntegerLiteral::toLiteralSpecification,
		RealLiteral::toLiteralSpecification;

mapping IntegerLiteral::toLiteralSpecification(): LiteralInteger {
	value := if self.sign.MINUS <> null then -self.value else value endif;
}

mapping RealLiteral::toLiteralSpecification(): LiteralReal {
	var image := self.integerPart.toString() + '.' + self.fractionPart.toString();
	value := image.toReal();
}

